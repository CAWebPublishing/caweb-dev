{
    "ƒ: zend_version": {
        "type": "function",
        "label": "zend_version()",
        "apply": "zend_version()",
        "info": "Returns a string containing the version of the currently running Zend Engine."
    },
    "ƒ: func_num_args": {
        "type": "function",
        "label": "func_num_args()",
        "apply": "func_num_args()",
        "info": "Gets the number of arguments passed to the function."
    },
    "ƒ: func_get_arg": {
        "type": "function",
        "label": "func_get_arg( $position:int )",
        "apply": "func_get_arg( $position:int )",
        "info": "Gets the specified argument from a user-defined function's argument list."
    },
    "ƒ: func_get_args": {
        "type": "function",
        "label": "func_get_args()",
        "apply": "func_get_args()",
        "info": "Gets an array of the function's argument list."
    },
    "ƒ: strlen": {
        "type": "function",
        "label": "strlen( $string:string )",
        "apply": "strlen( $string:string )",
        "info": "Returns the length of the given string. "
    },
    "ƒ: strcmp": {
        "type": "function",
        "label": "strcmp( $string1:string, $string2:string )",
        "apply": "strcmp( $string1:string, $string2:string )",
        "info": "Note that this comparison is case sensitive."
    },
    "ƒ: strncmp": {
        "type": "function",
        "label": "strncmp( $string1:string, $string2:string, $length:int )",
        "apply": "strncmp( $string1:string, $string2:string, $length:int )",
        "info": "This function is similar to strcmp(), with the difference that you can specify the (upper limit of the) number of characters from each string to be used in the comparison."
    },
    "ƒ: strcasecmp": {
        "type": "function",
        "label": "strcasecmp( $string1:string, $string2:string )",
        "apply": "strcasecmp( $string1:string, $string2:string )",
        "info": "Binary safe case-insensitive string comparison.The comparison is not locale aware; only ASCII letters are compared in a case-insensitive way."
    },
    "ƒ: strncasecmp": {
        "type": "function",
        "label": "strncasecmp( $string1:string, $string2:string, $length:int )",
        "apply": "strncasecmp( $string1:string, $string2:string, $length:int )",
        "info": "This function is similar to strcasecmp(), with the difference that you can specify the (upper limit of the) number of characters from each string to be used in the comparison."
    },
    "ƒ: error_reporting": {
        "type": "function",
        "label": "error_reporting( $error_level:?int )",
        "apply": "error_reporting( $error_level:?int )",
        "info": "The error_reporting() function sets the error_reporting directive at runtime.  PHP has many levels of errors, using this function sets that level for the duration (runtime) of your script. If the optional error_level is not set, error_reporting() will just return the current error reporting level."
    },
    "ƒ: define": {
        "type": "function",
        "label": "define( $constant_name:string, $value:mixed, $case_insensitive:bool )",
        "apply": "define( $constant_name:string, $value:mixed, $case_insensitive:bool )",
        "info": "Defines a named constant at runtime."
    },
    "ƒ: defined": {
        "type": "function",
        "label": "defined( $constant_name:string )",
        "apply": "defined( $constant_name:string )",
        "info": "Checks whether the given constant exists and is defined."
    },
    "ƒ: get_class": {
        "type": "function",
        "label": "get_class( $object:object )",
        "apply": "get_class( $object:object )",
        "info": "Gets the name of the class of the given object."
    },
    "ƒ: get_called_class": {
        "type": "function",
        "label": "get_called_class()",
        "apply": "get_called_class()",
        "info": "Gets the name of the class the static method is called in."
    },
    "ƒ: get_parent_class": {
        "type": "function",
        "label": "get_parent_class( $object_or_class:object|string )",
        "apply": "get_parent_class( $object_or_class:object|string )",
        "info": "Retrieves the parent class name for object or class."
    },
    "ƒ: is_subclass_of": {
        "type": "function",
        "label": "is_subclass_of( $object_or_class:mixed, $class:string, $allow_string:bool )",
        "apply": "is_subclass_of( $object_or_class:mixed, $class:string, $allow_string:bool )",
        "info": "Checks if the given object_or_class has the class class as one of its parents or implements it."
    },
    "ƒ: is_a": {
        "type": "function",
        "label": "is_a( $object_or_class:mixed, $class:string, $allow_string:bool )",
        "apply": "is_a( $object_or_class:mixed, $class:string, $allow_string:bool )",
        "info": "Checks if the given object_or_class is of this object type or has this object type as one of its supertypes."
    },
    "ƒ: get_class_vars": {
        "type": "function",
        "label": "get_class_vars( $class:string )",
        "apply": "get_class_vars( $class:string )",
        "info": "Get the default properties of the given class."
    },
    "ƒ: get_object_vars": {
        "type": "function",
        "label": "get_object_vars( $object:object )",
        "apply": "get_object_vars( $object:object )",
        "info": "Gets the accessible non-static properties of the given object according to scope."
    },
    "ƒ: get_mangled_object_vars": {
        "type": "function",
        "label": "get_mangled_object_vars( $object:object )",
        "apply": "get_mangled_object_vars( $object:object )",
        "info": "Returns an array whose elements are the object's properties. The keys are the member variable names, with a few notable exceptions: private variables have the class name prepended to the variable name,and protected variables have a * prepended to the variable name.These prepended values have NUL bytes on either side.Uninitialized typed properties are silently discarded."
    },
    "ƒ: get_class_methods": {
        "type": "function",
        "label": "get_class_methods( $object_or_class:object|string )",
        "apply": "get_class_methods( $object_or_class:object|string )",
        "info": "Gets the class methods names."
    },
    "ƒ: method_exists": {
        "type": "function",
        "label": "method_exists( $object_or_class:, $method:string )",
        "apply": "method_exists( $object_or_class:, $method:string )",
        "info": "Checks if the class method exists in the given object_or_class."
    },
    "ƒ: property_exists": {
        "type": "function",
        "label": "property_exists( $object_or_class:, $property:string )",
        "apply": "property_exists( $object_or_class:, $property:string )",
        "info": "This function checks if the given property exists in the specified class."
    },
    "ƒ: class_exists": {
        "type": "function",
        "label": "class_exists( $class:string, $autoload:bool )",
        "apply": "class_exists( $class:string, $autoload:bool )",
        "info": "This function checks whether or not the given class has been defined."
    },
    "ƒ: interface_exists": {
        "type": "function",
        "label": "interface_exists( $interface:string, $autoload:bool )",
        "apply": "interface_exists( $interface:string, $autoload:bool )",
        "info": "Checks if the given interface has been defined."
    },
    "ƒ: trait_exists": {
        "type": "function",
        "label": "trait_exists( $trait:string, $autoload:bool )",
        "apply": "trait_exists( $trait:string, $autoload:bool )",
        "info": ""
    },
    "ƒ: enum_exists": {
        "type": "function",
        "label": "enum_exists( $enum:string, $autoload:bool )",
        "apply": "enum_exists( $enum:string, $autoload:bool )",
        "info": "This function checks whether or not the given enum has been defined."
    },
    "ƒ: function_exists": {
        "type": "function",
        "label": "function_exists( $function:string )",
        "apply": "function_exists( $function:string )",
        "info": "Checks the list of defined functions, both built-in (internal) and user-defined, for function. "
    },
    "ƒ: class_alias": {
        "type": "function",
        "label": "class_alias( $class:string, $alias:string, $autoload:bool )",
        "apply": "class_alias( $class:string, $alias:string, $autoload:bool )",
        "info": "Creates an alias named alias based on the user defined class class.The aliased class is exactly the same as the original class."
    },
    "ƒ: get_included_files": {
        "type": "function",
        "label": "get_included_files()",
        "apply": "get_included_files()",
        "info": "Gets the names of all files that have been included using include, include_once,require or require_once."
    },
    "ƒ: get_required_files": {
        "type": "function",
        "label": "get_required_files()",
        "apply": "get_required_files()",
        "info": "This function is an alias of:  get_included_files()."
    },
    "ƒ: trigger_error": {
        "type": "function",
        "label": "trigger_error( $message:string, $error_level:int )",
        "apply": "trigger_error( $message:string, $error_level:int )",
        "info": "Used to trigger a user error condition, it can be used in conjunction with the built-in error handler, or with a user defined function that has been set as the new error handler (set_error_handler()). "
    },
    "ƒ: user_error": {
        "type": "function",
        "label": "user_error( $message:string, $error_level:int )",
        "apply": "user_error( $message:string, $error_level:int )",
        "info": "This function is an alias of:  trigger_error()."
    },
    "ƒ: set_error_handler": {
        "type": "function",
        "label": "set_error_handler( $callback:?callable, $error_levels:int )",
        "apply": "set_error_handler( $callback:?callable, $error_levels:int )",
        "info": "Sets a user function (callback) to handle errors in a script."
    },
    "ƒ: restore_error_handler": {
        "type": "function",
        "label": "restore_error_handler()",
        "apply": "restore_error_handler()",
        "info": "Used after changing the error handler function using set_error_handler(), to revert to the previous error handler (which could be the built-in or a user defined function). "
    },
    "ƒ: set_exception_handler": {
        "type": "function",
        "label": "set_exception_handler( $callback:?callable )",
        "apply": "set_exception_handler( $callback:?callable )",
        "info": "Sets the default exception handler if an exception is not caught within a try\/catch block. Execution will stop after the callback is called."
    },
    "ƒ: restore_exception_handler": {
        "type": "function",
        "label": "restore_exception_handler()",
        "apply": "restore_exception_handler()",
        "info": "Used after changing the exception handler function using set_exception_handler(), to revert to the previous exception handler (which could be the built-in or a user defined function)."
    },
    "ƒ: get_declared_classes": {
        "type": "function",
        "label": "get_declared_classes()",
        "apply": "get_declared_classes()",
        "info": "Gets the declared classes."
    },
    "ƒ: get_declared_traits": {
        "type": "function",
        "label": "get_declared_traits()",
        "apply": "get_declared_traits()",
        "info": ""
    },
    "ƒ: get_declared_interfaces": {
        "type": "function",
        "label": "get_declared_interfaces()",
        "apply": "get_declared_interfaces()",
        "info": "Gets the declared interfaces."
    },
    "ƒ: get_defined_functions": {
        "type": "function",
        "label": "get_defined_functions( $exclude_disabled:bool )",
        "apply": "get_defined_functions( $exclude_disabled:bool )",
        "info": "Gets an array of all defined functions."
    },
    "ƒ: get_defined_vars": {
        "type": "function",
        "label": "get_defined_vars()",
        "apply": "get_defined_vars()",
        "info": "This function returns a multidimensional array containing a list of all defined variables, be them environment, server or user-defined variables, within the scope that get_defined_vars() is called. "
    },
    "ƒ: get_resource_type": {
        "type": "function",
        "label": "get_resource_type( $resource: )",
        "apply": "get_resource_type( $resource: )",
        "info": "This function gets the type of the given resource."
    },
    "ƒ: get_resource_id": {
        "type": "function",
        "label": "get_resource_id( $resource: )",
        "apply": "get_resource_id( $resource: )",
        "info": "This function provides a type-safe way for generating the integer identifier for a resource."
    },
    "ƒ: get_resources": {
        "type": "function",
        "label": "get_resources( $type:?string )",
        "apply": "get_resources( $type:?string )",
        "info": "Returns an array of all currently active resources, optionally filtered by resource type."
    },
    "ƒ: get_loaded_extensions": {
        "type": "function",
        "label": "get_loaded_extensions( $zend_extensions:bool )",
        "apply": "get_loaded_extensions( $zend_extensions:bool )",
        "info": "This function returns the names of all the modules compiled and loaded in the PHP interpreter."
    },
    "ƒ: get_defined_constants": {
        "type": "function",
        "label": "get_defined_constants( $categorize:bool )",
        "apply": "get_defined_constants( $categorize:bool )",
        "info": "Returns the names and values of all the constants currently defined.This includes those created by extensions as well as those created with the define() function."
    },
    "ƒ: debug_backtrace": {
        "type": "function",
        "label": "debug_backtrace( $options:int, $limit:int )",
        "apply": "debug_backtrace( $options:int, $limit:int )",
        "info": "debug_backtrace() generates a PHP backtrace."
    },
    "ƒ: debug_print_backtrace": {
        "type": "function",
        "label": "debug_print_backtrace( $options:int, $limit:int )",
        "apply": "debug_print_backtrace( $options:int, $limit:int )",
        "info": "debug_print_backtrace() prints a PHP backtrace. It prints the function calls, included\/required files and eval()ed stuff."
    },
    "ƒ: extension_loaded": {
        "type": "function",
        "label": "extension_loaded( $extension:string )",
        "apply": "extension_loaded( $extension:string )",
        "info": "Finds out whether the extension is loaded."
    },
    "ƒ: get_extension_funcs": {
        "type": "function",
        "label": "get_extension_funcs( $extension:string )",
        "apply": "get_extension_funcs( $extension:string )",
        "info": "This function returns the names of all the functions defined in the module indicated by extension."
    },
    "ƒ: gc_mem_caches": {
        "type": "function",
        "label": "gc_mem_caches()",
        "apply": "gc_mem_caches()",
        "info": "Reclaims memory used by the Zend Engine memory manager."
    },
    "ƒ: gc_collect_cycles": {
        "type": "function",
        "label": "gc_collect_cycles()",
        "apply": "gc_collect_cycles()",
        "info": "Forces collection of any existing garbage cycles."
    },
    "ƒ: gc_enabled": {
        "type": "function",
        "label": "gc_enabled()",
        "apply": "gc_enabled()",
        "info": "Returns status of the circular reference collector."
    },
    "ƒ: gc_enable": {
        "type": "function",
        "label": "gc_enable()",
        "apply": "gc_enable()",
        "info": "Activates the circular reference collector, setting zend.enable_gc to 1."
    },
    "ƒ: gc_disable": {
        "type": "function",
        "label": "gc_disable()",
        "apply": "gc_disable()",
        "info": "Deactivates the circular reference collector, setting zend.enable_gc to 0."
    },
    "ƒ: gc_status": {
        "type": "function",
        "label": "gc_status()",
        "apply": "gc_status()",
        "info": "Gets information about the current state of the garbage collector."
    },
    "ƒ: strtotime": {
        "type": "function",
        "label": "strtotime( $datetime:string, $baseTimestamp:?int )",
        "apply": "strtotime( $datetime:string, $baseTimestamp:?int )",
        "info": "The function expects to be given a string containing an English date format and will try to parse that format into a Unix timestamp (the number of seconds since January 1 1970 00:00:00 UTC), relative to the timestamp given in baseTimestamp, or the current time if baseTimestamp is not supplied.  The date string parsing is defined in Date and Time Formats, and has several subtle considerations.  Reviewing the full details there is strongly recommended."
    },
    "ƒ: date": {
        "type": "function",
        "label": "date( $format:string, $timestamp:?int )",
        "apply": "date( $format:string, $timestamp:?int )",
        "info": "Returns a string formatted according to the given format string using the given integer timestamp (Unix timestamp) or the current time if no timestamp is given. In other words, timestamp is optional and defaults to the value of time()."
    },
    "ƒ: idate": {
        "type": "function",
        "label": "idate( $format:string, $timestamp:?int )",
        "apply": "idate( $format:string, $timestamp:?int )",
        "info": "Returns a number formatted according to the given format string using the given integer timestamp or the current local time if no timestamp is given. In other words, timestamp is optional and defaults to the value of time()."
    },
    "ƒ: gmdate": {
        "type": "function",
        "label": "gmdate( $format:string, $timestamp:?int )",
        "apply": "gmdate( $format:string, $timestamp:?int )",
        "info": "Identical to the date() function except that the time returned is Greenwich Mean Time (GMT). "
    },
    "ƒ: mktime": {
        "type": "function",
        "label": "mktime( $hour:int, $minute:?int, $second:?int, $month:?int, $day:?int, $year:?int )",
        "apply": "mktime( $hour:int, $minute:?int, $second:?int, $month:?int, $day:?int, $year:?int )",
        "info": "Returns the Unix timestamp corresponding to the arguments given. This timestamp is a long integer containing the number of seconds between the Unix Epoch (January 1 1970 00:00:00 GMT) and the time specified."
    },
    "ƒ: gmmktime": {
        "type": "function",
        "label": "gmmktime( $hour:int, $minute:?int, $second:?int, $month:?int, $day:?int, $year:?int )",
        "apply": "gmmktime( $hour:int, $minute:?int, $second:?int, $month:?int, $day:?int, $year:?int )",
        "info": "Identical to mktime() except the passed parameters represents a GMT date. gmmktime() internally uses mktime()so only times valid in derived local time can be used."
    },
    "ƒ: checkdate": {
        "type": "function",
        "label": "checkdate( $month:int, $day:int, $year:int )",
        "apply": "checkdate( $month:int, $day:int, $year:int )",
        "info": "Checks the validity of the date formed by the arguments. A date is considered valid if each parameter is properly defined."
    },
    "ƒ: strftime": {
        "type": "function",
        "label": "strftime( $format:string, $timestamp:?int )",
        "apply": "strftime( $format:string, $timestamp:?int )",
        "info": "Format the time and\/or date according to locale settings. Month and weekday names and other language-dependent strings respect the current locale set with setlocale()."
    },
    "ƒ: gmstrftime": {
        "type": "function",
        "label": "gmstrftime( $format:string, $timestamp:?int )",
        "apply": "gmstrftime( $format:string, $timestamp:?int )",
        "info": "Behaves the same as strftime() except that the time returned is Greenwich Mean Time (GMT). For example, when run in Eastern Standard Time (GMT -0500), the first line below prints \"Dec 31 1998 20:00:00\", while the second prints \"Jan 01 1999 01:00:00\"."
    },
    "ƒ: time": {
        "type": "function",
        "label": "time()",
        "apply": "time()",
        "info": "Returns the current time measured in the number of seconds since the Unix Epoch (January 1 1970 00:00:00 GMT)."
    },
    "ƒ: localtime": {
        "type": "function",
        "label": "localtime( $timestamp:?int, $associative:bool )",
        "apply": "localtime( $timestamp:?int, $associative:bool )",
        "info": "The localtime() function returns an array identical to that of the structure returned by the C function call."
    },
    "ƒ: getdate": {
        "type": "function",
        "label": "getdate( $timestamp:?int )",
        "apply": "getdate( $timestamp:?int )",
        "info": "Returns an associative array containing the date information of the timestamp, or the current local time if timestamp is omitted or null."
    },
    "ƒ: date_create": {
        "type": "function",
        "label": "date_create( $datetime:string, $timezone:?DateTimeZone )",
        "apply": "date_create( $datetime:string, $timezone:?DateTimeZone )",
        "info": "This is the procedural version of DateTime::__construct()."
    },
    "ƒ: date_create_immutable": {
        "type": "function",
        "label": "date_create_immutable( $datetime:string, $timezone:?DateTimeZone )",
        "apply": "date_create_immutable( $datetime:string, $timezone:?DateTimeZone )",
        "info": "This is the procedural version of DateTimeImmutable::__construct()."
    },
    "ƒ: date_create_from_format": {
        "type": "function",
        "label": "date_create_from_format( $format:string, $datetime:string, $timezone:?DateTimeZone )",
        "apply": "date_create_from_format( $format:string, $datetime:string, $timezone:?DateTimeZone )",
        "info": "This function is an alias of:  DateTime::createFromFormat()"
    },
    "ƒ: date_create_immutable_from_format": {
        "type": "function",
        "label": "date_create_immutable_from_format( $format:string, $datetime:string, $timezone:?DateTimeZone )",
        "apply": "date_create_immutable_from_format( $format:string, $datetime:string, $timezone:?DateTimeZone )",
        "info": "This function is an alias of:  DateTimeImmutable::createFromFormat()"
    },
    "ƒ: date_parse": {
        "type": "function",
        "label": "date_parse( $datetime:string )",
        "apply": "date_parse( $datetime:string )",
        "info": "date_parse() parses the given datetime string according to the same rules as strtotime() and DateTimeImmutable::__construct(). Instead of returning a Unix timestamp (with strtotime()) or a DateTimeImmutable object (with DateTimeImmutable::__construct()), it returns an associative array with the information that it could detect in the given datetime string."
    },
    "ƒ: date_parse_from_format": {
        "type": "function",
        "label": "date_parse_from_format( $format:string, $datetime:string )",
        "apply": "date_parse_from_format( $format:string, $datetime:string )",
        "info": "Returns associative array with detailed info about given date\/time."
    },
    "ƒ: date_get_last_errors": {
        "type": "function",
        "label": "date_get_last_errors()",
        "apply": "date_get_last_errors()",
        "info": "This function is an alias of:  DateTimeImmutable::getLastErrors()"
    },
    "ƒ: date_format": {
        "type": "function",
        "label": "date_format( $object:DateTimeInterface, $format:string )",
        "apply": "date_format( $object:DateTimeInterface, $format:string )",
        "info": "This function is an alias of:  DateTime::format()"
    },
    "ƒ: date_modify": {
        "type": "function",
        "label": "date_modify( $object:DateTime, $modifier:string )",
        "apply": "date_modify( $object:DateTime, $modifier:string )",
        "info": "This function is an alias of:  DateTime::modify()"
    },
    "ƒ: date_add": {
        "type": "function",
        "label": "date_add( $object:DateTime, $interval:DateInterval )",
        "apply": "date_add( $object:DateTime, $interval:DateInterval )",
        "info": "This function is an alias of:  DateTime::add()"
    },
    "ƒ: date_sub": {
        "type": "function",
        "label": "date_sub( $object:DateTime, $interval:DateInterval )",
        "apply": "date_sub( $object:DateTime, $interval:DateInterval )",
        "info": "This function is an alias of:  DateTime::sub()"
    },
    "ƒ: date_timezone_get": {
        "type": "function",
        "label": "date_timezone_get( $object:DateTimeInterface )",
        "apply": "date_timezone_get( $object:DateTimeInterface )",
        "info": "This function is an alias of:  DateTime::getTimezone()"
    },
    "ƒ: date_timezone_set": {
        "type": "function",
        "label": "date_timezone_set( $object:DateTime, $timezone:DateTimeZone )",
        "apply": "date_timezone_set( $object:DateTime, $timezone:DateTimeZone )",
        "info": "This function is an alias of:  DateTime::setTimezone()"
    },
    "ƒ: date_offset_get": {
        "type": "function",
        "label": "date_offset_get( $object:DateTimeInterface )",
        "apply": "date_offset_get( $object:DateTimeInterface )",
        "info": "This function is an alias of:  DateTime::getOffset()"
    },
    "ƒ: date_diff": {
        "type": "function",
        "label": "date_diff( $baseObject:DateTimeInterface, $targetObject:DateTimeInterface, $absolute:bool )",
        "apply": "date_diff( $baseObject:DateTimeInterface, $targetObject:DateTimeInterface, $absolute:bool )",
        "info": "This function is an alias of:  DateTime::diff()"
    },
    "ƒ: date_time_set": {
        "type": "function",
        "label": "date_time_set( $object:DateTime, $hour:int, $minute:int, $second:int, $microsecond:int )",
        "apply": "date_time_set( $object:DateTime, $hour:int, $minute:int, $second:int, $microsecond:int )",
        "info": "This function is an alias of:  DateTime::setTime()"
    },
    "ƒ: date_date_set": {
        "type": "function",
        "label": "date_date_set( $object:DateTime, $year:int, $month:int, $day:int )",
        "apply": "date_date_set( $object:DateTime, $year:int, $month:int, $day:int )",
        "info": "This function is an alias of:  DateTime::setDate()"
    },
    "ƒ: date_isodate_set": {
        "type": "function",
        "label": "date_isodate_set( $object:DateTime, $year:int, $week:int, $dayOfWeek:int )",
        "apply": "date_isodate_set( $object:DateTime, $year:int, $week:int, $dayOfWeek:int )",
        "info": "This function is an alias of:  DateTime::setISODate()"
    },
    "ƒ: date_timestamp_set": {
        "type": "function",
        "label": "date_timestamp_set( $object:DateTime, $timestamp:int )",
        "apply": "date_timestamp_set( $object:DateTime, $timestamp:int )",
        "info": "This function is an alias of:  DateTime::setTimestamp()"
    },
    "ƒ: date_timestamp_get": {
        "type": "function",
        "label": "date_timestamp_get( $object:DateTimeInterface )",
        "apply": "date_timestamp_get( $object:DateTimeInterface )",
        "info": "This function is an alias of:  DateTime::getTimestamp()"
    },
    "ƒ: timezone_open": {
        "type": "function",
        "label": "timezone_open( $timezone:string )",
        "apply": "timezone_open( $timezone:string )",
        "info": "This function is an alias of:  DateTimeZone::__construct()"
    },
    "ƒ: timezone_name_get": {
        "type": "function",
        "label": "timezone_name_get( $object:DateTimeZone )",
        "apply": "timezone_name_get( $object:DateTimeZone )",
        "info": "This function is an alias of:  DateTimeZone::getName()"
    },
    "ƒ: timezone_name_from_abbr": {
        "type": "function",
        "label": "timezone_name_from_abbr( $abbr:string, $utcOffset:int, $isDST:int )",
        "apply": "timezone_name_from_abbr( $abbr:string, $utcOffset:int, $isDST:int )",
        "info": null
    },
    "ƒ: timezone_offset_get": {
        "type": "function",
        "label": "timezone_offset_get( $object:DateTimeZone, $datetime:DateTimeInterface )",
        "apply": "timezone_offset_get( $object:DateTimeZone, $datetime:DateTimeInterface )",
        "info": "This function is an alias of:  DateTimeZone::getOffset()"
    },
    "ƒ: timezone_transitions_get": {
        "type": "function",
        "label": "timezone_transitions_get( $object:DateTimeZone, $timestampBegin:int, $timestampEnd:int )",
        "apply": "timezone_transitions_get( $object:DateTimeZone, $timestampBegin:int, $timestampEnd:int )",
        "info": "This function is an alias of:  DateTimeZone::getTransitions()"
    },
    "ƒ: timezone_location_get": {
        "type": "function",
        "label": "timezone_location_get( $object:DateTimeZone )",
        "apply": "timezone_location_get( $object:DateTimeZone )",
        "info": "This function is an alias of:  DateTimeZone::getLocation()"
    },
    "ƒ: timezone_identifiers_list": {
        "type": "function",
        "label": "timezone_identifiers_list( $timezoneGroup:int, $countryCode:?string )",
        "apply": "timezone_identifiers_list( $timezoneGroup:int, $countryCode:?string )",
        "info": "This function is an alias of:  DateTimeZone::listIdentifiers()"
    },
    "ƒ: timezone_abbreviations_list": {
        "type": "function",
        "label": "timezone_abbreviations_list()",
        "apply": "timezone_abbreviations_list()",
        "info": "This function is an alias of:  DateTimeZone::listAbbreviations()"
    },
    "ƒ: timezone_version_get": {
        "type": "function",
        "label": "timezone_version_get()",
        "apply": "timezone_version_get()",
        "info": "Returns the current version of the timezonedb."
    },
    "ƒ: date_interval_create_from_date_string": {
        "type": "function",
        "label": "date_interval_create_from_date_string( $datetime:string )",
        "apply": "date_interval_create_from_date_string( $datetime:string )",
        "info": "This function is an alias of:  DateInterval::createFromDateString()"
    },
    "ƒ: date_interval_format": {
        "type": "function",
        "label": "date_interval_format( $object:DateInterval, $format:string )",
        "apply": "date_interval_format( $object:DateInterval, $format:string )",
        "info": "This function is an alias of:  DateInterval::format()"
    },
    "ƒ: date_default_timezone_set": {
        "type": "function",
        "label": "date_default_timezone_set( $timezoneId:string )",
        "apply": "date_default_timezone_set( $timezoneId:string )",
        "info": "date_default_timezone_set() sets the default timezone used by all date\/time functions."
    },
    "ƒ: date_default_timezone_get": {
        "type": "function",
        "label": "date_default_timezone_get()",
        "apply": "date_default_timezone_get()",
        "info": "In order of preference, this function returns the default timezone by:"
    },
    "ƒ: date_sunrise": {
        "type": "function",
        "label": "date_sunrise( $timestamp:int, $returnFormat:int, $latitude:?float, $longitude:?float, $zenith:?float, $utcOffset:?float )",
        "apply": "date_sunrise( $timestamp:int, $returnFormat:int, $latitude:?float, $longitude:?float, $zenith:?float, $utcOffset:?float )",
        "info": "date_sunrise() returns the sunrise time for a given day (specified as a timestamp) and location."
    },
    "ƒ: date_sunset": {
        "type": "function",
        "label": "date_sunset( $timestamp:int, $returnFormat:int, $latitude:?float, $longitude:?float, $zenith:?float, $utcOffset:?float )",
        "apply": "date_sunset( $timestamp:int, $returnFormat:int, $latitude:?float, $longitude:?float, $zenith:?float, $utcOffset:?float )",
        "info": "date_sunset() returns the sunset time for a given day (specified as a timestamp) and location."
    },
    "ƒ: date_sun_info": {
        "type": "function",
        "label": "date_sun_info( $timestamp:int, $latitude:float, $longitude:float )",
        "apply": "date_sun_info( $timestamp:int, $latitude:float, $longitude:float )",
        "info": null
    },
    "ƒ: libxml_set_streams_context": {
        "type": "function",
        "label": "libxml_set_streams_context( $context: )",
        "apply": "libxml_set_streams_context( $context: )",
        "info": "Sets the streams context for the next libxml document load or write."
    },
    "ƒ: libxml_use_internal_errors": {
        "type": "function",
        "label": "libxml_use_internal_errors( $use_errors:?bool )",
        "apply": "libxml_use_internal_errors( $use_errors:?bool )",
        "info": "libxml_use_internal_errors() allows you to disable standard libxml errors and enable user error handling."
    },
    "ƒ: libxml_get_last_error": {
        "type": "function",
        "label": "libxml_get_last_error()",
        "apply": "libxml_get_last_error()",
        "info": "Retrieve last error from libxml."
    },
    "ƒ: libxml_get_errors": {
        "type": "function",
        "label": "libxml_get_errors()",
        "apply": "libxml_get_errors()",
        "info": "Retrieve array of errors."
    },
    "ƒ: libxml_clear_errors": {
        "type": "function",
        "label": "libxml_clear_errors()",
        "apply": "libxml_clear_errors()",
        "info": "libxml_clear_errors() clears the libxml error buffer."
    },
    "ƒ: libxml_disable_entity_loader": {
        "type": "function",
        "label": "libxml_disable_entity_loader( $disable:bool )",
        "apply": "libxml_disable_entity_loader( $disable:bool )",
        "info": "Disable\/enable the ability to load external entities.Note that disabling the loading of external entities may cause general issues with loading XML documents. However, as of libxml 2.9.0 entity substitution is disabled by default, so there is no need to disable the loading of external entities,unless there is the need to resolve internal entity references with LIBXML_NOENT.Generally, it is preferable to use libxml_set_external_entity_loader()to suppress loading of external entities."
    },
    "ƒ: libxml_set_external_entity_loader": {
        "type": "function",
        "label": "libxml_set_external_entity_loader( $resolver_function:?callable )",
        "apply": "libxml_set_external_entity_loader( $resolver_function:?callable )",
        "info": "Changes the default external entity loader.This can be used to suppress the expansion of arbitrary external entities to avoid XXE attacks,even when LIBXML_NOENT has been set for the respective operation,and is usually preferable over calling libxml_disable_entity_loader()."
    },
    "ƒ: openssl_x509_export_to_file": {
        "type": "function",
        "label": "openssl_x509_export_to_file( $certificate:OpenSSLCertificate|string, $output_filename:string, $no_text:bool )",
        "apply": "openssl_x509_export_to_file( $certificate:OpenSSLCertificate|string, $output_filename:string, $no_text:bool )",
        "info": "openssl_x509_export_to_file() stores certificate into a file named by output_filename in a PEM encoded format."
    },
    "ƒ: openssl_x509_export": {
        "type": "function",
        "label": "openssl_x509_export( $certificate:OpenSSLCertificate|string, $output:, $no_text:bool )",
        "apply": "openssl_x509_export( $certificate:OpenSSLCertificate|string, $output:, $no_text:bool )",
        "info": "openssl_x509_export() stores certificate into a string named by output in a PEM encoded format."
    },
    "ƒ: openssl_x509_fingerprint": {
        "type": "function",
        "label": "openssl_x509_fingerprint( $certificate:OpenSSLCertificate|string, $digest_algo:string, $binary:bool )",
        "apply": "openssl_x509_fingerprint( $certificate:OpenSSLCertificate|string, $digest_algo:string, $binary:bool )",
        "info": "openssl_x509_fingerprint() returns the digest of certificate as a string."
    },
    "ƒ: openssl_x509_check_private_key": {
        "type": "function",
        "label": "openssl_x509_check_private_key( $certificate:OpenSSLCertificate|string, $private_key: )",
        "apply": "openssl_x509_check_private_key( $certificate:OpenSSLCertificate|string, $private_key: )",
        "info": "Checks whether the given private_key is the private key that corresponds to certificate."
    },
    "ƒ: openssl_x509_verify": {
        "type": "function",
        "label": "openssl_x509_verify( $certificate:OpenSSLCertificate|string, $public_key: )",
        "apply": "openssl_x509_verify( $certificate:OpenSSLCertificate|string, $public_key: )",
        "info": "openssl_x509_verify() verifies that the certificate certificate was signed by the private key corresponding to public key public_key.  "
    },
    "ƒ: openssl_x509_parse": {
        "type": "function",
        "label": "openssl_x509_parse( $certificate:OpenSSLCertificate|string, $short_names:bool )",
        "apply": "openssl_x509_parse( $certificate:OpenSSLCertificate|string, $short_names:bool )",
        "info": "openssl_x509_parse() returns information about the supplied certificate, including fields such as subject name, issuer name, purposes, valid from and valid to dates etc."
    },
    "ƒ: openssl_x509_checkpurpose": {
        "type": "function",
        "label": "openssl_x509_checkpurpose( $certificate:OpenSSLCertificate|string, $purpose:int, $ca_info:array, $untrusted_certificates_file:?string )",
        "apply": "openssl_x509_checkpurpose( $certificate:OpenSSLCertificate|string, $purpose:int, $ca_info:array, $untrusted_certificates_file:?string )",
        "info": "openssl_x509_checkpurpose() examines a certificate to see if it can be used for the specified purpose."
    },
    "ƒ: openssl_x509_read": {
        "type": "function",
        "label": "openssl_x509_read( $certificate:OpenSSLCertificate|string )",
        "apply": "openssl_x509_read( $certificate:OpenSSLCertificate|string )",
        "info": "openssl_x509_read() parses the certificate supplied by certificate and returns an OpenSSLCertificate object for it."
    },
    "ƒ: openssl_x509_free": {
        "type": "function",
        "label": "openssl_x509_free( $certificate:OpenSSLCertificate )",
        "apply": "openssl_x509_free( $certificate:OpenSSLCertificate )",
        "info": "Note: "
    },
    "ƒ: openssl_pkcs12_export_to_file": {
        "type": "function",
        "label": "openssl_pkcs12_export_to_file( $certificate:OpenSSLCertificate|string, $output_filename:string, $private_key:, $passphrase:string, $options:array )",
        "apply": "openssl_pkcs12_export_to_file( $certificate:OpenSSLCertificate|string, $output_filename:string, $private_key:, $passphrase:string, $options:array )",
        "info": "openssl_pkcs12_export_to_file() stores certificate into a file named by output_filename in a PKCS#12 file format."
    },
    "ƒ: openssl_pkcs12_export": {
        "type": "function",
        "label": "openssl_pkcs12_export( $certificate:OpenSSLCertificate|string, $output:, $private_key:, $passphrase:string, $options:array )",
        "apply": "openssl_pkcs12_export( $certificate:OpenSSLCertificate|string, $output:, $private_key:, $passphrase:string, $options:array )",
        "info": "openssl_pkcs12_export() stores certificate into a string named by output in a PKCS#12 file format."
    },
    "ƒ: openssl_pkcs12_read": {
        "type": "function",
        "label": "openssl_pkcs12_read( $pkcs12:string, $certificates:, $passphrase:string )",
        "apply": "openssl_pkcs12_read( $pkcs12:string, $certificates:, $passphrase:string )",
        "info": "openssl_pkcs12_read() parses the PKCS#12 certificate store supplied by pkcs12 into a array named certificates."
    },
    "ƒ: openssl_csr_export_to_file": {
        "type": "function",
        "label": "openssl_csr_export_to_file( $csr:OpenSSLCertificateSigningRequest|string, $output_filename:string, $no_text:bool )",
        "apply": "openssl_csr_export_to_file( $csr:OpenSSLCertificateSigningRequest|string, $output_filename:string, $no_text:bool )",
        "info": "openssl_csr_export_to_file() takes the Certificate Signing Request represented by csr and saves it in PEM format into the file named by output_filename."
    },
    "ƒ: openssl_csr_export": {
        "type": "function",
        "label": "openssl_csr_export( $csr:OpenSSLCertificateSigningRequest|string, $output:, $no_text:bool )",
        "apply": "openssl_csr_export( $csr:OpenSSLCertificateSigningRequest|string, $output:, $no_text:bool )",
        "info": "openssl_csr_export() takes the Certificate Signing Request represented by csr and stores it in PEM format in output, which is passed by reference."
    },
    "ƒ: openssl_csr_sign": {
        "type": "function",
        "label": "openssl_csr_sign( $csr:OpenSSLCertificateSigningRequest|string, $ca_certificate:OpenSSLCertificate|string|null, $private_key:, $days:int, $options:?array, $serial:int )",
        "apply": "openssl_csr_sign( $csr:OpenSSLCertificateSigningRequest|string, $ca_certificate:OpenSSLCertificate|string|null, $private_key:, $days:int, $options:?array, $serial:int )",
        "info": "openssl_csr_sign() generates an x509 certificate from the given CSR."
    },
    "ƒ: openssl_csr_new": {
        "type": "function",
        "label": "openssl_csr_new( $distinguished_names:array, $private_key:, $options:?array, $extra_attributes:?array )",
        "apply": "openssl_csr_new( $distinguished_names:array, $private_key:, $options:?array, $extra_attributes:?array )",
        "info": "openssl_csr_new() generates a new CSR (Certificate Signing Request)based on the information provided by distinguished_names."
    },
    "ƒ: openssl_csr_get_subject": {
        "type": "function",
        "label": "openssl_csr_get_subject( $csr:OpenSSLCertificateSigningRequest|string, $short_names:bool )",
        "apply": "openssl_csr_get_subject( $csr:OpenSSLCertificateSigningRequest|string, $short_names:bool )",
        "info": "openssl_csr_get_subject() returns subject distinguished name information encoded in the csr including fields commonName (CN), organizationName (O), countryName (C) etc."
    },
    "ƒ: openssl_csr_get_public_key": {
        "type": "function",
        "label": "openssl_csr_get_public_key( $csr:OpenSSLCertificateSigningRequest|string, $short_names:bool )",
        "apply": "openssl_csr_get_public_key( $csr:OpenSSLCertificateSigningRequest|string, $short_names:bool )",
        "info": "openssl_csr_get_public_key() extracts the public key from csr and prepares it for use by other functions."
    },
    "ƒ: openssl_pkey_new": {
        "type": "function",
        "label": "openssl_pkey_new( $options:?array )",
        "apply": "openssl_pkey_new( $options:?array )",
        "info": "openssl_pkey_new() generates a new private key.How to obtain the public component of the key is shown in an example below."
    },
    "ƒ: openssl_pkey_export_to_file": {
        "type": "function",
        "label": "openssl_pkey_export_to_file( $key:, $output_filename:string, $passphrase:?string, $options:?array )",
        "apply": "openssl_pkey_export_to_file( $key:, $output_filename:string, $passphrase:?string, $options:?array )",
        "info": "openssl_pkey_export_to_file() saves an ascii-armoured (PEM encoded) rendition of key into the file named by output_filename.  "
    },
    "ƒ: openssl_pkey_export": {
        "type": "function",
        "label": "openssl_pkey_export( $key:, $output:, $passphrase:?string, $options:?array )",
        "apply": "openssl_pkey_export( $key:, $output:, $passphrase:?string, $options:?array )",
        "info": "openssl_pkey_export() exports key as a PEM encoded string and stores it into output (which is passed by reference)."
    },
    "ƒ: openssl_pkey_get_public": {
        "type": "function",
        "label": "openssl_pkey_get_public( $public_key: )",
        "apply": "openssl_pkey_get_public( $public_key: )",
        "info": "openssl_pkey_get_public() extracts the public key from public_key and prepares it for use by other functions."
    },
    "ƒ: openssl_get_publickey": {
        "type": "function",
        "label": "openssl_get_publickey( $public_key: )",
        "apply": "openssl_get_publickey( $public_key: )",
        "info": "This function is an alias of: openssl_pkey_get_public()."
    },
    "ƒ: openssl_pkey_free": {
        "type": "function",
        "label": "openssl_pkey_free( $key:OpenSSLAsymmetricKey )",
        "apply": "openssl_pkey_free( $key:OpenSSLAsymmetricKey )",
        "info": "Note: "
    },
    "ƒ: openssl_free_key": {
        "type": "function",
        "label": "openssl_free_key( $key:OpenSSLAsymmetricKey )",
        "apply": "openssl_free_key( $key:OpenSSLAsymmetricKey )",
        "info": "openssl_free_key() frees the key associated with the specified key from memory."
    },
    "ƒ: openssl_pkey_get_private": {
        "type": "function",
        "label": "openssl_pkey_get_private( $private_key:, $passphrase:?string )",
        "apply": "openssl_pkey_get_private( $private_key:, $passphrase:?string )",
        "info": "openssl_pkey_get_private() parses private_key and prepares it for use by other functions."
    },
    "ƒ: openssl_get_privatekey": {
        "type": "function",
        "label": "openssl_get_privatekey( $private_key:, $passphrase:?string )",
        "apply": "openssl_get_privatekey( $private_key:, $passphrase:?string )",
        "info": "This function is an alias of: openssl_pkey_get_private()."
    },
    "ƒ: openssl_pkey_get_details": {
        "type": "function",
        "label": "openssl_pkey_get_details( $key:OpenSSLAsymmetricKey )",
        "apply": "openssl_pkey_get_details( $key:OpenSSLAsymmetricKey )",
        "info": "This function returns the key details (bits, key, type)."
    },
    "ƒ: openssl_pbkdf2": {
        "type": "function",
        "label": "openssl_pbkdf2( $password:string, $salt:string, $key_length:int, $iterations:int, $digest_algo:string )",
        "apply": "openssl_pbkdf2( $password:string, $salt:string, $key_length:int, $iterations:int, $digest_algo:string )",
        "info": "openssl_pbkdf2() computes PBKDF2 (Password-Based Key Derivation Function 2),a key derivation function defined in PKCS5 v2."
    },
    "ƒ: openssl_pkcs7_verify": {
        "type": "function",
        "label": "openssl_pkcs7_verify( $input_filename:string, $flags:int, $signers_certificates_filename:?string, $ca_info:array, $untrusted_certificates_filename:?string, $content:?string, $output_filename:?string )",
        "apply": "openssl_pkcs7_verify( $input_filename:string, $flags:int, $signers_certificates_filename:?string, $ca_info:array, $untrusted_certificates_filename:?string, $content:?string, $output_filename:?string )",
        "info": "openssl_pkcs7_verify() reads the S\/MIME message contained in the given file and examines the digital signature."
    },
    "ƒ: openssl_pkcs7_encrypt": {
        "type": "function",
        "label": "openssl_pkcs7_encrypt( $input_filename:string, $output_filename:string, $certificate:, $headers:?array, $flags:int, $cipher_algo:int )",
        "apply": "openssl_pkcs7_encrypt( $input_filename:string, $output_filename:string, $certificate:, $headers:?array, $flags:int, $cipher_algo:int )",
        "info": "openssl_pkcs7_encrypt() takes the contents of the file named input_filename and encrypts them using an RC2 40-bit cipher so that they can only be read by the intended recipients specified by certificate."
    },
    "ƒ: openssl_pkcs7_sign": {
        "type": "function",
        "label": "openssl_pkcs7_sign( $input_filename:string, $output_filename:string, $certificate:OpenSSLCertificate|string, $private_key:, $headers:?array, $flags:int, $untrusted_certificates_filename:?string )",
        "apply": "openssl_pkcs7_sign( $input_filename:string, $output_filename:string, $certificate:OpenSSLCertificate|string, $private_key:, $headers:?array, $flags:int, $untrusted_certificates_filename:?string )",
        "info": "openssl_pkcs7_sign() takes the contents of the file named input_filename and signs them using the certificate and its matching private key specified by certificate and private_key parameters."
    },
    "ƒ: openssl_pkcs7_decrypt": {
        "type": "function",
        "label": "openssl_pkcs7_decrypt( $input_filename:string, $output_filename:string, $certificate:, $private_key: )",
        "apply": "openssl_pkcs7_decrypt( $input_filename:string, $output_filename:string, $certificate:, $private_key: )",
        "info": "Decrypts the S\/MIME encrypted message contained in the file specified by input_filename using the certificate and its associated private key specified by certificate and private_key."
    },
    "ƒ: openssl_pkcs7_read": {
        "type": "function",
        "label": "openssl_pkcs7_read( $data:string, $certificates: )",
        "apply": "openssl_pkcs7_read( $data:string, $certificates: )",
        "info": ""
    },
    "ƒ: openssl_cms_verify": {
        "type": "function",
        "label": "openssl_cms_verify( $input_filename:string, $flags:int, $certificates:?string, $ca_info:array, $untrusted_certificates_filename:?string, $content:?string, $pk7:?string, $sigfile:?string, $encoding:int )",
        "apply": "openssl_cms_verify( $input_filename:string, $flags:int, $certificates:?string, $ca_info:array, $untrusted_certificates_filename:?string, $content:?string, $pk7:?string, $sigfile:?string, $encoding:int )",
        "info": "This function verifies a CMS signature, either attached or detached, with the specified encoding."
    },
    "ƒ: openssl_cms_encrypt": {
        "type": "function",
        "label": "openssl_cms_encrypt( $input_filename:string, $output_filename:string, $certificate:, $headers:?array, $flags:int, $encoding:int, $cipher_algo:int )",
        "apply": "openssl_cms_encrypt( $input_filename:string, $output_filename:string, $certificate:, $headers:?array, $flags:int, $encoding:int, $cipher_algo:int )",
        "info": "This function encrypts content to one or more recipients,based on the certificates that are passed to it."
    },
    "ƒ: openssl_cms_sign": {
        "type": "function",
        "label": "openssl_cms_sign( $input_filename:string, $output_filename:string, $certificate:OpenSSLCertificate|string, $private_key:, $headers:?array, $flags:int, $encoding:int, $untrusted_certificates_filename:?string )",
        "apply": "openssl_cms_sign( $input_filename:string, $output_filename:string, $certificate:OpenSSLCertificate|string, $private_key:, $headers:?array, $flags:int, $encoding:int, $untrusted_certificates_filename:?string )",
        "info": "This function signs a file with an X.509 certificate and key."
    },
    "ƒ: openssl_cms_decrypt": {
        "type": "function",
        "label": "openssl_cms_decrypt( $input_filename:string, $output_filename:string, $certificate:, $private_key:, $encoding:int )",
        "apply": "openssl_cms_decrypt( $input_filename:string, $output_filename:string, $certificate:, $private_key:, $encoding:int )",
        "info": "Decrypts a CMS message."
    },
    "ƒ: openssl_cms_read": {
        "type": "function",
        "label": "openssl_cms_read( $input_filename:string, $certificates: )",
        "apply": "openssl_cms_read( $input_filename:string, $certificates: )",
        "info": "Performs the exact analog to openssl_pkcs7_read()."
    },
    "ƒ: openssl_private_encrypt": {
        "type": "function",
        "label": "openssl_private_encrypt( $data:string, $encrypted_data:, $private_key:, $padding:int )",
        "apply": "openssl_private_encrypt( $data:string, $encrypted_data:, $private_key:, $padding:int )",
        "info": "openssl_private_encrypt() encrypts data with private private_key and stores the result into encrypted_data. Encrypted data can be decrypted via openssl_public_decrypt(). "
    },
    "ƒ: openssl_private_decrypt": {
        "type": "function",
        "label": "openssl_private_decrypt( $data:string, $decrypted_data:, $private_key:, $padding:int )",
        "apply": "openssl_private_decrypt( $data:string, $decrypted_data:, $private_key:, $padding:int )",
        "info": "openssl_private_decrypt() decrypts data that was previously encrypted via openssl_public_encrypt() and stores the result into decrypted_data. "
    },
    "ƒ: openssl_public_encrypt": {
        "type": "function",
        "label": "openssl_public_encrypt( $data:string, $encrypted_data:, $public_key:, $padding:int )",
        "apply": "openssl_public_encrypt( $data:string, $encrypted_data:, $public_key:, $padding:int )",
        "info": "openssl_public_encrypt() encrypts data with public public_key and stores the result into encrypted_data. Encrypted data can be decrypted via openssl_private_decrypt(). "
    },
    "ƒ: openssl_public_decrypt": {
        "type": "function",
        "label": "openssl_public_decrypt( $data:string, $decrypted_data:, $public_key:, $padding:int )",
        "apply": "openssl_public_decrypt( $data:string, $decrypted_data:, $public_key:, $padding:int )",
        "info": "openssl_public_decrypt() decrypts data that was previous encrypted via openssl_private_encrypt() and stores the result into decrypted_data.  "
    },
    "ƒ: openssl_error_string": {
        "type": "function",
        "label": "openssl_error_string()",
        "apply": "openssl_error_string()",
        "info": "openssl_error_string() returns the last error from the openSSL library.  Error messages are queued, so this function should be called multiple times to collect all of the information. The last error will be the most recent one."
    },
    "ƒ: openssl_sign": {
        "type": "function",
        "label": "openssl_sign( $data:string, $signature:, $private_key:, $algorithm:string|int )",
        "apply": "openssl_sign( $data:string, $signature:, $private_key:, $algorithm:string|int )",
        "info": "openssl_sign() computes a signature for the specified data by generating a cryptographic digital signature using the private key associated with private_key. Note that the data itself is not encrypted."
    },
    "ƒ: openssl_verify": {
        "type": "function",
        "label": "openssl_verify( $data:string, $signature:string, $public_key:, $algorithm:string|int )",
        "apply": "openssl_verify( $data:string, $signature:string, $public_key:, $algorithm:string|int )",
        "info": "openssl_verify() verifies that the signature is correct for the specified data using the public key associated with public_key. This must be the public key corresponding to the private key used for signing."
    },
    "ƒ: openssl_seal": {
        "type": "function",
        "label": "openssl_seal( $data:string, $sealed_data:, $encrypted_keys:, $public_key:array, $cipher_algo:string, $iv: )",
        "apply": "openssl_seal( $data:string, $sealed_data:, $encrypted_keys:, $public_key:array, $cipher_algo:string, $iv: )",
        "info": "openssl_seal() seals (encrypts)data by using the given cipher_algo with a randomly generated secret key. The key is encrypted with each of the public keys associated with the identifiers in public_key and each encrypted key is returned in encrypted_keys. This means that one can send sealed data to multiple recipients (provided one has obtained their public keys). Each recipient must receive both the sealed data and the envelope key that was encrypted with the recipient's public key."
    },
    "ƒ: openssl_open": {
        "type": "function",
        "label": "openssl_open( $data:string, $output:, $encrypted_key:string, $private_key:, $cipher_algo:string, $iv:?string )",
        "apply": "openssl_open( $data:string, $output:, $encrypted_key:string, $private_key:, $cipher_algo:string, $iv:?string )",
        "info": "openssl_open() opens (decrypts)data using the private key associated with the key identifier private_key and the envelope key encrypted_key, and fills output with the decrypted data.The envelope key is generated when the data are sealed and can only be used by one specific private key. See openssl_seal() for more information."
    },
    "ƒ: openssl_get_md_methods": {
        "type": "function",
        "label": "openssl_get_md_methods( $aliases:bool )",
        "apply": "openssl_get_md_methods( $aliases:bool )",
        "info": "Gets a list of available digest methods."
    },
    "ƒ: openssl_get_cipher_methods": {
        "type": "function",
        "label": "openssl_get_cipher_methods( $aliases:bool )",
        "apply": "openssl_get_cipher_methods( $aliases:bool )",
        "info": "Gets a list of available cipher methods."
    },
    "ƒ: openssl_get_curve_names": {
        "type": "function",
        "label": "openssl_get_curve_names()",
        "apply": "openssl_get_curve_names()",
        "info": "Gets the list of available curve names for use in Elliptic curve cryptography (ECC) for public\/private key operations. The two most widely standardized\/supported curves are prime256v1 (NIST P-256) and secp384r1 (NIST P-384)."
    },
    "ƒ: openssl_digest": {
        "type": "function",
        "label": "openssl_digest( $data:string, $digest_algo:string, $binary:bool )",
        "apply": "openssl_digest( $data:string, $digest_algo:string, $binary:bool )",
        "info": "Computes a digest hash value for the given data using a given method,and returns a raw or binhex encoded string."
    },
    "ƒ: openssl_encrypt": {
        "type": "function",
        "label": "openssl_encrypt( $data:string, $cipher_algo:string, $passphrase:string, $options:int, $iv:string, $tag:, $aad:string, $tag_length:int )",
        "apply": "openssl_encrypt( $data:string, $cipher_algo:string, $passphrase:string, $options:int, $iv:string, $tag:, $aad:string, $tag_length:int )",
        "info": "Encrypts given data with given method and key, returns a raw or base64 encoded string "
    },
    "ƒ: openssl_decrypt": {
        "type": "function",
        "label": "openssl_decrypt( $data:string, $cipher_algo:string, $passphrase:string, $options:int, $iv:string, $tag:?string, $aad:string )",
        "apply": "openssl_decrypt( $data:string, $cipher_algo:string, $passphrase:string, $options:int, $iv:string, $tag:?string, $aad:string )",
        "info": "Takes a raw or base64 encoded string and decrypts it using a given method and key."
    },
    "ƒ: openssl_cipher_iv_length": {
        "type": "function",
        "label": "openssl_cipher_iv_length( $cipher_algo:string )",
        "apply": "openssl_cipher_iv_length( $cipher_algo:string )",
        "info": "Gets the cipher initialization vector (iv) length."
    },
    "ƒ: openssl_dh_compute_key": {
        "type": "function",
        "label": "openssl_dh_compute_key( $public_key:string, $private_key:OpenSSLAsymmetricKey )",
        "apply": "openssl_dh_compute_key( $public_key:string, $private_key:OpenSSLAsymmetricKey )",
        "info": "The shared secret returned by openssl_dh_compute_key() is often used as an encryption key to secretly communicate with a remote party.This is known as the Diffie-Hellman key exchange."
    },
    "ƒ: openssl_pkey_derive": {
        "type": "function",
        "label": "openssl_pkey_derive( $public_key:, $private_key:, $key_length:int )",
        "apply": "openssl_pkey_derive( $public_key:, $private_key:, $key_length:int )",
        "info": "openssl_pkey_derive() takes a set of a public_key and private_key and derives a shared secret, for either DH or EC keys."
    },
    "ƒ: openssl_random_pseudo_bytes": {
        "type": "function",
        "label": "openssl_random_pseudo_bytes( $length:int, $strong_result: )",
        "apply": "openssl_random_pseudo_bytes( $length:int, $strong_result: )",
        "info": "Generates a string of pseudo-random bytes, with the number of bytes determined by the length parameter. "
    },
    "ƒ: openssl_spki_new": {
        "type": "function",
        "label": "openssl_spki_new( $private_key:OpenSSLAsymmetricKey, $challenge:string, $digest_algo:int )",
        "apply": "openssl_spki_new( $private_key:OpenSSLAsymmetricKey, $challenge:string, $digest_algo:int )",
        "info": "Generates a signed public key and challenge using specified hashing algorithm "
    },
    "ƒ: openssl_spki_verify": {
        "type": "function",
        "label": "openssl_spki_verify( $spki:string )",
        "apply": "openssl_spki_verify( $spki:string )",
        "info": "Validates the supplied signed public key and challenge "
    },
    "ƒ: openssl_spki_export": {
        "type": "function",
        "label": "openssl_spki_export( $spki:string )",
        "apply": "openssl_spki_export( $spki:string )",
        "info": "Exports PEM formatted public key from encoded signed public key and challenge "
    },
    "ƒ: openssl_spki_export_challenge": {
        "type": "function",
        "label": "openssl_spki_export_challenge( $spki:string )",
        "apply": "openssl_spki_export_challenge( $spki:string )",
        "info": "Exports challenge from encoded signed public key and challenge "
    },
    "ƒ: openssl_get_cert_locations": {
        "type": "function",
        "label": "openssl_get_cert_locations()",
        "apply": "openssl_get_cert_locations()",
        "info": "openssl_get_cert_locations() returns an array with information about the available certificate locations that will be searched for SSL certificates."
    },
    "ƒ: preg_match": {
        "type": "function",
        "label": "preg_match( $pattern:string, $subject:string, $matches:, $flags:int, $offset:int )",
        "apply": "preg_match( $pattern:string, $subject:string, $matches:, $flags:int, $offset:int )",
        "info": "Searches subject for a match to the regular expression given in pattern."
    },
    "ƒ: preg_match_all": {
        "type": "function",
        "label": "preg_match_all( $pattern:string, $subject:string, $matches:, $flags:int, $offset:int )",
        "apply": "preg_match_all( $pattern:string, $subject:string, $matches:, $flags:int, $offset:int )",
        "info": "Searches subject for all matches to the regular expression given in pattern and puts them in matches in the order specified by flags."
    },
    "ƒ: preg_replace": {
        "type": "function",
        "label": "preg_replace( $pattern:array|string, $replacement:array|string, $subject:array|string, $limit:int, $count: )",
        "apply": "preg_replace( $pattern:array|string, $replacement:array|string, $subject:array|string, $limit:int, $count: )",
        "info": "Searches subject for matches to pattern and replaces them with replacement."
    },
    "ƒ: preg_filter": {
        "type": "function",
        "label": "preg_filter( $pattern:array|string, $replacement:array|string, $subject:array|string, $limit:int, $count: )",
        "apply": "preg_filter( $pattern:array|string, $replacement:array|string, $subject:array|string, $limit:int, $count: )",
        "info": "preg_filter() is identical to preg_replace()except it only returns the (possibly transformed) subjects where there was a match. For details about how this function works, read the preg_replace() documentation."
    },
    "ƒ: preg_replace_callback": {
        "type": "function",
        "label": "preg_replace_callback( $pattern:array|string, $callback:callable, $subject:array|string, $limit:int, $count:, $flags:int )",
        "apply": "preg_replace_callback( $pattern:array|string, $callback:callable, $subject:array|string, $limit:int, $count:, $flags:int )",
        "info": "The behavior of this function is almost identical to preg_replace(), except for the fact that instead of replacement parameter, one should specify a callback."
    },
    "ƒ: preg_replace_callback_array": {
        "type": "function",
        "label": "preg_replace_callback_array( $pattern:array, $subject:array|string, $limit:int, $count:, $flags:int )",
        "apply": "preg_replace_callback_array( $pattern:array, $subject:array|string, $limit:int, $count:, $flags:int )",
        "info": "The behavior of this function is similar to preg_replace_callback(), except that callbacks are executed on a per-pattern basis."
    },
    "ƒ: preg_split": {
        "type": "function",
        "label": "preg_split( $pattern:string, $subject:string, $limit:int, $flags:int )",
        "apply": "preg_split( $pattern:string, $subject:string, $limit:int, $flags:int )",
        "info": "Split the given string by a regular expression."
    },
    "ƒ: preg_quote": {
        "type": "function",
        "label": "preg_quote( $str:string, $delimiter:?string )",
        "apply": "preg_quote( $str:string, $delimiter:?string )",
        "info": "preg_quote() takes str and puts a backslash in front of every character that is part of the regular expression syntax.  This is useful if you have a run-time string that you need to match in some text and the string may contain special regex characters."
    },
    "ƒ: preg_grep": {
        "type": "function",
        "label": "preg_grep( $pattern:string, $array:array, $flags:int )",
        "apply": "preg_grep( $pattern:string, $array:array, $flags:int )",
        "info": "Returns the array consisting of the elements of the array array that match the given pattern."
    },
    "ƒ: preg_last_error": {
        "type": "function",
        "label": "preg_last_error()",
        "apply": "preg_last_error()",
        "info": "Returns the error code of the last PCRE regex execution."
    },
    "ƒ: preg_last_error_msg": {
        "type": "function",
        "label": "preg_last_error_msg()",
        "apply": "preg_last_error_msg()",
        "info": "Returns the error message of the last PCRE regex execution."
    },
    "ƒ: ob_gzhandler": {
        "type": "function",
        "label": "ob_gzhandler( $data:string, $flags:int )",
        "apply": "ob_gzhandler( $data:string, $flags:int )",
        "info": "ob_gzhandler() is intended to be used as a callback function for ob_start() to help facilitate sending gz-encoded data to web browsers that support compressed web pages.  Before ob_gzhandler() actually sends compressed data,it determines what type of content encoding the browser will accept (\"gzip\", \"deflate\" or none at all) and will return its output accordingly.All browsers are supported since it's up to the browser to send the correct header saying that it accepts compressed web pages. If a browser doesn't support compressed pages this function returns false."
    },
    "ƒ: zlib_get_coding_type": {
        "type": "function",
        "label": "zlib_get_coding_type()",
        "apply": "zlib_get_coding_type()",
        "info": "Returns the coding type used for output compression.  "
    },
    "ƒ: gzfile": {
        "type": "function",
        "label": "gzfile( $filename:string, $use_include_path:int )",
        "apply": "gzfile( $filename:string, $use_include_path:int )",
        "info": " This function is identical to readgzfile(), except that it returns the file in an array."
    },
    "ƒ: gzopen": {
        "type": "function",
        "label": "gzopen( $filename:string, $mode:string, $use_include_path:int )",
        "apply": "gzopen( $filename:string, $mode:string, $use_include_path:int )",
        "info": "Opens a gzip (.gz) file for reading or writing. "
    },
    "ƒ: readgzfile": {
        "type": "function",
        "label": "readgzfile( $filename:string, $use_include_path:int )",
        "apply": "readgzfile( $filename:string, $use_include_path:int )",
        "info": " Reads a file, decompresses it and writes it to standard output."
    },
    "ƒ: zlib_encode": {
        "type": "function",
        "label": "zlib_encode( $data:string, $encoding:int, $level:int )",
        "apply": "zlib_encode( $data:string, $encoding:int, $level:int )",
        "info": "Compress data with the specified encoding."
    },
    "ƒ: zlib_decode": {
        "type": "function",
        "label": "zlib_decode( $data:string, $max_length:int )",
        "apply": "zlib_decode( $data:string, $max_length:int )",
        "info": "Uncompress any raw\/gzip\/zlib encoded data."
    },
    "ƒ: gzdeflate": {
        "type": "function",
        "label": "gzdeflate( $data:string, $level:int, $encoding:int )",
        "apply": "gzdeflate( $data:string, $level:int, $encoding:int )",
        "info": "This function compresses the given string using the DEFLATE data format."
    },
    "ƒ: gzencode": {
        "type": "function",
        "label": "gzencode( $data:string, $level:int, $encoding:int )",
        "apply": "gzencode( $data:string, $level:int, $encoding:int )",
        "info": "   This function returns a compressed version of the input data compatible with the output of the gzip program."
    },
    "ƒ: gzcompress": {
        "type": "function",
        "label": "gzcompress( $data:string, $level:int, $encoding:int )",
        "apply": "gzcompress( $data:string, $level:int, $encoding:int )",
        "info": "This function compresses the given string using the ZLIB data format."
    },
    "ƒ: gzinflate": {
        "type": "function",
        "label": "gzinflate( $data:string, $max_length:int )",
        "apply": "gzinflate( $data:string, $max_length:int )",
        "info": "   This function inflates a deflated string.  "
    },
    "ƒ: gzdecode": {
        "type": "function",
        "label": "gzdecode( $data:string, $max_length:int )",
        "apply": "gzdecode( $data:string, $max_length:int )",
        "info": "   This function returns a decoded version of the input data."
    },
    "ƒ: gzuncompress": {
        "type": "function",
        "label": "gzuncompress( $data:string, $max_length:int )",
        "apply": "gzuncompress( $data:string, $max_length:int )",
        "info": "   This function uncompress a compressed string.  "
    },
    "ƒ: gzwrite": {
        "type": "function",
        "label": "gzwrite( $stream:, $data:string, $length:?int )",
        "apply": "gzwrite( $stream:, $data:string, $length:?int )",
        "info": "gzwrite() writes the contents of data to the given gz-file."
    },
    "ƒ: gzputs": {
        "type": "function",
        "label": "gzputs( $stream:, $data:string, $length:?int )",
        "apply": "gzputs( $stream:, $data:string, $length:?int )",
        "info": "This function is an alias of: gzwrite()."
    },
    "ƒ: gzrewind": {
        "type": "function",
        "label": "gzrewind( $stream: )",
        "apply": "gzrewind( $stream: )",
        "info": "    Sets the file position indicator of the given gz-file pointer to the beginning of the file stream."
    },
    "ƒ: gzclose": {
        "type": "function",
        "label": "gzclose( $stream: )",
        "apply": "gzclose( $stream: )",
        "info": "Closes the given gz-file pointer."
    },
    "ƒ: gzeof": {
        "type": "function",
        "label": "gzeof( $stream: )",
        "apply": "gzeof( $stream: )",
        "info": "Tests the given GZ file pointer for EOF."
    },
    "ƒ: gzgetc": {
        "type": "function",
        "label": "gzgetc( $stream: )",
        "apply": "gzgetc( $stream: )",
        "info": "Returns a string containing a single (uncompressed) character read from the given gz-file pointer."
    },
    "ƒ: gzpassthru": {
        "type": "function",
        "label": "gzpassthru( $stream: )",
        "apply": "gzpassthru( $stream: )",
        "info": "Reads to EOF on the given gz-file pointer from the current position and writes the (uncompressed) results to standard output."
    },
    "ƒ: gzseek": {
        "type": "function",
        "label": "gzseek( $stream:, $offset:int, $whence:int )",
        "apply": "gzseek( $stream:, $offset:int, $whence:int )",
        "info": "Sets the file position indicator for the given file pointer to the given offset byte into the file stream. Equivalent to calling (in C)gzseek(zp, offset, SEEK_SET)."
    },
    "ƒ: gztell": {
        "type": "function",
        "label": "gztell( $stream: )",
        "apply": "gztell( $stream: )",
        "info": "Gets the position of the given file pointer; i.e., its offset into the uncompressed file stream."
    },
    "ƒ: gzread": {
        "type": "function",
        "label": "gzread( $stream:, $length:int )",
        "apply": "gzread( $stream:, $length:int )",
        "info": "gzread() reads up to length bytes from the given gz-file pointer. Reading stops when length (uncompressed) bytes have been read or EOF is reached, whichever comes first."
    },
    "ƒ: gzgets": {
        "type": "function",
        "label": "gzgets( $stream:, $length:?int )",
        "apply": "gzgets( $stream:, $length:?int )",
        "info": "Gets a (uncompressed) string of up to length - 1 bytes read from the given file pointer. Reading ends when length - 1 bytes have been read, on a newline, or on EOF (whichever comes first)."
    },
    "ƒ: deflate_init": {
        "type": "function",
        "label": "deflate_init( $encoding:int, $options:array )",
        "apply": "deflate_init( $encoding:int, $options:array )",
        "info": "Initializes an incremental deflate context using the specified encoding."
    },
    "ƒ: deflate_add": {
        "type": "function",
        "label": "deflate_add( $context:DeflateContext, $data:string, $flush_mode:int )",
        "apply": "deflate_add( $context:DeflateContext, $data:string, $flush_mode:int )",
        "info": "Incrementally deflates data in the specified context."
    },
    "ƒ: inflate_init": {
        "type": "function",
        "label": "inflate_init( $encoding:int, $options:array )",
        "apply": "inflate_init( $encoding:int, $options:array )",
        "info": "Initialize an incremental inflate context with the specified encoding."
    },
    "ƒ: inflate_add": {
        "type": "function",
        "label": "inflate_add( $context:InflateContext, $data:string, $flush_mode:int )",
        "apply": "inflate_add( $context:InflateContext, $data:string, $flush_mode:int )",
        "info": "Incrementally inflates encoded data in the specified context."
    },
    "ƒ: inflate_get_status": {
        "type": "function",
        "label": "inflate_get_status( $context:InflateContext )",
        "apply": "inflate_get_status( $context:InflateContext )",
        "info": "Usually returns either ZLIB_OK or ZLIB_STREAM_END."
    },
    "ƒ: inflate_get_read_len": {
        "type": "function",
        "label": "inflate_get_read_len( $context:InflateContext )",
        "apply": "inflate_get_read_len( $context:InflateContext )",
        "info": ""
    },
    "ƒ: ctype_alnum": {
        "type": "function",
        "label": "ctype_alnum( $text:mixed )",
        "apply": "ctype_alnum( $text:mixed )",
        "info": "Checks if all of the characters in the provided string,text, are alphanumeric."
    },
    "ƒ: ctype_alpha": {
        "type": "function",
        "label": "ctype_alpha( $text:mixed )",
        "apply": "ctype_alpha( $text:mixed )",
        "info": "Checks if all of the characters in the provided string,text, are alphabetic.In the standard C locale letters are just [A-Za-z] and ctype_alpha() is equivalent to (ctype_upper($text) || ctype_lower($text))if $text is just a single character, but other languages have letters that are considered neither upper nor lower case."
    },
    "ƒ: ctype_cntrl": {
        "type": "function",
        "label": "ctype_cntrl( $text:mixed )",
        "apply": "ctype_cntrl( $text:mixed )",
        "info": "Checks if all of the characters in the provided string,text, are control characters.Control characters are e.g. line feed, tab, escape."
    },
    "ƒ: ctype_digit": {
        "type": "function",
        "label": "ctype_digit( $text:mixed )",
        "apply": "ctype_digit( $text:mixed )",
        "info": "Checks if all of the characters in the provided string,text, are numerical."
    },
    "ƒ: ctype_lower": {
        "type": "function",
        "label": "ctype_lower( $text:mixed )",
        "apply": "ctype_lower( $text:mixed )",
        "info": "Checks if all of the characters in the provided string,text, are lowercase letters."
    },
    "ƒ: ctype_graph": {
        "type": "function",
        "label": "ctype_graph( $text:mixed )",
        "apply": "ctype_graph( $text:mixed )",
        "info": "Checks if all of the characters in the provided string,text, creates visible output."
    },
    "ƒ: ctype_print": {
        "type": "function",
        "label": "ctype_print( $text:mixed )",
        "apply": "ctype_print( $text:mixed )",
        "info": "Checks if all of the characters in the provided string,text, are printable."
    },
    "ƒ: ctype_punct": {
        "type": "function",
        "label": "ctype_punct( $text:mixed )",
        "apply": "ctype_punct( $text:mixed )",
        "info": "Checks if all of the characters in the provided string,text, are punctuation character."
    },
    "ƒ: ctype_space": {
        "type": "function",
        "label": "ctype_space( $text:mixed )",
        "apply": "ctype_space( $text:mixed )",
        "info": "Checks if all of the characters in the provided string,text, creates whitespace."
    },
    "ƒ: ctype_upper": {
        "type": "function",
        "label": "ctype_upper( $text:mixed )",
        "apply": "ctype_upper( $text:mixed )",
        "info": "Checks if all of the characters in the provided string,text, are uppercase characters."
    },
    "ƒ: ctype_xdigit": {
        "type": "function",
        "label": "ctype_xdigit( $text:mixed )",
        "apply": "ctype_xdigit( $text:mixed )",
        "info": "Checks if all of the characters in the provided string,text, are hexadecimal 'digits'."
    },
    "ƒ: curl_close": {
        "type": "function",
        "label": "curl_close( $handle:CurlHandle )",
        "apply": "curl_close( $handle:CurlHandle )",
        "info": "Note: "
    },
    "ƒ: curl_copy_handle": {
        "type": "function",
        "label": "curl_copy_handle( $handle:CurlHandle )",
        "apply": "curl_copy_handle( $handle:CurlHandle )",
        "info": "Copies a cURL handle keeping the same preferences."
    },
    "ƒ: curl_errno": {
        "type": "function",
        "label": "curl_errno( $handle:CurlHandle )",
        "apply": "curl_errno( $handle:CurlHandle )",
        "info": "Returns the error number for the last cURL operation."
    },
    "ƒ: curl_error": {
        "type": "function",
        "label": "curl_error( $handle:CurlHandle )",
        "apply": "curl_error( $handle:CurlHandle )",
        "info": "Returns a clear text error message for the last cURL operation."
    },
    "ƒ: curl_escape": {
        "type": "function",
        "label": "curl_escape( $handle:CurlHandle, $string:string )",
        "apply": "curl_escape( $handle:CurlHandle, $string:string )",
        "info": "This function URL encodes the given string according to \u00bb\u00a0RFC 3986."
    },
    "ƒ: curl_unescape": {
        "type": "function",
        "label": "curl_unescape( $handle:CurlHandle, $string:string )",
        "apply": "curl_unescape( $handle:CurlHandle, $string:string )",
        "info": "This function decodes the given URL encoded string."
    },
    "ƒ: curl_multi_setopt": {
        "type": "function",
        "label": "curl_multi_setopt( $multi_handle:CurlMultiHandle, $option:int, $value:mixed )",
        "apply": "curl_multi_setopt( $multi_handle:CurlMultiHandle, $option:int, $value:mixed )",
        "info": ""
    },
    "ƒ: curl_exec": {
        "type": "function",
        "label": "curl_exec( $handle:CurlHandle )",
        "apply": "curl_exec( $handle:CurlHandle )",
        "info": "Execute the given cURL session."
    },
    "ƒ: curl_file_create": {
        "type": "function",
        "label": "curl_file_create( $filename:string, $mime_type:?string, $posted_filename:?string )",
        "apply": "curl_file_create( $filename:string, $mime_type:?string, $posted_filename:?string )",
        "info": "Object-oriented style"
    },
    "ƒ: curl_getinfo": {
        "type": "function",
        "label": "curl_getinfo( $handle:CurlHandle, $option:?int )",
        "apply": "curl_getinfo( $handle:CurlHandle, $option:?int )",
        "info": "Gets information about the last transfer. "
    },
    "ƒ: curl_init": {
        "type": "function",
        "label": "curl_init( $url:?string )",
        "apply": "curl_init( $url:?string )",
        "info": "Initializes a new session and return a cURL handle for use with the curl_setopt(), curl_exec(),and curl_close() functions.  "
    },
    "ƒ: curl_multi_add_handle": {
        "type": "function",
        "label": "curl_multi_add_handle( $multi_handle:CurlMultiHandle, $handle:CurlHandle )",
        "apply": "curl_multi_add_handle( $multi_handle:CurlMultiHandle, $handle:CurlHandle )",
        "info": "Adds the handle handle to the multi handle multi_handle "
    },
    "ƒ: curl_multi_close": {
        "type": "function",
        "label": "curl_multi_close( $multi_handle:CurlMultiHandle )",
        "apply": "curl_multi_close( $multi_handle:CurlMultiHandle )",
        "info": "Note: "
    },
    "ƒ: curl_multi_errno": {
        "type": "function",
        "label": "curl_multi_errno( $multi_handle:CurlMultiHandle )",
        "apply": "curl_multi_errno( $multi_handle:CurlMultiHandle )",
        "info": "Return an integer containing the last multi curl error number."
    },
    "ƒ: curl_multi_exec": {
        "type": "function",
        "label": "curl_multi_exec( $multi_handle:CurlMultiHandle, $still_running: )",
        "apply": "curl_multi_exec( $multi_handle:CurlMultiHandle, $still_running: )",
        "info": "Processes each of the handles in the stack.  This method can be called whether or not a handle needs to read or write data."
    },
    "ƒ: curl_multi_getcontent": {
        "type": "function",
        "label": "curl_multi_getcontent( $handle:CurlHandle )",
        "apply": "curl_multi_getcontent( $handle:CurlHandle )",
        "info": "If CURLOPT_RETURNTRANSFER is an option that is set for a specific handle, then this function will return the content of that cURL handle in the form of a string."
    },
    "ƒ: curl_multi_info_read": {
        "type": "function",
        "label": "curl_multi_info_read( $multi_handle:CurlMultiHandle, $queued_messages: )",
        "apply": "curl_multi_info_read( $multi_handle:CurlMultiHandle, $queued_messages: )",
        "info": "Ask the multi handle if there are any messages or information from the individual transfers. Messages may include information such as an error code from the transfer or just the fact that a transfer is completed."
    },
    "ƒ: curl_multi_init": {
        "type": "function",
        "label": "curl_multi_init()",
        "apply": "curl_multi_init()",
        "info": "Allows the processing of multiple cURL handles asynchronously."
    },
    "ƒ: curl_multi_remove_handle": {
        "type": "function",
        "label": "curl_multi_remove_handle( $multi_handle:CurlMultiHandle, $handle:CurlHandle )",
        "apply": "curl_multi_remove_handle( $multi_handle:CurlMultiHandle, $handle:CurlHandle )",
        "info": "Removes a given handle handle from the given multi_handle handle. When the handle handle has been removed, it is again perfectly legal to run curl_exec() on this handle.  Removing the handle handle while being used, will effectively halt the transfer in progress involving that handle."
    },
    "ƒ: curl_multi_select": {
        "type": "function",
        "label": "curl_multi_select( $multi_handle:CurlMultiHandle, $timeout:float )",
        "apply": "curl_multi_select( $multi_handle:CurlMultiHandle, $timeout:float )",
        "info": "Blocks until there is activity on any of the curl_multi connections."
    },
    "ƒ: curl_multi_strerror": {
        "type": "function",
        "label": "curl_multi_strerror( $error_code:int )",
        "apply": "curl_multi_strerror( $error_code:int )",
        "info": "Returns a text error message describing the given CURLM error code."
    },
    "ƒ: curl_pause": {
        "type": "function",
        "label": "curl_pause( $handle:CurlHandle, $flags:int )",
        "apply": "curl_pause( $handle:CurlHandle, $flags:int )",
        "info": ""
    },
    "ƒ: curl_reset": {
        "type": "function",
        "label": "curl_reset( $handle:CurlHandle )",
        "apply": "curl_reset( $handle:CurlHandle )",
        "info": "This function re-initializes all options set on the given cURL handle to the default values."
    },
    "ƒ: curl_setopt_array": {
        "type": "function",
        "label": "curl_setopt_array( $handle:CurlHandle, $options:array )",
        "apply": "curl_setopt_array( $handle:CurlHandle, $options:array )",
        "info": "Sets multiple options for a cURL session. This function is useful for setting a large number of cURL options without repetitively calling curl_setopt()."
    },
    "ƒ: curl_setopt": {
        "type": "function",
        "label": "curl_setopt( $handle:CurlHandle, $option:int, $value:mixed )",
        "apply": "curl_setopt( $handle:CurlHandle, $option:int, $value:mixed )",
        "info": "Sets an option on the given cURL session handle."
    },
    "ƒ: curl_share_close": {
        "type": "function",
        "label": "curl_share_close( $share_handle:CurlShareHandle )",
        "apply": "curl_share_close( $share_handle:CurlShareHandle )",
        "info": "Note: "
    },
    "ƒ: curl_share_errno": {
        "type": "function",
        "label": "curl_share_errno( $share_handle:CurlShareHandle )",
        "apply": "curl_share_errno( $share_handle:CurlShareHandle )",
        "info": "Return an integer containing the last share curl error number."
    },
    "ƒ: curl_share_init": {
        "type": "function",
        "label": "curl_share_init()",
        "apply": "curl_share_init()",
        "info": "Allows to share data between cURL handles."
    },
    "ƒ: curl_share_setopt": {
        "type": "function",
        "label": "curl_share_setopt( $share_handle:CurlShareHandle, $option:int, $value:mixed )",
        "apply": "curl_share_setopt( $share_handle:CurlShareHandle, $option:int, $value:mixed )",
        "info": "Sets an option on the given cURL share handle."
    },
    "ƒ: curl_share_strerror": {
        "type": "function",
        "label": "curl_share_strerror( $error_code:int )",
        "apply": "curl_share_strerror( $error_code:int )",
        "info": "Returns a text error message describing the given error code."
    },
    "ƒ: curl_strerror": {
        "type": "function",
        "label": "curl_strerror( $error_code:int )",
        "apply": "curl_strerror( $error_code:int )",
        "info": "Returns a text error message describing the given error code."
    },
    "ƒ: curl_version": {
        "type": "function",
        "label": "curl_version()",
        "apply": "curl_version()",
        "info": "Returns information about the cURL version."
    },
    "ƒ: dom_import_simplexml": {
        "type": "function",
        "label": "dom_import_simplexml( $node:object )",
        "apply": "dom_import_simplexml( $node:object )",
        "info": "This function takes the node node of class SimpleXML and makes it into a DOMElement node. This new object can then be used as a native DOMElement node. "
    },
    "ƒ: finfo_open": {
        "type": "function",
        "label": "finfo_open( $flags:int, $magic_database:?string )",
        "apply": "finfo_open( $flags:int, $magic_database:?string )",
        "info": "Procedural style"
    },
    "ƒ: finfo_close": {
        "type": "function",
        "label": "finfo_close( $finfo:finfo )",
        "apply": "finfo_close( $finfo:finfo )",
        "info": "This function closes the instance opened by finfo_open()."
    },
    "ƒ: finfo_set_flags": {
        "type": "function",
        "label": "finfo_set_flags( $finfo:finfo, $flags:int )",
        "apply": "finfo_set_flags( $finfo:finfo, $flags:int )",
        "info": "Procedural style"
    },
    "ƒ: finfo_file": {
        "type": "function",
        "label": "finfo_file( $finfo:finfo, $filename:string, $flags:int, $context: )",
        "apply": "finfo_file( $finfo:finfo, $filename:string, $flags:int, $context: )",
        "info": "Procedural style"
    },
    "ƒ: finfo_buffer": {
        "type": "function",
        "label": "finfo_buffer( $finfo:finfo, $string:string, $flags:int, $context: )",
        "apply": "finfo_buffer( $finfo:finfo, $string:string, $flags:int, $context: )",
        "info": "Procedural style"
    },
    "ƒ: mime_content_type": {
        "type": "function",
        "label": "mime_content_type( $filename: )",
        "apply": "mime_content_type( $filename: )",
        "info": "Returns the MIME content type for a file as determined by using information from the magic.mime file. "
    },
    "ƒ: filter_has_var": {
        "type": "function",
        "label": "filter_has_var( $input_type:int, $var_name:string )",
        "apply": "filter_has_var( $input_type:int, $var_name:string )",
        "info": null
    },
    "ƒ: filter_input": {
        "type": "function",
        "label": "filter_input( $type:int, $var_name:string, $filter:int, $options:array|int )",
        "apply": "filter_input( $type:int, $var_name:string, $filter:int, $options:array|int )",
        "info": null
    },
    "ƒ: filter_var": {
        "type": "function",
        "label": "filter_var( $value:mixed, $filter:int, $options:array|int )",
        "apply": "filter_var( $value:mixed, $filter:int, $options:array|int )",
        "info": null
    },
    "ƒ: filter_input_array": {
        "type": "function",
        "label": "filter_input_array( $type:int, $options:array|int, $add_empty:bool )",
        "apply": "filter_input_array( $type:int, $options:array|int, $add_empty:bool )",
        "info": "This function is useful for retrieving many values without repetitively calling filter_input()."
    },
    "ƒ: filter_var_array": {
        "type": "function",
        "label": "filter_var_array( $array:array, $options:array|int, $add_empty:bool )",
        "apply": "filter_var_array( $array:array, $options:array|int, $add_empty:bool )",
        "info": "This function is useful for retrieving many values without repetitively calling filter_var()."
    },
    "ƒ: filter_list": {
        "type": "function",
        "label": "filter_list()",
        "apply": "filter_list()",
        "info": null
    },
    "ƒ: filter_id": {
        "type": "function",
        "label": "filter_id( $name:string )",
        "apply": "filter_id( $name:string )",
        "info": null
    },
    "ƒ: ftp_connect": {
        "type": "function",
        "label": "ftp_connect( $hostname:string, $port:int, $timeout:int )",
        "apply": "ftp_connect( $hostname:string, $port:int, $timeout:int )",
        "info": "ftp_connect() opens an FTP connection to the specified hostname.  "
    },
    "ƒ: ftp_ssl_connect": {
        "type": "function",
        "label": "ftp_ssl_connect( $hostname:string, $port:int, $timeout:int )",
        "apply": "ftp_ssl_connect( $hostname:string, $port:int, $timeout:int )",
        "info": "ftp_ssl_connect() opens an explicit SSL-FTP connection to the specified hostname. That implies that ftp_ssl_connect() will succeed even if the server is not configured for SSL-FTP, or its certificate is invalid. Only when ftp_login() is called, the client will send the appropriate AUTH FTP command, so ftp_login() will fail in the mentioned cases."
    },
    "ƒ: ftp_login": {
        "type": "function",
        "label": "ftp_login( $ftp:FTP\\Connection, $username:string, $password:string )",
        "apply": "ftp_login( $ftp:FTP\\Connection, $username:string, $password:string )",
        "info": " Logs in to the given FTP connection."
    },
    "ƒ: ftp_pwd": {
        "type": "function",
        "label": "ftp_pwd( $ftp:FTP\\Connection )",
        "apply": "ftp_pwd( $ftp:FTP\\Connection )",
        "info": ""
    },
    "ƒ: ftp_cdup": {
        "type": "function",
        "label": "ftp_cdup( $ftp:FTP\\Connection )",
        "apply": "ftp_cdup( $ftp:FTP\\Connection )",
        "info": " Changes to the parent directory."
    },
    "ƒ: ftp_chdir": {
        "type": "function",
        "label": "ftp_chdir( $ftp:FTP\\Connection, $directory:string )",
        "apply": "ftp_chdir( $ftp:FTP\\Connection, $directory:string )",
        "info": " Changes the current directory to the specified one."
    },
    "ƒ: ftp_exec": {
        "type": "function",
        "label": "ftp_exec( $ftp:FTP\\Connection, $command:string )",
        "apply": "ftp_exec( $ftp:FTP\\Connection, $command:string )",
        "info": "Sends a SITE EXEC command request to the FTP server. "
    },
    "ƒ: ftp_raw": {
        "type": "function",
        "label": "ftp_raw( $ftp:FTP\\Connection, $command:string )",
        "apply": "ftp_raw( $ftp:FTP\\Connection, $command:string )",
        "info": "Sends an arbitrary command to the FTP server. "
    },
    "ƒ: ftp_mkdir": {
        "type": "function",
        "label": "ftp_mkdir( $ftp:FTP\\Connection, $directory:string )",
        "apply": "ftp_mkdir( $ftp:FTP\\Connection, $directory:string )",
        "info": " Creates the specified directory on the FTP server."
    },
    "ƒ: ftp_rmdir": {
        "type": "function",
        "label": "ftp_rmdir( $ftp:FTP\\Connection, $directory:string )",
        "apply": "ftp_rmdir( $ftp:FTP\\Connection, $directory:string )",
        "info": " Removes the specified directory on the FTP server."
    },
    "ƒ: ftp_chmod": {
        "type": "function",
        "label": "ftp_chmod( $ftp:FTP\\Connection, $permissions:int, $filename:string )",
        "apply": "ftp_chmod( $ftp:FTP\\Connection, $permissions:int, $filename:string )",
        "info": " Sets the permissions on the specified remote file to permissions."
    },
    "ƒ: ftp_alloc": {
        "type": "function",
        "label": "ftp_alloc( $ftp:FTP\\Connection, $size:int, $response: )",
        "apply": "ftp_alloc( $ftp:FTP\\Connection, $size:int, $response: )",
        "info": "Sends an ALLO command to the remote FTP server to allocate space for a file to be uploaded."
    },
    "ƒ: ftp_nlist": {
        "type": "function",
        "label": "ftp_nlist( $ftp:FTP\\Connection, $directory:string )",
        "apply": "ftp_nlist( $ftp:FTP\\Connection, $directory:string )",
        "info": null
    },
    "ƒ: ftp_rawlist": {
        "type": "function",
        "label": "ftp_rawlist( $ftp:FTP\\Connection, $directory:string, $recursive:bool )",
        "apply": "ftp_rawlist( $ftp:FTP\\Connection, $directory:string, $recursive:bool )",
        "info": "ftp_rawlist() executes the FTP LIST command, and returns the result as an array."
    },
    "ƒ: ftp_mlsd": {
        "type": "function",
        "label": "ftp_mlsd( $ftp:FTP\\Connection, $directory:string )",
        "apply": "ftp_mlsd( $ftp:FTP\\Connection, $directory:string )",
        "info": null
    },
    "ƒ: ftp_systype": {
        "type": "function",
        "label": "ftp_systype( $ftp:FTP\\Connection )",
        "apply": "ftp_systype( $ftp:FTP\\Connection )",
        "info": "Returns the system type identifier of the remote FTP server."
    },
    "ƒ: ftp_fget": {
        "type": "function",
        "label": "ftp_fget( $ftp:FTP\\Connection, $stream:, $remote_filename:string, $mode:int, $offset:int )",
        "apply": "ftp_fget( $ftp:FTP\\Connection, $stream:, $remote_filename:string, $mode:int, $offset:int )",
        "info": "ftp_fget() retrieves remote_filename from the FTP server, and writes it to the given file pointer."
    },
    "ƒ: ftp_nb_fget": {
        "type": "function",
        "label": "ftp_nb_fget( $ftp:FTP\\Connection, $stream:, $remote_filename:string, $mode:int, $offset:int )",
        "apply": "ftp_nb_fget( $ftp:FTP\\Connection, $stream:, $remote_filename:string, $mode:int, $offset:int )",
        "info": "ftp_nb_fget() retrieves a remote file from the FTP server."
    },
    "ƒ: ftp_pasv": {
        "type": "function",
        "label": "ftp_pasv( $ftp:FTP\\Connection, $enable:bool )",
        "apply": "ftp_pasv( $ftp:FTP\\Connection, $enable:bool )",
        "info": "ftp_pasv() turns on or off passive mode. In passive mode, data connections are initiated by the client,rather than by the server.It may be needed if the client is behind firewall."
    },
    "ƒ: ftp_get": {
        "type": "function",
        "label": "ftp_get( $ftp:FTP\\Connection, $local_filename:string, $remote_filename:string, $mode:int, $offset:int )",
        "apply": "ftp_get( $ftp:FTP\\Connection, $local_filename:string, $remote_filename:string, $mode:int, $offset:int )",
        "info": "ftp_get() retrieves a remote file from the FTP server,and saves it into a local file. "
    },
    "ƒ: ftp_nb_get": {
        "type": "function",
        "label": "ftp_nb_get( $ftp:FTP\\Connection, $local_filename:string, $remote_filename:string, $mode:int, $offset:int )",
        "apply": "ftp_nb_get( $ftp:FTP\\Connection, $local_filename:string, $remote_filename:string, $mode:int, $offset:int )",
        "info": "ftp_nb_get() retrieves a remote file from the FTP server,and saves it into a local file. "
    },
    "ƒ: ftp_nb_continue": {
        "type": "function",
        "label": "ftp_nb_continue( $ftp:FTP\\Connection )",
        "apply": "ftp_nb_continue( $ftp:FTP\\Connection )",
        "info": " Continues retrieving\/sending a file non-blocking."
    },
    "ƒ: ftp_fput": {
        "type": "function",
        "label": "ftp_fput( $ftp:FTP\\Connection, $remote_filename:string, $stream:, $mode:int, $offset:int )",
        "apply": "ftp_fput( $ftp:FTP\\Connection, $remote_filename:string, $stream:, $mode:int, $offset:int )",
        "info": "ftp_fput() uploads the data from a file pointer to a remote file on the FTP server."
    },
    "ƒ: ftp_nb_fput": {
        "type": "function",
        "label": "ftp_nb_fput( $ftp:FTP\\Connection, $remote_filename:string, $stream:, $mode:int, $offset:int )",
        "apply": "ftp_nb_fput( $ftp:FTP\\Connection, $remote_filename:string, $stream:, $mode:int, $offset:int )",
        "info": "ftp_nb_fput() uploads the data from a file pointer to a remote file on the FTP server."
    },
    "ƒ: ftp_put": {
        "type": "function",
        "label": "ftp_put( $ftp:FTP\\Connection, $remote_filename:string, $local_filename:string, $mode:int, $offset:int )",
        "apply": "ftp_put( $ftp:FTP\\Connection, $remote_filename:string, $local_filename:string, $mode:int, $offset:int )",
        "info": "ftp_put() stores a local file on the FTP server."
    },
    "ƒ: ftp_append": {
        "type": "function",
        "label": "ftp_append( $ftp:FTP\\Connection, $remote_filename:string, $local_filename:string, $mode:int )",
        "apply": "ftp_append( $ftp:FTP\\Connection, $remote_filename:string, $local_filename:string, $mode:int )",
        "info": ""
    },
    "ƒ: ftp_nb_put": {
        "type": "function",
        "label": "ftp_nb_put( $ftp:FTP\\Connection, $remote_filename:string, $local_filename:string, $mode:int, $offset:int )",
        "apply": "ftp_nb_put( $ftp:FTP\\Connection, $remote_filename:string, $local_filename:string, $mode:int, $offset:int )",
        "info": "ftp_nb_put() stores a local file on the FTP server."
    },
    "ƒ: ftp_size": {
        "type": "function",
        "label": "ftp_size( $ftp:FTP\\Connection, $filename:string )",
        "apply": "ftp_size( $ftp:FTP\\Connection, $filename:string )",
        "info": "ftp_size() returns the size of the given file in bytes."
    },
    "ƒ: ftp_mdtm": {
        "type": "function",
        "label": "ftp_mdtm( $ftp:FTP\\Connection, $filename:string )",
        "apply": "ftp_mdtm( $ftp:FTP\\Connection, $filename:string )",
        "info": "ftp_mdtm() gets the last modified time for a remote file."
    },
    "ƒ: ftp_rename": {
        "type": "function",
        "label": "ftp_rename( $ftp:FTP\\Connection, $from:string, $to:string )",
        "apply": "ftp_rename( $ftp:FTP\\Connection, $from:string, $to:string )",
        "info": "ftp_rename() renames a file or a directory on the FTP server."
    },
    "ƒ: ftp_delete": {
        "type": "function",
        "label": "ftp_delete( $ftp:FTP\\Connection, $filename:string )",
        "apply": "ftp_delete( $ftp:FTP\\Connection, $filename:string )",
        "info": "ftp_delete() deletes the file specified by filename from the FTP server."
    },
    "ƒ: ftp_site": {
        "type": "function",
        "label": "ftp_site( $ftp:FTP\\Connection, $command:string )",
        "apply": "ftp_site( $ftp:FTP\\Connection, $command:string )",
        "info": "ftp_site() sends the given SITE command to the FTP server."
    },
    "ƒ: ftp_close": {
        "type": "function",
        "label": "ftp_close( $ftp:FTP\\Connection )",
        "apply": "ftp_close( $ftp:FTP\\Connection )",
        "info": "ftp_close() closes the given link identifier and releases the resource."
    },
    "ƒ: ftp_quit": {
        "type": "function",
        "label": "ftp_quit( $ftp:FTP\\Connection )",
        "apply": "ftp_quit( $ftp:FTP\\Connection )",
        "info": "This function is an alias of: ftp_close()."
    },
    "ƒ: ftp_set_option": {
        "type": "function",
        "label": "ftp_set_option( $ftp:FTP\\Connection, $option:int, $value: )",
        "apply": "ftp_set_option( $ftp:FTP\\Connection, $option:int, $value: )",
        "info": "This function controls various runtime options for the specified FTP connection."
    },
    "ƒ: ftp_get_option": {
        "type": "function",
        "label": "ftp_get_option( $ftp:FTP\\Connection, $option:int )",
        "apply": "ftp_get_option( $ftp:FTP\\Connection, $option:int )",
        "info": "This function returns the value for the requested option from the specified FTP connection."
    },
    "ƒ: hash": {
        "type": "function",
        "label": "hash( $algo:string, $data:string, $binary:bool, $options:array )",
        "apply": "hash( $algo:string, $data:string, $binary:bool, $options:array )",
        "info": null
    },
    "ƒ: hash_file": {
        "type": "function",
        "label": "hash_file( $algo:string, $filename:string, $binary:bool, $options:array )",
        "apply": "hash_file( $algo:string, $filename:string, $binary:bool, $options:array )",
        "info": null
    },
    "ƒ: hash_hmac": {
        "type": "function",
        "label": "hash_hmac( $algo:string, $data:string, $key:string, $binary:bool )",
        "apply": "hash_hmac( $algo:string, $data:string, $key:string, $binary:bool )",
        "info": null
    },
    "ƒ: hash_hmac_file": {
        "type": "function",
        "label": "hash_hmac_file( $algo:string, $filename:string, $key:string, $binary:bool )",
        "apply": "hash_hmac_file( $algo:string, $filename:string, $key:string, $binary:bool )",
        "info": null
    },
    "ƒ: hash_init": {
        "type": "function",
        "label": "hash_init( $algo:string, $flags:int, $key:string, $options:array )",
        "apply": "hash_init( $algo:string, $flags:int, $key:string, $options:array )",
        "info": null
    },
    "ƒ: hash_update": {
        "type": "function",
        "label": "hash_update( $context:HashContext, $data:string )",
        "apply": "hash_update( $context:HashContext, $data:string )",
        "info": null
    },
    "ƒ: hash_update_stream": {
        "type": "function",
        "label": "hash_update_stream( $context:HashContext, $stream:, $length:int )",
        "apply": "hash_update_stream( $context:HashContext, $stream:, $length:int )",
        "info": null
    },
    "ƒ: hash_update_file": {
        "type": "function",
        "label": "hash_update_file( $context:HashContext, $filename:string, $stream_context: )",
        "apply": "hash_update_file( $context:HashContext, $filename:string, $stream_context: )",
        "info": null
    },
    "ƒ: hash_final": {
        "type": "function",
        "label": "hash_final( $context:HashContext, $binary:bool )",
        "apply": "hash_final( $context:HashContext, $binary:bool )",
        "info": null
    },
    "ƒ: hash_copy": {
        "type": "function",
        "label": "hash_copy( $context:HashContext )",
        "apply": "hash_copy( $context:HashContext )",
        "info": null
    },
    "ƒ: hash_algos": {
        "type": "function",
        "label": "hash_algos()",
        "apply": "hash_algos()",
        "info": null
    },
    "ƒ: hash_hmac_algos": {
        "type": "function",
        "label": "hash_hmac_algos()",
        "apply": "hash_hmac_algos()",
        "info": null
    },
    "ƒ: hash_pbkdf2": {
        "type": "function",
        "label": "hash_pbkdf2( $algo:string, $password:string, $salt:string, $iterations:int, $length:int, $binary:bool )",
        "apply": "hash_pbkdf2( $algo:string, $password:string, $salt:string, $iterations:int, $length:int, $binary:bool )",
        "info": null
    },
    "ƒ: hash_equals": {
        "type": "function",
        "label": "hash_equals( $known_string:string, $user_string:string )",
        "apply": "hash_equals( $known_string:string, $user_string:string )",
        "info": "Compares two strings using the same time whether they're equal or not."
    },
    "ƒ: hash_hkdf": {
        "type": "function",
        "label": "hash_hkdf( $algo:string, $key:string, $length:int, $info:string, $salt:string )",
        "apply": "hash_hkdf( $algo:string, $key:string, $length:int, $info:string, $salt:string )",
        "info": null
    },
    "ƒ: mhash_get_block_size": {
        "type": "function",
        "label": "mhash_get_block_size( $algo:int )",
        "apply": "mhash_get_block_size( $algo:int )",
        "info": "Gets the size of a block of the specified algo."
    },
    "ƒ: mhash_get_hash_name": {
        "type": "function",
        "label": "mhash_get_hash_name( $algo:int )",
        "apply": "mhash_get_hash_name( $algo:int )",
        "info": "Gets the name of the specified algo."
    },
    "ƒ: mhash_keygen_s2k": {
        "type": "function",
        "label": "mhash_keygen_s2k( $algo:int, $password:string, $salt:string, $length:int )",
        "apply": "mhash_keygen_s2k( $algo:int, $password:string, $salt:string, $length:int )",
        "info": "Generates a key according to the given algo, using an user provided password."
    },
    "ƒ: mhash_count": {
        "type": "function",
        "label": "mhash_count()",
        "apply": "mhash_count()",
        "info": "Gets the highest available hash ID."
    },
    "ƒ: mhash": {
        "type": "function",
        "label": "mhash( $algo:int, $data:string, $key:?string )",
        "apply": "mhash( $algo:int, $data:string, $key:?string )",
        "info": "mhash() applies a hash function specified by algo to the data."
    },
    "ƒ: iconv_strlen": {
        "type": "function",
        "label": "iconv_strlen( $string:string, $encoding:?string )",
        "apply": "iconv_strlen( $string:string, $encoding:?string )",
        "info": "In contrast to strlen(),iconv_strlen() counts the occurrences of characters in the given byte sequence string on the basis of the specified character set, the result of which is not necessarily identical to the length of the string in byte."
    },
    "ƒ: iconv_substr": {
        "type": "function",
        "label": "iconv_substr( $string:string, $offset:int, $length:?int, $encoding:?string )",
        "apply": "iconv_substr( $string:string, $offset:int, $length:?int, $encoding:?string )",
        "info": "Cuts a portion of string specified by the offset and length parameters."
    },
    "ƒ: iconv_strpos": {
        "type": "function",
        "label": "iconv_strpos( $haystack:string, $needle:string, $offset:int, $encoding:?string )",
        "apply": "iconv_strpos( $haystack:string, $needle:string, $offset:int, $encoding:?string )",
        "info": "Finds position of first occurrence of a needle within a haystack."
    },
    "ƒ: iconv_strrpos": {
        "type": "function",
        "label": "iconv_strrpos( $haystack:string, $needle:string, $encoding:?string )",
        "apply": "iconv_strrpos( $haystack:string, $needle:string, $encoding:?string )",
        "info": "Finds the last occurrence of a needle within a haystack."
    },
    "ƒ: iconv_mime_encode": {
        "type": "function",
        "label": "iconv_mime_encode( $field_name:string, $field_value:string, $options:array )",
        "apply": "iconv_mime_encode( $field_name:string, $field_value:string, $options:array )",
        "info": "Composes and returns a string that represents a valid MIME header field, which looks like the following:"
    },
    "ƒ: iconv_mime_decode": {
        "type": "function",
        "label": "iconv_mime_decode( $string:string, $mode:int, $encoding:?string )",
        "apply": "iconv_mime_decode( $string:string, $mode:int, $encoding:?string )",
        "info": "Decodes a MIME header field."
    },
    "ƒ: iconv_mime_decode_headers": {
        "type": "function",
        "label": "iconv_mime_decode_headers( $headers:string, $mode:int, $encoding:?string )",
        "apply": "iconv_mime_decode_headers( $headers:string, $mode:int, $encoding:?string )",
        "info": "Decodes multiple MIME header fields at once."
    },
    "ƒ: iconv": {
        "type": "function",
        "label": "iconv( $from_encoding:string, $to_encoding:string, $string:string )",
        "apply": "iconv( $from_encoding:string, $to_encoding:string, $string:string )",
        "info": "Converts string from from_encoding to to_encoding."
    },
    "ƒ: iconv_set_encoding": {
        "type": "function",
        "label": "iconv_set_encoding( $type:string, $encoding:string )",
        "apply": "iconv_set_encoding( $type:string, $encoding:string )",
        "info": "Changes the value of the internal configuration variable specified by type to encoding."
    },
    "ƒ: iconv_get_encoding": {
        "type": "function",
        "label": "iconv_get_encoding( $type:string )",
        "apply": "iconv_get_encoding( $type:string )",
        "info": "Retrieve internal configuration variables of iconv extension."
    },
    "ƒ: json_encode": {
        "type": "function",
        "label": "json_encode( $value:mixed, $flags:int, $depth:int )",
        "apply": "json_encode( $value:mixed, $flags:int, $depth:int )",
        "info": "Returns a string containing the JSON representation of the supplied value.  If the parameter is an array or object,it will be serialized recursively."
    },
    "ƒ: json_decode": {
        "type": "function",
        "label": "json_decode( $json:string, $associative:?bool, $depth:int, $flags:int )",
        "apply": "json_decode( $json:string, $associative:?bool, $depth:int, $flags:int )",
        "info": "Takes a JSON encoded string and converts it into a PHP value."
    },
    "ƒ: json_last_error": {
        "type": "function",
        "label": "json_last_error()",
        "apply": "json_last_error()",
        "info": "Returns the last error (if any) occurred during the last JSON encoding\/decoding,which did not specify JSON_THROW_ON_ERROR."
    },
    "ƒ: json_last_error_msg": {
        "type": "function",
        "label": "json_last_error_msg()",
        "apply": "json_last_error_msg()",
        "info": "Returns the error string of the last json_encode() or json_decode()call, which did not specify JSON_THROW_ON_ERROR."
    },
    "ƒ: mb_language": {
        "type": "function",
        "label": "mb_language( $language:?string )",
        "apply": "mb_language( $language:?string )",
        "info": "Set\/Get the current language."
    },
    "ƒ: mb_internal_encoding": {
        "type": "function",
        "label": "mb_internal_encoding( $encoding:?string )",
        "apply": "mb_internal_encoding( $encoding:?string )",
        "info": "Set\/Get the internal character encoding "
    },
    "ƒ: mb_http_input": {
        "type": "function",
        "label": "mb_http_input( $type:?string )",
        "apply": "mb_http_input( $type:?string )",
        "info": "Detects the HTTP input character encoding."
    },
    "ƒ: mb_http_output": {
        "type": "function",
        "label": "mb_http_output( $encoding:?string )",
        "apply": "mb_http_output( $encoding:?string )",
        "info": "Set\/Get the HTTP output character encoding.Output after this function is called will be converted from the set internal encoding to encoding."
    },
    "ƒ: mb_detect_order": {
        "type": "function",
        "label": "mb_detect_order( $encoding:array|string|null )",
        "apply": "mb_detect_order( $encoding:array|string|null )",
        "info": "Sets the automatic character encoding detection order to encoding."
    },
    "ƒ: mb_substitute_character": {
        "type": "function",
        "label": "mb_substitute_character( $substitute_character:string|int|null )",
        "apply": "mb_substitute_character( $substitute_character:string|int|null )",
        "info": "Specifies a substitution character when input character encoding is invalid or character code does not exist in output character encoding. Invalid characters may be substituted \"none\" (no output),string or int value (Unicode character code value)."
    },
    "ƒ: mb_preferred_mime_name": {
        "type": "function",
        "label": "mb_preferred_mime_name( $encoding:string )",
        "apply": "mb_preferred_mime_name( $encoding:string )",
        "info": "Get a MIME charset string for a specific encoding."
    },
    "ƒ: mb_parse_str": {
        "type": "function",
        "label": "mb_parse_str( $string:string, $result: )",
        "apply": "mb_parse_str( $string:string, $result: )",
        "info": "Parses GET\/POST\/COOKIE data and sets global variables. Since PHP does not provide raw POST\/COOKIE data, it can only be used for GET data for now. It parses URL encoded data, detects encoding, converts coding to internal encoding and set values to the result array or global variables."
    },
    "ƒ: mb_output_handler": {
        "type": "function",
        "label": "mb_output_handler( $string:string, $status:int )",
        "apply": "mb_output_handler( $string:string, $status:int )",
        "info": "mb_output_handler() is ob_start() callback function. mb_output_handler() converts characters in the output buffer from internal character encoding to HTTP output character encoding. "
    },
    "ƒ: mb_str_split": {
        "type": "function",
        "label": "mb_str_split( $string:string, $length:int, $encoding:?string )",
        "apply": "mb_str_split( $string:string, $length:int, $encoding:?string )",
        "info": "This function will return an array of strings, it is a version of str_split() with support for encodings of variable character size as well as fixed-size encodings of 1,2 or 4 byte characters.If the length parameter is specified, the string is broken down into chunks of the specified length in characters (not bytes).The encoding parameter can be optionally specified and it is good practice to do so."
    },
    "ƒ: mb_strlen": {
        "type": "function",
        "label": "mb_strlen( $string:string, $encoding:?string )",
        "apply": "mb_strlen( $string:string, $encoding:?string )",
        "info": "Gets the length of a string."
    },
    "ƒ: mb_strpos": {
        "type": "function",
        "label": "mb_strpos( $haystack:string, $needle:string, $offset:int, $encoding:?string )",
        "apply": "mb_strpos( $haystack:string, $needle:string, $offset:int, $encoding:?string )",
        "info": "Finds position of the first occurrence of a string in a string."
    },
    "ƒ: mb_strrpos": {
        "type": "function",
        "label": "mb_strrpos( $haystack:string, $needle:string, $offset:int, $encoding:?string )",
        "apply": "mb_strrpos( $haystack:string, $needle:string, $offset:int, $encoding:?string )",
        "info": "Performs a multibyte safe strrpos() operation based on the number of characters. needle position is counted from the beginning of haystack. First character's position is 0. Second character position is 1. "
    },
    "ƒ: mb_stripos": {
        "type": "function",
        "label": "mb_stripos( $haystack:string, $needle:string, $offset:int, $encoding:?string )",
        "apply": "mb_stripos( $haystack:string, $needle:string, $offset:int, $encoding:?string )",
        "info": "mb_stripos() returns the numeric position of the first occurrence of needle in the haystack string.Unlike mb_strpos(), mb_stripos() is case-insensitive.If needle is not found, it returns false."
    },
    "ƒ: mb_strripos": {
        "type": "function",
        "label": "mb_strripos( $haystack:string, $needle:string, $offset:int, $encoding:?string )",
        "apply": "mb_strripos( $haystack:string, $needle:string, $offset:int, $encoding:?string )",
        "info": "mb_strripos() performs multi-byte safe strripos() operation based on number of characters. needle position is counted from the beginning of haystack. First character's position is 0. Second character position is 1. Unlike mb_strrpos(),mb_strripos() is case-insensitive."
    },
    "ƒ: mb_strstr": {
        "type": "function",
        "label": "mb_strstr( $haystack:string, $needle:string, $before_needle:bool, $encoding:?string )",
        "apply": "mb_strstr( $haystack:string, $needle:string, $before_needle:bool, $encoding:?string )",
        "info": "mb_strstr() finds the first occurrence of needle in haystack and returns the portion of haystack.If needle is not found, it returns false."
    },
    "ƒ: mb_strrchr": {
        "type": "function",
        "label": "mb_strrchr( $haystack:string, $needle:string, $before_needle:bool, $encoding:?string )",
        "apply": "mb_strrchr( $haystack:string, $needle:string, $before_needle:bool, $encoding:?string )",
        "info": "mb_strrchr() finds the last occurrence of needle in haystack and returns the portion of haystack.If needle is not found, it returns false."
    },
    "ƒ: mb_stristr": {
        "type": "function",
        "label": "mb_stristr( $haystack:string, $needle:string, $before_needle:bool, $encoding:?string )",
        "apply": "mb_stristr( $haystack:string, $needle:string, $before_needle:bool, $encoding:?string )",
        "info": "mb_stristr() finds the first occurrence of needle in haystack and returns the portion of haystack.Unlike mb_strstr(), mb_stristr() is case-insensitive.If needle is not found, it returns false."
    },
    "ƒ: mb_strrichr": {
        "type": "function",
        "label": "mb_strrichr( $haystack:string, $needle:string, $before_needle:bool, $encoding:?string )",
        "apply": "mb_strrichr( $haystack:string, $needle:string, $before_needle:bool, $encoding:?string )",
        "info": "mb_strrichr() finds the last occurrence of needle in haystack and returns the portion of haystack. Unlike mb_strrchr(), mb_strrichr() is case-insensitive.If needle is not found, it returns false."
    },
    "ƒ: mb_substr_count": {
        "type": "function",
        "label": "mb_substr_count( $haystack:string, $needle:string, $encoding:?string )",
        "apply": "mb_substr_count( $haystack:string, $needle:string, $encoding:?string )",
        "info": "Counts the number of times the needle substring occurs in the haystack string."
    },
    "ƒ: mb_substr": {
        "type": "function",
        "label": "mb_substr( $string:string, $start:int, $length:?int, $encoding:?string )",
        "apply": "mb_substr( $string:string, $start:int, $length:?int, $encoding:?string )",
        "info": "Performs a multi-byte safe substr() operation based on number of characters. Position is counted from the beginning of string. First character's position is 0. Second character position is 1, and so on. "
    },
    "ƒ: mb_strcut": {
        "type": "function",
        "label": "mb_strcut( $string:string, $start:int, $length:?int, $encoding:?string )",
        "apply": "mb_strcut( $string:string, $start:int, $length:?int, $encoding:?string )",
        "info": "mb_strcut() extracts a substring from a string similarly to mb_substr(), but operates on bytes instead of characters. If the cut position happens to be between two bytes of a multi-byte character, the cut is performed starting from the first byte of that character. This is also the difference to the substr() function, which would simply cut the string between the bytes and thus result in a malformed byte sequence."
    },
    "ƒ: mb_strwidth": {
        "type": "function",
        "label": "mb_strwidth( $string:string, $encoding:?string )",
        "apply": "mb_strwidth( $string:string, $encoding:?string )",
        "info": "Returns the width of string string,where halfwidth characters count as 1, and fullwidth characters count as 2.See \u00bb\u00a0http:\/\/www.unicode.org\/reports\/tr11\/for details regarding East Asian character widths."
    },
    "ƒ: mb_strimwidth": {
        "type": "function",
        "label": "mb_strimwidth( $string:string, $start:int, $width:int, $trim_marker:string, $encoding:?string )",
        "apply": "mb_strimwidth( $string:string, $start:int, $width:int, $trim_marker:string, $encoding:?string )",
        "info": "Truncates string string to specified width,where halfwidth characters count as 1, and fullwidth characters count as 2.See \u00bb\u00a0http:\/\/www.unicode.org\/reports\/tr11\/for details regarding East Asian character widths."
    },
    "ƒ: mb_convert_encoding": {
        "type": "function",
        "label": "mb_convert_encoding( $string:array|string, $to_encoding:string, $from_encoding:array|string|null )",
        "apply": "mb_convert_encoding( $string:array|string, $to_encoding:string, $from_encoding:array|string|null )",
        "info": "Converts string from from_encoding,or the current internal encoding, to to_encoding.If string is an array, all its string values will be converted recursively."
    },
    "ƒ: mb_convert_case": {
        "type": "function",
        "label": "mb_convert_case( $string:string, $mode:int, $encoding:?string )",
        "apply": "mb_convert_case( $string:string, $mode:int, $encoding:?string )",
        "info": "Performs case folding on a string, converted in the way specified by mode."
    },
    "ƒ: mb_strtoupper": {
        "type": "function",
        "label": "mb_strtoupper( $string:string, $encoding:?string )",
        "apply": "mb_strtoupper( $string:string, $encoding:?string )",
        "info": "Returns string with all alphabetic characters converted to uppercase."
    },
    "ƒ: mb_strtolower": {
        "type": "function",
        "label": "mb_strtolower( $string:string, $encoding:?string )",
        "apply": "mb_strtolower( $string:string, $encoding:?string )",
        "info": "Returns string with all alphabetic characters converted to lowercase."
    },
    "ƒ: mb_detect_encoding": {
        "type": "function",
        "label": "mb_detect_encoding( $string:string, $encodings:array|string|null, $strict:bool )",
        "apply": "mb_detect_encoding( $string:string, $encodings:array|string|null, $strict:bool )",
        "info": "Detects the most likely character encoding for string string from an ordered list of candidates."
    },
    "ƒ: mb_list_encodings": {
        "type": "function",
        "label": "mb_list_encodings()",
        "apply": "mb_list_encodings()",
        "info": "Returns an array containing all supported encodings."
    },
    "ƒ: mb_encoding_aliases": {
        "type": "function",
        "label": "mb_encoding_aliases( $encoding:string )",
        "apply": "mb_encoding_aliases( $encoding:string )",
        "info": "Returns an array of aliases for a known encoding type."
    },
    "ƒ: mb_encode_mimeheader": {
        "type": "function",
        "label": "mb_encode_mimeheader( $string:string, $charset:?string, $transfer_encoding:?string, $newline:string, $indent:int )",
        "apply": "mb_encode_mimeheader( $string:string, $charset:?string, $transfer_encoding:?string, $newline:string, $indent:int )",
        "info": "Encodes a given string string by the MIME header encoding scheme."
    },
    "ƒ: mb_decode_mimeheader": {
        "type": "function",
        "label": "mb_decode_mimeheader( $string:string )",
        "apply": "mb_decode_mimeheader( $string:string )",
        "info": "Decodes encoded-word string string in MIME header. "
    },
    "ƒ: mb_convert_kana": {
        "type": "function",
        "label": "mb_convert_kana( $string:string, $mode:string, $encoding:?string )",
        "apply": "mb_convert_kana( $string:string, $mode:string, $encoding:?string )",
        "info": "Performs a \"han-kaku\" - \"zen-kaku\" conversion for string string. This function is only useful for Japanese."
    },
    "ƒ: mb_convert_variables": {
        "type": "function",
        "label": "mb_convert_variables( $to_encoding:string, $from_encoding:array|string, $var:mixed, $vars:mixed )",
        "apply": "mb_convert_variables( $to_encoding:string, $from_encoding:array|string, $var:mixed, $vars:mixed )",
        "info": "Converts character encoding of variables var and vars in encoding from_encoding to encoding to_encoding. "
    },
    "ƒ: mb_encode_numericentity": {
        "type": "function",
        "label": "mb_encode_numericentity( $string:string, $map:array, $encoding:?string, $hex:bool )",
        "apply": "mb_encode_numericentity( $string:string, $map:array, $encoding:?string, $hex:bool )",
        "info": "Converts specified character codes in string string from character code to HTML numeric character reference.    "
    },
    "ƒ: mb_decode_numericentity": {
        "type": "function",
        "label": "mb_decode_numericentity( $string:string, $map:array, $encoding:?string )",
        "apply": "mb_decode_numericentity( $string:string, $map:array, $encoding:?string )",
        "info": "Convert numeric string reference of string string in a specified block to character. "
    },
    "ƒ: mb_send_mail": {
        "type": "function",
        "label": "mb_send_mail( $to:string, $subject:string, $message:string, $additional_headers:array|string, $additional_params:?string )",
        "apply": "mb_send_mail( $to:string, $subject:string, $message:string, $additional_headers:array|string, $additional_params:?string )",
        "info": "Sends email. Headers and messages are converted and encoded according to the mb_language() setting. It's a wrapper function for mail(), so see also mail() for details."
    },
    "ƒ: mb_get_info": {
        "type": "function",
        "label": "mb_get_info( $type:string )",
        "apply": "mb_get_info( $type:string )",
        "info": "mb_get_info() returns the internal setting parameters of mbstring."
    },
    "ƒ: mb_check_encoding": {
        "type": "function",
        "label": "mb_check_encoding( $value:array|string|null, $encoding:?string )",
        "apply": "mb_check_encoding( $value:array|string|null, $encoding:?string )",
        "info": "Checks if the specified byte stream is valid for the specified encoding.If value is of type array, all keys and values are validated recursively.It is useful to prevent so-called \"Invalid Encoding Attack\"."
    },
    "ƒ: mb_scrub": {
        "type": "function",
        "label": "mb_scrub( $string:string, $encoding:?string )",
        "apply": "mb_scrub( $string:string, $encoding:?string )",
        "info": ""
    },
    "ƒ: mb_ord": {
        "type": "function",
        "label": "mb_ord( $string:string, $encoding:?string )",
        "apply": "mb_ord( $string:string, $encoding:?string )",
        "info": "Returns the Unicode code point value of the given character."
    },
    "ƒ: mb_chr": {
        "type": "function",
        "label": "mb_chr( $codepoint:int, $encoding:?string )",
        "apply": "mb_chr( $codepoint:int, $encoding:?string )",
        "info": "Returns a string containing the character specified by the Unicode code point value,encoded in the specified encoding."
    },
    "ƒ: mb_regex_encoding": {
        "type": "function",
        "label": "mb_regex_encoding( $encoding:?string )",
        "apply": "mb_regex_encoding( $encoding:?string )",
        "info": "Set\/Get character encoding for a multibyte regex."
    },
    "ƒ: mb_ereg": {
        "type": "function",
        "label": "mb_ereg( $pattern:string, $string:string, $matches: )",
        "apply": "mb_ereg( $pattern:string, $string:string, $matches: )",
        "info": "Executes the regular expression match with multibyte support."
    },
    "ƒ: mb_eregi": {
        "type": "function",
        "label": "mb_eregi( $pattern:string, $string:string, $matches: )",
        "apply": "mb_eregi( $pattern:string, $string:string, $matches: )",
        "info": "Executes the case insensitive regular expression match with multibyte support."
    },
    "ƒ: mb_ereg_replace": {
        "type": "function",
        "label": "mb_ereg_replace( $pattern:string, $replacement:string, $string:string, $options:?string )",
        "apply": "mb_ereg_replace( $pattern:string, $replacement:string, $string:string, $options:?string )",
        "info": "Scans string for matches to pattern, then replaces the matched text with replacement  "
    },
    "ƒ: mb_eregi_replace": {
        "type": "function",
        "label": "mb_eregi_replace( $pattern:string, $replacement:string, $string:string, $options:?string )",
        "apply": "mb_eregi_replace( $pattern:string, $replacement:string, $string:string, $options:?string )",
        "info": "Scans string for matches to pattern, then replaces the matched text with replacement. "
    },
    "ƒ: mb_ereg_replace_callback": {
        "type": "function",
        "label": "mb_ereg_replace_callback( $pattern:string, $callback:callable, $string:string, $options:?string )",
        "apply": "mb_ereg_replace_callback( $pattern:string, $callback:callable, $string:string, $options:?string )",
        "info": "Scans string for matches to pattern, then replaces the matched text with the output of callback function.  "
    },
    "ƒ: mb_split": {
        "type": "function",
        "label": "mb_split( $pattern:string, $string:string, $limit:int )",
        "apply": "mb_split( $pattern:string, $string:string, $limit:int )",
        "info": "Split a multibyte string using regular expression pattern and returns the result as an array."
    },
    "ƒ: mb_ereg_match": {
        "type": "function",
        "label": "mb_ereg_match( $pattern:string, $string:string, $options:?string )",
        "apply": "mb_ereg_match( $pattern:string, $string:string, $options:?string )",
        "info": "A regular expression match for a multibyte string "
    },
    "ƒ: mb_ereg_search": {
        "type": "function",
        "label": "mb_ereg_search( $pattern:?string, $options:?string )",
        "apply": "mb_ereg_search( $pattern:?string, $options:?string )",
        "info": "Performs a multibyte regular expression match for a predefined multibyte string."
    },
    "ƒ: mb_ereg_search_pos": {
        "type": "function",
        "label": "mb_ereg_search_pos( $pattern:?string, $options:?string )",
        "apply": "mb_ereg_search_pos( $pattern:?string, $options:?string )",
        "info": "Returns position and length of a matched part of the multibyte regular expression for a predefined multibyte string "
    },
    "ƒ: mb_ereg_search_regs": {
        "type": "function",
        "label": "mb_ereg_search_regs( $pattern:?string, $options:?string )",
        "apply": "mb_ereg_search_regs( $pattern:?string, $options:?string )",
        "info": "Returns the matched part of a multibyte regular expression."
    },
    "ƒ: mb_ereg_search_init": {
        "type": "function",
        "label": "mb_ereg_search_init( $string:string, $pattern:?string, $options:?string )",
        "apply": "mb_ereg_search_init( $string:string, $pattern:?string, $options:?string )",
        "info": "mb_ereg_search_init() sets string and pattern for a multibyte regular expression. These values are used for mb_ereg_search(),mb_ereg_search_pos(), and mb_ereg_search_regs(). "
    },
    "ƒ: mb_ereg_search_getregs": {
        "type": "function",
        "label": "mb_ereg_search_getregs()",
        "apply": "mb_ereg_search_getregs()",
        "info": "Retrieve the result from the last multibyte regular expression match "
    },
    "ƒ: mb_ereg_search_getpos": {
        "type": "function",
        "label": "mb_ereg_search_getpos()",
        "apply": "mb_ereg_search_getpos()",
        "info": "Returns the start point for the next regular expression match."
    },
    "ƒ: mb_ereg_search_setpos": {
        "type": "function",
        "label": "mb_ereg_search_setpos( $offset:int )",
        "apply": "mb_ereg_search_setpos( $offset:int )",
        "info": "mb_ereg_search_setpos() sets the starting point of a match for mb_ereg_search()."
    },
    "ƒ: mb_regex_set_options": {
        "type": "function",
        "label": "mb_regex_set_options( $options:?string )",
        "apply": "mb_regex_set_options( $options:?string )",
        "info": "Sets the default options described by options for multibyte regex functions."
    },
    "ƒ: set_time_limit": {
        "type": "function",
        "label": "set_time_limit( $seconds:int )",
        "apply": "set_time_limit( $seconds:int )",
        "info": "Set the number of seconds a script is allowed to run. If this is reached,the script returns a fatal error. The default limit is 30 seconds or, if it exists, the max_execution_time value defined in the php.ini."
    },
    "ƒ: header_register_callback": {
        "type": "function",
        "label": "header_register_callback( $callback:callable )",
        "apply": "header_register_callback( $callback:callable )",
        "info": "Registers a function that will be called when PHP starts sending output."
    },
    "ƒ: ob_start": {
        "type": "function",
        "label": "ob_start( $callback:, $chunk_size:int, $flags:int )",
        "apply": "ob_start( $callback:, $chunk_size:int, $flags:int )",
        "info": "This function will turn output buffering on. While output buffering is active no output is sent from the script (other than headers), instead the output is stored in an internal buffer."
    },
    "ƒ: ob_flush": {
        "type": "function",
        "label": "ob_flush()",
        "apply": "ob_flush()",
        "info": "This function will send the contents of the output buffer (if any). If you want to further process the buffer's contents you have to call ob_get_contents() before ob_flush()as the buffer contents are discarded after ob_flush()is called."
    },
    "ƒ: ob_clean": {
        "type": "function",
        "label": "ob_clean()",
        "apply": "ob_clean()",
        "info": "This function discards the contents of the output buffer."
    },
    "ƒ: ob_end_flush": {
        "type": "function",
        "label": "ob_end_flush()",
        "apply": "ob_end_flush()",
        "info": "This function will send the contents of the topmost output buffer (if any) and turn this output buffer off.  If you want to further process the buffer's contents you have to call ob_get_contents() before ob_end_flush() as the buffer contents are discarded after ob_end_flush() is called."
    },
    "ƒ: ob_end_clean": {
        "type": "function",
        "label": "ob_end_clean()",
        "apply": "ob_end_clean()",
        "info": "This function discards the contents of the topmost output buffer and turns off this output buffering. If you want to further process the buffer's contents you have to call ob_get_contents() before ob_end_clean() as the buffer contents are discarded when ob_end_clean() is called."
    },
    "ƒ: ob_get_flush": {
        "type": "function",
        "label": "ob_get_flush()",
        "apply": "ob_get_flush()",
        "info": "ob_get_flush() flushes the output buffer, return it as a string and turns off output buffering."
    },
    "ƒ: ob_get_clean": {
        "type": "function",
        "label": "ob_get_clean()",
        "apply": "ob_get_clean()",
        "info": "Gets the current buffer contents and delete current output buffer."
    },
    "ƒ: ob_get_contents": {
        "type": "function",
        "label": "ob_get_contents()",
        "apply": "ob_get_contents()",
        "info": "Gets the contents of the output buffer without clearing it."
    },
    "ƒ: ob_get_level": {
        "type": "function",
        "label": "ob_get_level()",
        "apply": "ob_get_level()",
        "info": "Returns the nesting level of the output buffering mechanism."
    },
    "ƒ: ob_get_length": {
        "type": "function",
        "label": "ob_get_length()",
        "apply": "ob_get_length()",
        "info": "This will return the length of the contents in the output buffer, in bytes."
    },
    "ƒ: ob_list_handlers": {
        "type": "function",
        "label": "ob_list_handlers()",
        "apply": "ob_list_handlers()",
        "info": "Lists all output handlers in use."
    },
    "ƒ: ob_get_status": {
        "type": "function",
        "label": "ob_get_status( $full_status:bool )",
        "apply": "ob_get_status( $full_status:bool )",
        "info": "ob_get_status() returns status information on either the top level output buffer or all active output buffer levels if full_status is set to true."
    },
    "ƒ: ob_implicit_flush": {
        "type": "function",
        "label": "ob_implicit_flush( $enable:bool )",
        "apply": "ob_implicit_flush( $enable:bool )",
        "info": "ob_implicit_flush() will turn implicit flushing on or off. Implicit flushing will result in a flush operation after every output call, so that explicit calls to flush() will no longer be needed."
    },
    "ƒ: output_reset_rewrite_vars": {
        "type": "function",
        "label": "output_reset_rewrite_vars()",
        "apply": "output_reset_rewrite_vars()",
        "info": "This function resets the URL rewriter and removes all rewrite variables previously set by the output_add_rewrite_var()function."
    },
    "ƒ: output_add_rewrite_var": {
        "type": "function",
        "label": "output_add_rewrite_var( $name:string, $value:string )",
        "apply": "output_add_rewrite_var( $name:string, $value:string )",
        "info": "This function adds another name\/value pair to the URL rewrite mechanism.The name and value will be added to URLs (as GET parameter) and forms (as hidden input fields) the same way as the session ID when transparent URL rewriting is enabled with session.use_trans_sid. "
    },
    "ƒ: stream_wrapper_register": {
        "type": "function",
        "label": "stream_wrapper_register( $protocol:string, $class:string, $flags:int )",
        "apply": "stream_wrapper_register( $protocol:string, $class:string, $flags:int )",
        "info": "Allows you to implement your own protocol handlers and streams for use with all the other filesystem functions (such as fopen(),fread() etc.)."
    },
    "ƒ: stream_register_wrapper": {
        "type": "function",
        "label": "stream_register_wrapper( $protocol:string, $class:string, $flags:int )",
        "apply": "stream_register_wrapper( $protocol:string, $class:string, $flags:int )",
        "info": "This function is an alias of:  stream_wrapper_register()."
    },
    "ƒ: stream_wrapper_unregister": {
        "type": "function",
        "label": "stream_wrapper_unregister( $protocol:string )",
        "apply": "stream_wrapper_unregister( $protocol:string )",
        "info": "Allows you to disable an already defined stream wrapper. Once the wrapper has been disabled you may override it with a user-defined wrapper using stream_wrapper_register() or reenable it later on with stream_wrapper_restore()."
    },
    "ƒ: stream_wrapper_restore": {
        "type": "function",
        "label": "stream_wrapper_restore( $protocol:string )",
        "apply": "stream_wrapper_restore( $protocol:string )",
        "info": "Restores a built-in wrapper previously unregistered with stream_wrapper_unregister()."
    },
    "ƒ: array_push": {
        "type": "function",
        "label": "array_push( $array:array, $values:mixed )",
        "apply": "array_push( $array:array, $values:mixed )",
        "info": "array_push() treats array as a stack, and pushes the passed variables onto the end of array. The length of array increases by the number of variables pushed. Has the same effect as:"
    },
    "ƒ: krsort": {
        "type": "function",
        "label": "krsort( $array:array, $flags:int )",
        "apply": "krsort( $array:array, $flags:int )",
        "info": "Sorts array in place by keys in descending order."
    },
    "ƒ: ksort": {
        "type": "function",
        "label": "ksort( $array:array, $flags:int )",
        "apply": "ksort( $array:array, $flags:int )",
        "info": "Sorts array in place by keys in ascending order."
    },
    "ƒ: count": {
        "type": "function",
        "label": "count( $value:Countable|array, $mode:int )",
        "apply": "count( $value:Countable|array, $mode:int )",
        "info": "Counts all elements in an array when used with an array. When used with an object that implements the Countable interface, it returns the return value of the method Countable::count()."
    },
    "ƒ: sizeof": {
        "type": "function",
        "label": "sizeof( $value:Countable|array, $mode:int )",
        "apply": "sizeof( $value:Countable|array, $mode:int )",
        "info": "This function is an alias of: count()."
    },
    "ƒ: natsort": {
        "type": "function",
        "label": "natsort( $array:array )",
        "apply": "natsort( $array:array )",
        "info": "This function implements a sort algorithm that orders alphanumeric strings in the way a human being would while maintaining key\/value associations.This is described as a \"natural ordering\".  An example of the difference between this algorithm and the regular computer string sorting algorithms (used in sort()) can be seen in the example below."
    },
    "ƒ: natcasesort": {
        "type": "function",
        "label": "natcasesort( $array:array )",
        "apply": "natcasesort( $array:array )",
        "info": "natcasesort() is a case insensitive version of natsort()."
    },
    "ƒ: asort": {
        "type": "function",
        "label": "asort( $array:array, $flags:int )",
        "apply": "asort( $array:array, $flags:int )",
        "info": "Sorts array in place in ascending order,such that its keys maintain their correlation with the values they are associated with."
    },
    "ƒ: arsort": {
        "type": "function",
        "label": "arsort( $array:array, $flags:int )",
        "apply": "arsort( $array:array, $flags:int )",
        "info": "Sorts array in place in descending order,such that its keys maintain their correlation with the values they are associated with."
    },
    "ƒ: sort": {
        "type": "function",
        "label": "sort( $array:array, $flags:int )",
        "apply": "sort( $array:array, $flags:int )",
        "info": "Sorts array in place by values in ascending order."
    },
    "ƒ: rsort": {
        "type": "function",
        "label": "rsort( $array:array, $flags:int )",
        "apply": "rsort( $array:array, $flags:int )",
        "info": "Sorts array in place by values in descending order."
    },
    "ƒ: usort": {
        "type": "function",
        "label": "usort( $array:array, $callback:callable )",
        "apply": "usort( $array:array, $callback:callable )",
        "info": "Sorts array in place by values using a user-supplied comparison function to determine the order."
    },
    "ƒ: uasort": {
        "type": "function",
        "label": "uasort( $array:array, $callback:callable )",
        "apply": "uasort( $array:array, $callback:callable )",
        "info": "Sorts array in place such that its keys maintain their correlation with the values they are associated with,using a user-defined comparison function."
    },
    "ƒ: uksort": {
        "type": "function",
        "label": "uksort( $array:array, $callback:callable )",
        "apply": "uksort( $array:array, $callback:callable )",
        "info": "Sorts array in place by keys using a user-supplied comparison function to determine the order."
    },
    "ƒ: end": {
        "type": "function",
        "label": "end( $array:object|array )",
        "apply": "end( $array:object|array )",
        "info": "end() advances array's internal pointer to the last element, and returns its value."
    },
    "ƒ: prev": {
        "type": "function",
        "label": "prev( $array:object|array )",
        "apply": "prev( $array:object|array )",
        "info": "Rewind the internal array pointer."
    },
    "ƒ: next": {
        "type": "function",
        "label": "next( $array:object|array )",
        "apply": "next( $array:object|array )",
        "info": "next() behaves like current(), with one difference.  It advances the internal array pointer one place forward before returning the element value.  That means it returns the next array value and advances the internal array pointer by one."
    },
    "ƒ: reset": {
        "type": "function",
        "label": "reset( $array:object|array )",
        "apply": "reset( $array:object|array )",
        "info": "reset() rewinds array's internal pointer to the first element and returns the value of the first array element."
    },
    "ƒ: current": {
        "type": "function",
        "label": "current( $array:object|array )",
        "apply": "current( $array:object|array )",
        "info": "Every array has an internal pointer to its \"current\" element,which is initialized to the first element inserted into the array."
    },
    "ƒ: pos": {
        "type": "function",
        "label": "pos( $array:object|array )",
        "apply": "pos( $array:object|array )",
        "info": "This function is an alias of: current()"
    },
    "ƒ: key": {
        "type": "function",
        "label": "key( $array:object|array )",
        "apply": "key( $array:object|array )",
        "info": "key() returns the index element of the current array position."
    },
    "ƒ: min": {
        "type": "function",
        "label": "min( $value:mixed, $values:mixed )",
        "apply": "min( $value:mixed, $values:mixed )",
        "info": "Alternative signature (not supported with named arguments):"
    },
    "ƒ: max": {
        "type": "function",
        "label": "max( $value:mixed, $values:mixed )",
        "apply": "max( $value:mixed, $values:mixed )",
        "info": "Alternative signature (not supported with named arguments):"
    },
    "ƒ: array_walk": {
        "type": "function",
        "label": "array_walk( $array:object|array, $callback:callable, $arg:mixed )",
        "apply": "array_walk( $array:object|array, $callback:callable, $arg:mixed )",
        "info": "Applies the user-defined callback function to each element of the array array."
    },
    "ƒ: array_walk_recursive": {
        "type": "function",
        "label": "array_walk_recursive( $array:object|array, $callback:callable, $arg:mixed )",
        "apply": "array_walk_recursive( $array:object|array, $callback:callable, $arg:mixed )",
        "info": "Applies the user-defined callback function to each element of the array. This function will recurse into deeper arrays."
    },
    "ƒ: in_array": {
        "type": "function",
        "label": "in_array( $needle:mixed, $haystack:array, $strict:bool )",
        "apply": "in_array( $needle:mixed, $haystack:array, $strict:bool )",
        "info": "Searches for needle in haystack using loose comparison unless strict is set."
    },
    "ƒ: array_search": {
        "type": "function",
        "label": "array_search( $needle:mixed, $haystack:array, $strict:bool )",
        "apply": "array_search( $needle:mixed, $haystack:array, $strict:bool )",
        "info": "Searches for needle in haystack."
    },
    "ƒ: extract": {
        "type": "function",
        "label": "extract( $array:array, $flags:int, $prefix:string )",
        "apply": "extract( $array:array, $flags:int, $prefix:string )",
        "info": "Import variables from an array into the current symbol table."
    },
    "ƒ: compact": {
        "type": "function",
        "label": "compact( $var_name:, $var_names: )",
        "apply": "compact( $var_name:, $var_names: )",
        "info": "Creates an array containing variables and their values."
    },
    "ƒ: array_fill": {
        "type": "function",
        "label": "array_fill( $start_index:int, $count:int, $value:mixed )",
        "apply": "array_fill( $start_index:int, $count:int, $value:mixed )",
        "info": "Fills an array with count entries of the value of the value parameter, keys starting at the start_index parameter."
    },
    "ƒ: array_fill_keys": {
        "type": "function",
        "label": "array_fill_keys( $keys:array, $value:mixed )",
        "apply": "array_fill_keys( $keys:array, $value:mixed )",
        "info": "Fills an array with the value of the value parameter, using the values of the keys array as keys."
    },
    "ƒ: range": {
        "type": "function",
        "label": "range( $start:, $end:, $step:int|float )",
        "apply": "range( $start:, $end:, $step:int|float )",
        "info": "Create an array containing a range of elements."
    },
    "ƒ: shuffle": {
        "type": "function",
        "label": "shuffle( $array:array )",
        "apply": "shuffle( $array:array )",
        "info": "This function shuffles (randomizes the order of the elements in) an array."
    },
    "ƒ: array_pop": {
        "type": "function",
        "label": "array_pop( $array:array )",
        "apply": "array_pop( $array:array )",
        "info": "array_pop() pops and returns the value of the last element of array, shortening the array by one element."
    },
    "ƒ: array_shift": {
        "type": "function",
        "label": "array_shift( $array:array )",
        "apply": "array_shift( $array:array )",
        "info": "array_shift() shifts the first value of the array off and returns it, shortening the array by one element and moving everything down. All numerical array keys will be modified to start counting from zero while literal keys won't be affected."
    },
    "ƒ: array_unshift": {
        "type": "function",
        "label": "array_unshift( $array:array, $values:mixed )",
        "apply": "array_unshift( $array:array, $values:mixed )",
        "info": "array_unshift() prepends passed elements to the front of the array. Note that the list of elements is prepended as a whole, so that the prepended elements stay in the same order.  All numerical array keys will be modified to start counting from zero while literal keys won't be changed."
    },
    "ƒ: array_splice": {
        "type": "function",
        "label": "array_splice( $array:array, $offset:int, $length:?int, $replacement:mixed )",
        "apply": "array_splice( $array:array, $offset:int, $length:?int, $replacement:mixed )",
        "info": "Removes the elements designated by offset and length from the array array,and replaces them with the elements of the replacement array, if supplied."
    },
    "ƒ: array_slice": {
        "type": "function",
        "label": "array_slice( $array:array, $offset:int, $length:?int, $preserve_keys:bool )",
        "apply": "array_slice( $array:array, $offset:int, $length:?int, $preserve_keys:bool )",
        "info": "array_slice() returns the sequence of elements from the array array as specified by the offset and length parameters."
    },
    "ƒ: array_merge": {
        "type": "function",
        "label": "array_merge( $arrays:array )",
        "apply": "array_merge( $arrays:array )",
        "info": "Merges the elements of one or more arrays together so that the values of one are appended to the end of the previous one. It returns the resulting array."
    },
    "ƒ: array_merge_recursive": {
        "type": "function",
        "label": "array_merge_recursive( $arrays:array )",
        "apply": "array_merge_recursive( $arrays:array )",
        "info": "array_merge_recursive() merges the elements of one or more arrays together so that the values of one are appended to the end of the previous one.  It returns the resulting array."
    },
    "ƒ: array_replace": {
        "type": "function",
        "label": "array_replace( $array:array, $replacements:array )",
        "apply": "array_replace( $array:array, $replacements:array )",
        "info": "array_replace() replaces the values of array with values having the same keys in each of the following arrays. If a key from the first array exists in the second array, its value will be replaced by the value from the second array. If the key exists in the second array, and not the first, it will be created in the first array.If a key only exists in the first array, it will be left as is.If several arrays are passed for replacement, they will be processed in order, the later arrays overwriting the previous values."
    },
    "ƒ: array_replace_recursive": {
        "type": "function",
        "label": "array_replace_recursive( $array:array, $replacements:array )",
        "apply": "array_replace_recursive( $array:array, $replacements:array )",
        "info": "array_replace_recursive() replaces the values of array with the same values from all the following arrays. If a key from the first array exists in the second array, its value will be replaced by the value from the second array. If the key exists in the second array, and not the first, it will be created in the first array.If a key only exists in the first array, it will be left as is. If several arrays are passed for replacement, they will be processed in order, the later array overwriting the previous values."
    },
    "ƒ: array_keys": {
        "type": "function",
        "label": "array_keys( $array:array, $filter_value:mixed, $strict:bool )",
        "apply": "array_keys( $array:array, $filter_value:mixed, $strict:bool )",
        "info": "array_keys() returns the keys, numeric and string, from the array."
    },
    "ƒ: array_key_first": {
        "type": "function",
        "label": "array_key_first( $array:array )",
        "apply": "array_key_first( $array:array )",
        "info": "Get the first key of the given array without affecting the internal array pointer."
    },
    "ƒ: array_key_last": {
        "type": "function",
        "label": "array_key_last( $array:array )",
        "apply": "array_key_last( $array:array )",
        "info": "Get the last key of the given array without affecting the internal array pointer."
    },
    "ƒ: array_values": {
        "type": "function",
        "label": "array_values( $array:array )",
        "apply": "array_values( $array:array )",
        "info": "array_values() returns all the values from the array and indexes the array numerically."
    },
    "ƒ: array_count_values": {
        "type": "function",
        "label": "array_count_values( $array:array )",
        "apply": "array_count_values( $array:array )",
        "info": "array_count_values() returns an array using the values of array (which must be ints or strings) as keys and their frequency in array as values."
    },
    "ƒ: array_column": {
        "type": "function",
        "label": "array_column( $array:array, $column_key:string|int|null, $index_key:string|int|null )",
        "apply": "array_column( $array:array, $column_key:string|int|null, $index_key:string|int|null )",
        "info": "array_column() returns the values from a single column of the array, identified by the column_key. Optionally, an index_key may be provided to index the values in the returned array by the values from the index_key column of the input array."
    },
    "ƒ: array_reverse": {
        "type": "function",
        "label": "array_reverse( $array:array, $preserve_keys:bool )",
        "apply": "array_reverse( $array:array, $preserve_keys:bool )",
        "info": "Takes an input array and returns a new array with the order of the elements reversed."
    },
    "ƒ: array_pad": {
        "type": "function",
        "label": "array_pad( $array:array, $length:int, $value:mixed )",
        "apply": "array_pad( $array:array, $length:int, $value:mixed )",
        "info": "array_pad() returns a copy of the array padded to size specified by length with value value. If length is positive then the array is padded on the right, if it's negative then on the left. If the absolute value of length is less than or equal to the length of the array then no padding takes place.It is possible to add at most 1048576 elements at a time."
    },
    "ƒ: array_flip": {
        "type": "function",
        "label": "array_flip( $array:array )",
        "apply": "array_flip( $array:array )",
        "info": "array_flip() returns an array in flip order, i.e. keys from array become values and values from array become keys."
    },
    "ƒ: array_change_key_case": {
        "type": "function",
        "label": "array_change_key_case( $array:array, $case:int )",
        "apply": "array_change_key_case( $array:array, $case:int )",
        "info": "Returns an array with all keys from array lowercased or uppercased. Numbered indices are left as is."
    },
    "ƒ: array_unique": {
        "type": "function",
        "label": "array_unique( $array:array, $flags:int )",
        "apply": "array_unique( $array:array, $flags:int )",
        "info": "Takes an input array and returns a new array without duplicate values."
    },
    "ƒ: array_intersect_key": {
        "type": "function",
        "label": "array_intersect_key( $array:array, $arrays:array )",
        "apply": "array_intersect_key( $array:array, $arrays:array )",
        "info": "array_intersect_key() returns an array containing all the entries of array which have keys that are present in all the arguments."
    },
    "ƒ: array_intersect_ukey": {
        "type": "function",
        "label": "array_intersect_ukey( $array:array, $rest: )",
        "apply": "array_intersect_ukey( $array:array, $rest: )",
        "info": "array_intersect_ukey() returns an array containing all the values of array which have matching keys that are present in all the arguments."
    },
    "ƒ: array_intersect": {
        "type": "function",
        "label": "array_intersect( $array:array, $arrays:array )",
        "apply": "array_intersect( $array:array, $arrays:array )",
        "info": "array_intersect() returns an array containing all the values of array that are present in all the arguments.Note that keys are preserved."
    },
    "ƒ: array_uintersect": {
        "type": "function",
        "label": "array_uintersect( $array:array, $rest: )",
        "apply": "array_uintersect( $array:array, $rest: )",
        "info": "Computes the intersection of arrays, compares data by a callback function."
    },
    "ƒ: array_intersect_assoc": {
        "type": "function",
        "label": "array_intersect_assoc( $array:array, $arrays:array )",
        "apply": "array_intersect_assoc( $array:array, $arrays:array )",
        "info": "array_intersect_assoc() returns an array containing all the values of array that are present in all the arguments. Note that the keys are also used in the comparison unlike in array_intersect()."
    },
    "ƒ: array_uintersect_assoc": {
        "type": "function",
        "label": "array_uintersect_assoc( $array:array, $rest: )",
        "apply": "array_uintersect_assoc( $array:array, $rest: )",
        "info": "Computes the intersection of arrays with additional index check, compares data by a callback function."
    },
    "ƒ: array_intersect_uassoc": {
        "type": "function",
        "label": "array_intersect_uassoc( $array:array, $rest: )",
        "apply": "array_intersect_uassoc( $array:array, $rest: )",
        "info": "array_intersect_uassoc() returns an array containing all the values of array that are present in all the arguments. Note that the keys are used in the comparison unlike in array_intersect()."
    },
    "ƒ: array_uintersect_uassoc": {
        "type": "function",
        "label": "array_uintersect_uassoc( $array:array, $rest: )",
        "apply": "array_uintersect_uassoc( $array:array, $rest: )",
        "info": "Computes the intersection of arrays with additional index check, compares data and indexes by separate callback functions."
    },
    "ƒ: array_diff_key": {
        "type": "function",
        "label": "array_diff_key( $array:array, $arrays:array )",
        "apply": "array_diff_key( $array:array, $arrays:array )",
        "info": "Compares the keys from array against the keys from arrays and returns the difference.This function is like array_diff() except the comparison is done on the keys instead of the values."
    },
    "ƒ: array_diff_ukey": {
        "type": "function",
        "label": "array_diff_ukey( $array:array, $rest: )",
        "apply": "array_diff_ukey( $array:array, $rest: )",
        "info": "Compares the keys from array against the keys from arrays and returns the difference.This function is like array_diff() except the comparison is done on the keys instead of the values."
    },
    "ƒ: array_diff": {
        "type": "function",
        "label": "array_diff( $array:array, $arrays:array )",
        "apply": "array_diff( $array:array, $arrays:array )",
        "info": "Compares array against one or more other arrays and returns the values in array that are not present in any of the other arrays."
    },
    "ƒ: array_udiff": {
        "type": "function",
        "label": "array_udiff( $array:array, $rest: )",
        "apply": "array_udiff( $array:array, $rest: )",
        "info": "Computes the difference of arrays by using a callback function for data comparison. This is unlike array_diff() which uses an internal function for comparing the data."
    },
    "ƒ: array_diff_assoc": {
        "type": "function",
        "label": "array_diff_assoc( $array:array, $arrays:array )",
        "apply": "array_diff_assoc( $array:array, $arrays:array )",
        "info": "Compares array against arrays and returns the difference. Unlike array_diff() the array keys are also used in the comparison."
    },
    "ƒ: array_diff_uassoc": {
        "type": "function",
        "label": "array_diff_uassoc( $array:array, $rest: )",
        "apply": "array_diff_uassoc( $array:array, $rest: )",
        "info": "Compares array against arrays and returns the difference. Unlike array_diff() the array keys are used in the comparison."
    },
    "ƒ: array_udiff_assoc": {
        "type": "function",
        "label": "array_udiff_assoc( $array:array, $rest: )",
        "apply": "array_udiff_assoc( $array:array, $rest: )",
        "info": "Computes the difference of arrays with additional index check, compares data by a callback function."
    },
    "ƒ: array_udiff_uassoc": {
        "type": "function",
        "label": "array_udiff_uassoc( $array:array, $rest: )",
        "apply": "array_udiff_uassoc( $array:array, $rest: )",
        "info": "Computes the difference of arrays with additional index check, compares data and indexes by a callback function."
    },
    "ƒ: array_multisort": {
        "type": "function",
        "label": "array_multisort( $array:, $rest: )",
        "apply": "array_multisort( $array:, $rest: )",
        "info": "array_multisort() can be used to sort several arrays at once, or a multi-dimensional array by one or more dimensions."
    },
    "ƒ: array_rand": {
        "type": "function",
        "label": "array_rand( $array:array, $num:int )",
        "apply": "array_rand( $array:array, $num:int )",
        "info": "Picks one or more random entries out of an array, and returns the key (or keys) of the random entries."
    },
    "ƒ: array_sum": {
        "type": "function",
        "label": "array_sum( $array:array )",
        "apply": "array_sum( $array:array )",
        "info": "array_sum() returns the sum of values in an array."
    },
    "ƒ: array_product": {
        "type": "function",
        "label": "array_product( $array:array )",
        "apply": "array_product( $array:array )",
        "info": "array_product() returns the product of values in an array."
    },
    "ƒ: array_reduce": {
        "type": "function",
        "label": "array_reduce( $array:array, $callback:callable, $initial:mixed )",
        "apply": "array_reduce( $array:array, $callback:callable, $initial:mixed )",
        "info": "array_reduce() applies iteratively the callback function to the elements of the array, so as to reduce the array to a single value."
    },
    "ƒ: array_filter": {
        "type": "function",
        "label": "array_filter( $array:array, $callback:?callable, $mode:int )",
        "apply": "array_filter( $array:array, $callback:?callable, $mode:int )",
        "info": "Iterates over each value in the array passing them to the callback function.If the callback function returns true, the current value from array is returned into the result array."
    },
    "ƒ: array_map": {
        "type": "function",
        "label": "array_map( $callback:?callable, $array:array, $arrays:array )",
        "apply": "array_map( $callback:?callable, $array:array, $arrays:array )",
        "info": "array_map() returns an array containing the results of applying the callback to the corresponding value of array (and arrays if more arrays are provided)used as arguments for the callback.The number of parameters that the callback function accepts should match the number of arrays passed to array_map(). Excess input arrays are ignored. An ArgumentCountError is thrown if an insufficient number of arguments is provided."
    },
    "ƒ: array_key_exists": {
        "type": "function",
        "label": "array_key_exists( $key:, $array:array )",
        "apply": "array_key_exists( $key:, $array:array )",
        "info": "array_key_exists() returns true if the given key is set in the array.key can be any value possible for an array index."
    },
    "ƒ: key_exists": {
        "type": "function",
        "label": "key_exists( $key:, $array:array )",
        "apply": "key_exists( $key:, $array:array )",
        "info": "This function is an alias of: array_key_exists()."
    },
    "ƒ: array_chunk": {
        "type": "function",
        "label": "array_chunk( $array:array, $length:int, $preserve_keys:bool )",
        "apply": "array_chunk( $array:array, $length:int, $preserve_keys:bool )",
        "info": "Chunks an array into arrays with length elements.The last chunk may contain less than length elements."
    },
    "ƒ: array_combine": {
        "type": "function",
        "label": "array_combine( $keys:array, $values:array )",
        "apply": "array_combine( $keys:array, $values:array )",
        "info": "Creates an array by using the values from the keys array as keys and the values from the values array as the corresponding values."
    },
    "ƒ: array_is_list": {
        "type": "function",
        "label": "array_is_list( $array:array )",
        "apply": "array_is_list( $array:array )",
        "info": "Determines if the given array is a list.An array is considered a list if its keys consist of consecutive numbers from 0 to count($array)-1."
    },
    "ƒ: base64_encode": {
        "type": "function",
        "label": "base64_encode( $string:string )",
        "apply": "base64_encode( $string:string )",
        "info": "Encodes the given string with base64."
    },
    "ƒ: base64_decode": {
        "type": "function",
        "label": "base64_decode( $string:string, $strict:bool )",
        "apply": "base64_decode( $string:string, $strict:bool )",
        "info": "Decodes a base64 encoded string."
    },
    "ƒ: constant": {
        "type": "function",
        "label": "constant( $name:string )",
        "apply": "constant( $name:string )",
        "info": "Return the value of the constant indicated by name."
    },
    "ƒ: ip2long": {
        "type": "function",
        "label": "ip2long( $ip:string )",
        "apply": "ip2long( $ip:string )",
        "info": "The function ip2long() generates a long integer representation of IPv4 Internet network address from its Internet standard format (dotted string) representation. "
    },
    "ƒ: long2ip": {
        "type": "function",
        "label": "long2ip( $ip:int )",
        "apply": "long2ip( $ip:int )",
        "info": "The function long2ip() generates an Internet address in dotted format (i.e.: aaa.bbb.ccc.ddd) from the long integer representation."
    },
    "ƒ: getenv": {
        "type": "function",
        "label": "getenv( $name:?string, $local_only:bool )",
        "apply": "getenv( $name:?string, $local_only:bool )",
        "info": "Gets the value of an environment variable."
    },
    "ƒ: putenv": {
        "type": "function",
        "label": "putenv( $assignment:string )",
        "apply": "putenv( $assignment:string )",
        "info": "Adds assignment to the server environment.  The environment variable will only exist for the duration of the current request. At the end of the request the environment is restored to its original state."
    },
    "ƒ: getopt": {
        "type": "function",
        "label": "getopt( $short_options:string, $long_options:array, $rest_index: )",
        "apply": "getopt( $short_options:string, $long_options:array, $rest_index: )",
        "info": "Parses options passed to the script."
    },
    "ƒ: flush": {
        "type": "function",
        "label": "flush()",
        "apply": "flush()",
        "info": "Flushes the system write buffers of PHP and whatever backend PHP is using (CGI,a web server, etc).  This attempts to push current output all the way to the browser with a few caveats."
    },
    "ƒ: sleep": {
        "type": "function",
        "label": "sleep( $seconds:int )",
        "apply": "sleep( $seconds:int )",
        "info": "Delays the program execution for the given number of seconds."
    },
    "ƒ: usleep": {
        "type": "function",
        "label": "usleep( $microseconds:int )",
        "apply": "usleep( $microseconds:int )",
        "info": "Delays program execution for the given number of microseconds."
    },
    "ƒ: time_nanosleep": {
        "type": "function",
        "label": "time_nanosleep( $seconds:int, $nanoseconds:int )",
        "apply": "time_nanosleep( $seconds:int, $nanoseconds:int )",
        "info": "Delays program execution for the given number of seconds and nanoseconds."
    },
    "ƒ: time_sleep_until": {
        "type": "function",
        "label": "time_sleep_until( $timestamp:float )",
        "apply": "time_sleep_until( $timestamp:float )",
        "info": "Makes the script sleep until the specified timestamp. "
    },
    "ƒ: get_current_user": {
        "type": "function",
        "label": "get_current_user()",
        "apply": "get_current_user()",
        "info": "Returns the name of the owner of the current PHP script."
    },
    "ƒ: get_cfg_var": {
        "type": "function",
        "label": "get_cfg_var( $option:string )",
        "apply": "get_cfg_var( $option:string )",
        "info": "Gets the value of a PHP configuration option."
    },
    "ƒ: error_log": {
        "type": "function",
        "label": "error_log( $message:string, $message_type:int, $destination:?string, $additional_headers:?string )",
        "apply": "error_log( $message:string, $message_type:int, $destination:?string, $additional_headers:?string )",
        "info": "Sends an error message to the web server's error log or to a file."
    },
    "ƒ: error_get_last": {
        "type": "function",
        "label": "error_get_last()",
        "apply": "error_get_last()",
        "info": "Gets information about the last error that occurred."
    },
    "ƒ: error_clear_last": {
        "type": "function",
        "label": "error_clear_last()",
        "apply": "error_clear_last()",
        "info": ""
    },
    "ƒ: call_user_func": {
        "type": "function",
        "label": "call_user_func( $callback:callable, $args:mixed )",
        "apply": "call_user_func( $callback:callable, $args:mixed )",
        "info": "Calls the callback given by the first parameter and passes the remaining parameters as arguments."
    },
    "ƒ: call_user_func_array": {
        "type": "function",
        "label": "call_user_func_array( $callback:callable, $args:array )",
        "apply": "call_user_func_array( $callback:callable, $args:array )",
        "info": "Calls the callback given by the first parameter with the parameters in args."
    },
    "ƒ: forward_static_call": {
        "type": "function",
        "label": "forward_static_call( $callback:callable, $args:mixed )",
        "apply": "forward_static_call( $callback:callable, $args:mixed )",
        "info": "Calls a user defined function or method given by the callback parameter, with the following arguments. This function must be called within a method context, it can't be used outside a class.It uses the late static binding."
    },
    "ƒ: forward_static_call_array": {
        "type": "function",
        "label": "forward_static_call_array( $callback:callable, $args:array )",
        "apply": "forward_static_call_array( $callback:callable, $args:array )",
        "info": "Calls a user defined function or method given by the callback parameter. This function must be called within a method context, it can't be used outside a class.It uses the late static binding.All arguments of the forwarded method are passed as values,and as an array, similarly to call_user_func_array()."
    },
    "ƒ: register_shutdown_function": {
        "type": "function",
        "label": "register_shutdown_function( $callback:callable, $args:mixed )",
        "apply": "register_shutdown_function( $callback:callable, $args:mixed )",
        "info": "Registers a callback to be executed after script execution finishes or exit() is called."
    },
    "ƒ: highlight_file": {
        "type": "function",
        "label": "highlight_file( $filename:string, $return:bool )",
        "apply": "highlight_file( $filename:string, $return:bool )",
        "info": "Prints out or returns a syntax highlighted version of the code contained in filename using the colors defined in the built-in syntax highlighter for PHP."
    },
    "ƒ: show_source": {
        "type": "function",
        "label": "show_source( $filename:string, $return:bool )",
        "apply": "show_source( $filename:string, $return:bool )",
        "info": "This function is an alias of: highlight_file()."
    },
    "ƒ: php_strip_whitespace": {
        "type": "function",
        "label": "php_strip_whitespace( $filename:string )",
        "apply": "php_strip_whitespace( $filename:string )",
        "info": "Returns the PHP source code in filename with PHP comments and whitespace removed. This may be useful for determining the amount of actual code in your scripts compared with the amount of comments.This is similar to using php -w from the commandline."
    },
    "ƒ: highlight_string": {
        "type": "function",
        "label": "highlight_string( $string:string, $return:bool )",
        "apply": "highlight_string( $string:string, $return:bool )",
        "info": "Outputs or returns html markup for a syntax highlighted version of the given PHP code using the colors defined in the built-in syntax highlighter for PHP."
    },
    "ƒ: ini_get": {
        "type": "function",
        "label": "ini_get( $option:string )",
        "apply": "ini_get( $option:string )",
        "info": "Returns the value of the configuration option on success."
    },
    "ƒ: ini_get_all": {
        "type": "function",
        "label": "ini_get_all( $extension:?string, $details:bool )",
        "apply": "ini_get_all( $extension:?string, $details:bool )",
        "info": "Returns all the registered configuration options. "
    },
    "ƒ: ini_set": {
        "type": "function",
        "label": "ini_set( $option:string, $value:string|int|float|bool|null )",
        "apply": "ini_set( $option:string, $value:string|int|float|bool|null )",
        "info": "Sets the value of the given configuration option.  The configuration option will keep this new value during the script's execution, and will be restored at the script's ending."
    },
    "ƒ: ini_alter": {
        "type": "function",
        "label": "ini_alter( $option:string, $value:string|int|float|bool|null )",
        "apply": "ini_alter( $option:string, $value:string|int|float|bool|null )",
        "info": "This function is an alias of:  ini_set()."
    },
    "ƒ: ini_restore": {
        "type": "function",
        "label": "ini_restore( $option:string )",
        "apply": "ini_restore( $option:string )",
        "info": "Restores a given configuration option to its original value."
    },
    "ƒ: set_include_path": {
        "type": "function",
        "label": "set_include_path( $include_path:string )",
        "apply": "set_include_path( $include_path:string )",
        "info": "Sets the include_path configuration option for the duration of the script.  "
    },
    "ƒ: get_include_path": {
        "type": "function",
        "label": "get_include_path()",
        "apply": "get_include_path()",
        "info": "Gets the current include_path configuration option value."
    },
    "ƒ: print_r": {
        "type": "function",
        "label": "print_r( $value:mixed, $return:bool )",
        "apply": "print_r( $value:mixed, $return:bool )",
        "info": "print_r() displays information about a variable in a way that's readable by humans.  "
    },
    "ƒ: connection_aborted": {
        "type": "function",
        "label": "connection_aborted()",
        "apply": "connection_aborted()",
        "info": "Checks whether the client disconnected."
    },
    "ƒ: connection_status": {
        "type": "function",
        "label": "connection_status()",
        "apply": "connection_status()",
        "info": "Gets the connection status bitfield.  "
    },
    "ƒ: ignore_user_abort": {
        "type": "function",
        "label": "ignore_user_abort( $enable:?bool )",
        "apply": "ignore_user_abort( $enable:?bool )",
        "info": "Sets whether a client disconnect should cause a script to be aborted."
    },
    "ƒ: getservbyname": {
        "type": "function",
        "label": "getservbyname( $service:string, $protocol:string )",
        "apply": "getservbyname( $service:string, $protocol:string )",
        "info": "getservbyname() returns the Internet port which corresponds to service for the specified protocol as per \/etc\/services."
    },
    "ƒ: getservbyport": {
        "type": "function",
        "label": "getservbyport( $port:int, $protocol:string )",
        "apply": "getservbyport( $port:int, $protocol:string )",
        "info": "getservbyport() returns the Internet service associated with port for the specified protocol as per \/etc\/services."
    },
    "ƒ: getprotobyname": {
        "type": "function",
        "label": "getprotobyname( $protocol:string )",
        "apply": "getprotobyname( $protocol:string )",
        "info": "getprotobyname() returns the protocol number associated with the protocol protocol as per \/etc\/protocols."
    },
    "ƒ: getprotobynumber": {
        "type": "function",
        "label": "getprotobynumber( $protocol:int )",
        "apply": "getprotobynumber( $protocol:int )",
        "info": "getprotobynumber() returns the protocol name associated with protocol protocol as per \/etc\/protocols."
    },
    "ƒ: register_tick_function": {
        "type": "function",
        "label": "register_tick_function( $callback:callable, $args:mixed )",
        "apply": "register_tick_function( $callback:callable, $args:mixed )",
        "info": "Registers the given callback to be executed when a tick is called."
    },
    "ƒ: unregister_tick_function": {
        "type": "function",
        "label": "unregister_tick_function( $callback:callable )",
        "apply": "unregister_tick_function( $callback:callable )",
        "info": "De-registers the function function so it is no longer executed when a tick is called."
    },
    "ƒ: is_uploaded_file": {
        "type": "function",
        "label": "is_uploaded_file( $filename:string )",
        "apply": "is_uploaded_file( $filename:string )",
        "info": "Returns true if the file named by filename was uploaded via HTTP POST. This is useful to help ensure that a malicious user hasn't tried to trick the script into working on files upon which it should not be working--for instance,\/etc\/passwd."
    },
    "ƒ: move_uploaded_file": {
        "type": "function",
        "label": "move_uploaded_file( $from:string, $to:string )",
        "apply": "move_uploaded_file( $from:string, $to:string )",
        "info": "This function checks to ensure that the file designated by from is a valid upload file (meaning that it was uploaded via PHP's HTTP POST upload mechanism). If the file is valid, it will be moved to the filename given by to."
    },
    "ƒ: parse_ini_file": {
        "type": "function",
        "label": "parse_ini_file( $filename:string, $process_sections:bool, $scanner_mode:int )",
        "apply": "parse_ini_file( $filename:string, $process_sections:bool, $scanner_mode:int )",
        "info": "parse_ini_file() loads in the ini file specified in filename,and returns the settings in it in an associative array."
    },
    "ƒ: parse_ini_string": {
        "type": "function",
        "label": "parse_ini_string( $ini_string:string, $process_sections:bool, $scanner_mode:int )",
        "apply": "parse_ini_string( $ini_string:string, $process_sections:bool, $scanner_mode:int )",
        "info": "parse_ini_string() returns the settings in string ini_string in an associative array."
    },
    "ƒ: sys_getloadavg": {
        "type": "function",
        "label": "sys_getloadavg()",
        "apply": "sys_getloadavg()",
        "info": "Returns three samples representing the average system load (the number of processes in the system run queue) over the last 1, 5 and 15 minutes, respectively. Returns false on failure."
    },
    "ƒ: get_browser": {
        "type": "function",
        "label": "get_browser( $user_agent:?string, $return_array:bool )",
        "apply": "get_browser( $user_agent:?string, $return_array:bool )",
        "info": "Attempts to determine the capabilities of the user's browser, by looking up the browser's information in the browscap.ini file."
    },
    "ƒ: crc32": {
        "type": "function",
        "label": "crc32( $string:string )",
        "apply": "crc32( $string:string )",
        "info": "Generates the cyclic redundancy checksum polynomial of 32-bit lengths of the string. This is usually used to validate the integrity of data being transmitted."
    },
    "ƒ: crypt": {
        "type": "function",
        "label": "crypt( $string:string, $salt:string )",
        "apply": "crypt( $string:string, $salt:string )",
        "info": "crypt() will return a hashed string using the standard Unix DES-based algorithm or alternative algorithms. password_verify() is compatible with crypt(). Therefore, password hashes created by crypt() can be used with password_verify()."
    },
    "ƒ: strptime": {
        "type": "function",
        "label": "strptime( $timestamp:string, $format:string )",
        "apply": "strptime( $timestamp:string, $format:string )",
        "info": "strptime() returns an array with the timestamp parsed, or false on error."
    },
    "ƒ: gethostname": {
        "type": "function",
        "label": "gethostname()",
        "apply": "gethostname()",
        "info": "gethostname() gets the standard host name for the local machine."
    },
    "ƒ: gethostbyaddr": {
        "type": "function",
        "label": "gethostbyaddr( $ip:string )",
        "apply": "gethostbyaddr( $ip:string )",
        "info": "Returns the host name of the Internet host specified by ip."
    },
    "ƒ: gethostbyname": {
        "type": "function",
        "label": "gethostbyname( $hostname:string )",
        "apply": "gethostbyname( $hostname:string )",
        "info": "Returns the IPv4 address of the Internet host specified by hostname."
    },
    "ƒ: gethostbynamel": {
        "type": "function",
        "label": "gethostbynamel( $hostname:string )",
        "apply": "gethostbynamel( $hostname:string )",
        "info": "Returns a list of IPv4 addresses to which the Internet host specified by hostname resolves. "
    },
    "ƒ: dns_check_record": {
        "type": "function",
        "label": "dns_check_record( $hostname:string, $type:string )",
        "apply": "dns_check_record( $hostname:string, $type:string )",
        "info": "This function is an alias of: checkdnsrr()."
    },
    "ƒ: checkdnsrr": {
        "type": "function",
        "label": "checkdnsrr( $hostname:string, $type:string )",
        "apply": "checkdnsrr( $hostname:string, $type:string )",
        "info": "Searches DNS for records of type type corresponding to hostname. "
    },
    "ƒ: dns_get_record": {
        "type": "function",
        "label": "dns_get_record( $hostname:string, $type:int, $authoritative_name_servers:, $additional_records:, $raw:bool )",
        "apply": "dns_get_record( $hostname:string, $type:int, $authoritative_name_servers:, $additional_records:, $raw:bool )",
        "info": "Fetch DNS Resource Records associated with the given hostname."
    },
    "ƒ: dns_get_mx": {
        "type": "function",
        "label": "dns_get_mx( $hostname:string, $hosts:, $weights: )",
        "apply": "dns_get_mx( $hostname:string, $hosts:, $weights: )",
        "info": "This function is an alias of: getmxrr()."
    },
    "ƒ: getmxrr": {
        "type": "function",
        "label": "getmxrr( $hostname:string, $hosts:, $weights: )",
        "apply": "getmxrr( $hostname:string, $hosts:, $weights: )",
        "info": "Searches DNS for MX records corresponding to hostname. "
    },
    "ƒ: net_get_interfaces": {
        "type": "function",
        "label": "net_get_interfaces()",
        "apply": "net_get_interfaces()",
        "info": "Returns an enumeration of network interfaces (adapters) on the local machine."
    },
    "ƒ: ftok": {
        "type": "function",
        "label": "ftok( $filename:string, $project_id:string )",
        "apply": "ftok( $filename:string, $project_id:string )",
        "info": "The function converts the filename of an existing accessible file and a project identifier into an integer for use with for example shmop_open() and other System V IPC keys. "
    },
    "ƒ: hrtime": {
        "type": "function",
        "label": "hrtime( $as_number:bool )",
        "apply": "hrtime( $as_number:bool )",
        "info": "Returns the system's high resolution time, counted from an arbitrary point in time.The delivered timestamp is monotonic and can not be adjusted."
    },
    "ƒ: lcg_value": {
        "type": "function",
        "label": "lcg_value()",
        "apply": "lcg_value()",
        "info": "lcg_value() returns a pseudo random number in the range of (0, 1).  The function combines two CGs with periods of 2^31 - 85 and 2^31 - 249. The period of this function is equal to the product of both primes."
    },
    "ƒ: md5": {
        "type": "function",
        "label": "md5( $string:string, $binary:bool )",
        "apply": "md5( $string:string, $binary:bool )",
        "info": "Calculates the MD5 hash of string using the \u00bb\u00a0RSA Data Security, Inc.MD5 Message-Digest Algorithm, and returns that hash."
    },
    "ƒ: md5_file": {
        "type": "function",
        "label": "md5_file( $filename:string, $binary:bool )",
        "apply": "md5_file( $filename:string, $binary:bool )",
        "info": "Calculates the MD5 hash of the file specified by the filename parameter using the \u00bb\u00a0RSA Data Security, Inc. MD5 Message-Digest Algorithm, and returns that hash.The hash is a 32-character hexadecimal number."
    },
    "ƒ: getmyuid": {
        "type": "function",
        "label": "getmyuid()",
        "apply": "getmyuid()",
        "info": "Gets the user ID of the current script."
    },
    "ƒ: getmygid": {
        "type": "function",
        "label": "getmygid()",
        "apply": "getmygid()",
        "info": "Gets the group ID of the current script."
    },
    "ƒ: getmypid": {
        "type": "function",
        "label": "getmypid()",
        "apply": "getmypid()",
        "info": "Gets the current PHP process ID."
    },
    "ƒ: getmyinode": {
        "type": "function",
        "label": "getmyinode()",
        "apply": "getmyinode()",
        "info": "Gets the inode of the current script."
    },
    "ƒ: getlastmod": {
        "type": "function",
        "label": "getlastmod()",
        "apply": "getlastmod()",
        "info": "Gets the time of the last modification of the main script of execution."
    },
    "ƒ: sha1": {
        "type": "function",
        "label": "sha1( $string:string, $binary:bool )",
        "apply": "sha1( $string:string, $binary:bool )",
        "info": "Calculates the sha1 hash of string using the \u00bb\u00a0US Secure Hash Algorithm 1."
    },
    "ƒ: sha1_file": {
        "type": "function",
        "label": "sha1_file( $filename:string, $binary:bool )",
        "apply": "sha1_file( $filename:string, $binary:bool )",
        "info": "Calculates the sha1 hash of the file specified by filename using the \u00bb\u00a0US Secure Hash Algorithm 1,and returns that hash. The hash is a 40-character hexadecimal number."
    },
    "ƒ: openlog": {
        "type": "function",
        "label": "openlog( $prefix:string, $flags:int, $facility:int )",
        "apply": "openlog( $prefix:string, $flags:int, $facility:int )",
        "info": "openlog() opens a connection to the system logger for a program.  "
    },
    "ƒ: closelog": {
        "type": "function",
        "label": "closelog()",
        "apply": "closelog()",
        "info": "closelog() closes the descriptor being used to write to the system logger.  The use of closelog() is optional."
    },
    "ƒ: syslog": {
        "type": "function",
        "label": "syslog( $priority:int, $message:string )",
        "apply": "syslog( $priority:int, $message:string )",
        "info": "syslog() generates a log message that will be distributed by the system logger."
    },
    "ƒ: inet_ntop": {
        "type": "function",
        "label": "inet_ntop( $ip:string )",
        "apply": "inet_ntop( $ip:string )",
        "info": "This function converts a 32bit IPv4, or 128bit IPv6 address (if PHP was built with IPv6 support enabled) into an address family appropriate string representation.  "
    },
    "ƒ: inet_pton": {
        "type": "function",
        "label": "inet_pton( $ip:string )",
        "apply": "inet_pton( $ip:string )",
        "info": "This function converts a human readable IPv4 or IPv6 address (if PHP was built with IPv6 support enabled) into an address family appropriate 32bit or 128bit binary structure."
    },
    "ƒ: metaphone": {
        "type": "function",
        "label": "metaphone( $string:string, $max_phonemes:int )",
        "apply": "metaphone( $string:string, $max_phonemes:int )",
        "info": "Calculates the metaphone key of string."
    },
    "ƒ: header": {
        "type": "function",
        "label": "header( $header:string, $replace:bool, $response_code:int )",
        "apply": "header( $header:string, $replace:bool, $response_code:int )",
        "info": "header() is used to send a raw HTTP header. See the \u00bb\u00a0HTTP\/1.1 specification for more information on HTTP headers."
    },
    "ƒ: header_remove": {
        "type": "function",
        "label": "header_remove( $name:?string )",
        "apply": "header_remove( $name:?string )",
        "info": "Removes an HTTP header previously set using header()."
    },
    "ƒ: setrawcookie": {
        "type": "function",
        "label": "setrawcookie( $name:string, $value:string, $expires_or_options:array|int, $path:string, $domain:string, $secure:bool, $httponly:bool )",
        "apply": "setrawcookie( $name:string, $value:string, $expires_or_options:array|int, $path:string, $domain:string, $secure:bool, $httponly:bool )",
        "info": "Alternative signature available as of PHP 7.3.0 (not supported with named parameters):"
    },
    "ƒ: setcookie": {
        "type": "function",
        "label": "setcookie( $name:string, $value:string, $expires_or_options:array|int, $path:string, $domain:string, $secure:bool, $httponly:bool )",
        "apply": "setcookie( $name:string, $value:string, $expires_or_options:array|int, $path:string, $domain:string, $secure:bool, $httponly:bool )",
        "info": "Alternative signature available as of PHP 7.3.0 (not supported with named parameters):"
    },
    "ƒ: http_response_code": {
        "type": "function",
        "label": "http_response_code( $response_code:int )",
        "apply": "http_response_code( $response_code:int )",
        "info": "Gets or sets the HTTP response status code."
    },
    "ƒ: headers_sent": {
        "type": "function",
        "label": "headers_sent( $filename:, $line: )",
        "apply": "headers_sent( $filename:, $line: )",
        "info": "Checks if or where headers have been sent."
    },
    "ƒ: headers_list": {
        "type": "function",
        "label": "headers_list()",
        "apply": "headers_list()",
        "info": "headers_list() will return a list of headers to be sent to the browser \/ client.  To determine whether or not these headers have been sent yet, use headers_sent()."
    },
    "ƒ: htmlspecialchars": {
        "type": "function",
        "label": "htmlspecialchars( $string:string, $flags:int, $encoding:?string, $double_encode:bool )",
        "apply": "htmlspecialchars( $string:string, $flags:int, $encoding:?string, $double_encode:bool )",
        "info": "Certain characters have special significance in HTML, and should be represented by HTML entities if they are to preserve their meanings. This function returns a string with these conversions made. If you require all input substrings that have associated named entities to be translated, use htmlentities()instead."
    },
    "ƒ: htmlspecialchars_decode": {
        "type": "function",
        "label": "htmlspecialchars_decode( $string:string, $flags:int )",
        "apply": "htmlspecialchars_decode( $string:string, $flags:int )",
        "info": "This function is the opposite of htmlspecialchars(). It converts special HTML entities back to characters."
    },
    "ƒ: html_entity_decode": {
        "type": "function",
        "label": "html_entity_decode( $string:string, $flags:int, $encoding:?string )",
        "apply": "html_entity_decode( $string:string, $flags:int, $encoding:?string )",
        "info": "html_entity_decode() is the opposite of htmlentities() in that it converts HTML entities in the string to their corresponding characters."
    },
    "ƒ: htmlentities": {
        "type": "function",
        "label": "htmlentities( $string:string, $flags:int, $encoding:?string, $double_encode:bool )",
        "apply": "htmlentities( $string:string, $flags:int, $encoding:?string, $double_encode:bool )",
        "info": "This function is identical to htmlspecialchars() in all ways, except with htmlentities(), all characters which have HTML character entity equivalents are translated into these entities.The get_html_translation_table() function can be used to return the translation table used dependent upon the provided flags constants."
    },
    "ƒ: get_html_translation_table": {
        "type": "function",
        "label": "get_html_translation_table( $table:int, $flags:int, $encoding:string )",
        "apply": "get_html_translation_table( $table:int, $flags:int, $encoding:string )",
        "info": "get_html_translation_table() will return the translation table that is used internally for htmlspecialchars() and htmlentities()."
    },
    "ƒ: assert": {
        "type": "function",
        "label": "assert( $assertion:mixed, $description:Throwable|string|null )",
        "apply": "assert( $assertion:mixed, $description:Throwable|string|null )",
        "info": "PHP 5 and 7"
    },
    "ƒ: assert_options": {
        "type": "function",
        "label": "assert_options( $option:int, $value:mixed )",
        "apply": "assert_options( $option:int, $value:mixed )",
        "info": "Set the various assert() control options or just query their current settings."
    },
    "ƒ: bin2hex": {
        "type": "function",
        "label": "bin2hex( $string:string )",
        "apply": "bin2hex( $string:string )",
        "info": "Returns an ASCII string containing the hexadecimal representation of string. The conversion is done byte-wise with the high-nibble first."
    },
    "ƒ: hex2bin": {
        "type": "function",
        "label": "hex2bin( $string:string )",
        "apply": "hex2bin( $string:string )",
        "info": "Decodes a hexadecimally encoded binary string."
    },
    "ƒ: strspn": {
        "type": "function",
        "label": "strspn( $string:string, $characters:string, $offset:int, $length:?int )",
        "apply": "strspn( $string:string, $characters:string, $offset:int, $length:?int )",
        "info": "Finds the length of the initial segment of string that contains only characters from characters."
    },
    "ƒ: strcspn": {
        "type": "function",
        "label": "strcspn( $string:string, $characters:string, $offset:int, $length:?int )",
        "apply": "strcspn( $string:string, $characters:string, $offset:int, $length:?int )",
        "info": "Returns the length of the initial segment of string which does not contain any of the characters in characters."
    },
    "ƒ: nl_langinfo": {
        "type": "function",
        "label": "nl_langinfo( $item:int )",
        "apply": "nl_langinfo( $item:int )",
        "info": "nl_langinfo() is used to access individual elements of the locale categories.  Unlike localeconv(), which returns all of the elements, nl_langinfo() allows you to select any specific element."
    },
    "ƒ: strcoll": {
        "type": "function",
        "label": "strcoll( $string1:string, $string2:string )",
        "apply": "strcoll( $string1:string, $string2:string )",
        "info": "Note that this comparison is case sensitive, and unlike strcmp() this function is not binary safe."
    },
    "ƒ: trim": {
        "type": "function",
        "label": "trim( $string:string, $characters:string )",
        "apply": "trim( $string:string, $characters:string )",
        "info": "This function returns a string with whitespace stripped from the beginning and end of string.Without the second parameter,trim() will strip these characters:"
    },
    "ƒ: rtrim": {
        "type": "function",
        "label": "rtrim( $string:string, $characters:string )",
        "apply": "rtrim( $string:string, $characters:string )",
        "info": "This function returns a string with whitespace (or other characters) stripped from the end of string."
    },
    "ƒ: chop": {
        "type": "function",
        "label": "chop( $string:string, $characters:string )",
        "apply": "chop( $string:string, $characters:string )",
        "info": "This function is an alias of: rtrim()."
    },
    "ƒ: ltrim": {
        "type": "function",
        "label": "ltrim( $string:string, $characters:string )",
        "apply": "ltrim( $string:string, $characters:string )",
        "info": "Strip whitespace (or other characters) from the beginning of a string."
    },
    "ƒ: wordwrap": {
        "type": "function",
        "label": "wordwrap( $string:string, $width:int, $break:string, $cut_long_words:bool )",
        "apply": "wordwrap( $string:string, $width:int, $break:string, $cut_long_words:bool )",
        "info": "Wraps a string to a given number of characters using a string break character."
    },
    "ƒ: explode": {
        "type": "function",
        "label": "explode( $separator:string, $string:string, $limit:int )",
        "apply": "explode( $separator:string, $string:string, $limit:int )",
        "info": "Returns an array of strings, each of which is a substring of string formed by splitting it on boundaries formed by the string separator."
    },
    "ƒ: implode": {
        "type": "function",
        "label": "implode( $separator:array|string, $array:?array )",
        "apply": "implode( $separator:array|string, $array:?array )",
        "info": "Alternative signature (not supported with named arguments):"
    },
    "ƒ: join": {
        "type": "function",
        "label": "join( $separator:array|string, $array:?array )",
        "apply": "join( $separator:array|string, $array:?array )",
        "info": "This function is an alias of: implode()."
    },
    "ƒ: strtok": {
        "type": "function",
        "label": "strtok( $string:string, $token:?string )",
        "apply": "strtok( $string:string, $token:?string )",
        "info": "Alternative signature (not supported with named arguments):"
    },
    "ƒ: strtoupper": {
        "type": "function",
        "label": "strtoupper( $string:string )",
        "apply": "strtoupper( $string:string )",
        "info": "Returns string with all ASCII alphabetic characters converted to uppercase."
    },
    "ƒ: strtolower": {
        "type": "function",
        "label": "strtolower( $string:string )",
        "apply": "strtolower( $string:string )",
        "info": "Returns string with all ASCII alphabetic characters converted to lowercase."
    },
    "ƒ: basename": {
        "type": "function",
        "label": "basename( $path:string, $suffix:string )",
        "apply": "basename( $path:string, $suffix:string )",
        "info": "Given a string containing the path to a file or directory, this function will return the trailing name component."
    },
    "ƒ: dirname": {
        "type": "function",
        "label": "dirname( $path:string, $levels:int )",
        "apply": "dirname( $path:string, $levels:int )",
        "info": "Given a string containing the path of a file or directory, this function will return the parent directory's path that is levels up from the current directory."
    },
    "ƒ: pathinfo": {
        "type": "function",
        "label": "pathinfo( $path:string, $flags:int )",
        "apply": "pathinfo( $path:string, $flags:int )",
        "info": "pathinfo() returns information about path: either an associative array or a string,depending on flags."
    },
    "ƒ: stristr": {
        "type": "function",
        "label": "stristr( $haystack:string, $needle:string, $before_needle:bool )",
        "apply": "stristr( $haystack:string, $needle:string, $before_needle:bool )",
        "info": "Returns all of haystack starting from and including the first occurrence of needle to the end."
    },
    "ƒ: strstr": {
        "type": "function",
        "label": "strstr( $haystack:string, $needle:string, $before_needle:bool )",
        "apply": "strstr( $haystack:string, $needle:string, $before_needle:bool )",
        "info": "Returns part of haystack string starting from and including the first occurrence of needle to the end of haystack."
    },
    "ƒ: strchr": {
        "type": "function",
        "label": "strchr( $haystack:string, $needle:string, $before_needle:bool )",
        "apply": "strchr( $haystack:string, $needle:string, $before_needle:bool )",
        "info": "This function is an alias of: strstr()."
    },
    "ƒ: strpos": {
        "type": "function",
        "label": "strpos( $haystack:string, $needle:string, $offset:int )",
        "apply": "strpos( $haystack:string, $needle:string, $offset:int )",
        "info": "Find the numeric position of the first occurrence of needle in the haystack string."
    },
    "ƒ: stripos": {
        "type": "function",
        "label": "stripos( $haystack:string, $needle:string, $offset:int )",
        "apply": "stripos( $haystack:string, $needle:string, $offset:int )",
        "info": "Find the numeric position of the first occurrence of needle in the haystack string."
    },
    "ƒ: strrpos": {
        "type": "function",
        "label": "strrpos( $haystack:string, $needle:string, $offset:int )",
        "apply": "strrpos( $haystack:string, $needle:string, $offset:int )",
        "info": "Find the numeric position of the last occurrence of needle in the haystack string."
    },
    "ƒ: strripos": {
        "type": "function",
        "label": "strripos( $haystack:string, $needle:string, $offset:int )",
        "apply": "strripos( $haystack:string, $needle:string, $offset:int )",
        "info": "Find the numeric position of the last occurrence of needle in the haystack string."
    },
    "ƒ: strrchr": {
        "type": "function",
        "label": "strrchr( $haystack:string, $needle:string )",
        "apply": "strrchr( $haystack:string, $needle:string )",
        "info": "This function returns the portion of haystack which starts at the last occurrence of needle and goes until the end of haystack."
    },
    "ƒ: str_contains": {
        "type": "function",
        "label": "str_contains( $haystack:string, $needle:string )",
        "apply": "str_contains( $haystack:string, $needle:string )",
        "info": "Performs a case-sensitive check indicating if needle is contained in haystack."
    },
    "ƒ: str_starts_with": {
        "type": "function",
        "label": "str_starts_with( $haystack:string, $needle:string )",
        "apply": "str_starts_with( $haystack:string, $needle:string )",
        "info": "Performs a case-sensitive check indicating if haystack begins with needle."
    },
    "ƒ: str_ends_with": {
        "type": "function",
        "label": "str_ends_with( $haystack:string, $needle:string )",
        "apply": "str_ends_with( $haystack:string, $needle:string )",
        "info": "Performs a case-sensitive check indicating if haystack ends with needle."
    },
    "ƒ: chunk_split": {
        "type": "function",
        "label": "chunk_split( $string:string, $length:int, $separator:string )",
        "apply": "chunk_split( $string:string, $length:int, $separator:string )",
        "info": "Can be used to split a string into smaller chunks which is useful for e.g. converting base64_encode() output to match RFC 2045 semantics. It inserts separator every length characters."
    },
    "ƒ: substr": {
        "type": "function",
        "label": "substr( $string:string, $offset:int, $length:?int )",
        "apply": "substr( $string:string, $offset:int, $length:?int )",
        "info": "Returns the portion of string specified by the offset and length parameters."
    },
    "ƒ: substr_replace": {
        "type": "function",
        "label": "substr_replace( $string:array|string, $replace:array|string, $offset:array|int, $length:array|int|null )",
        "apply": "substr_replace( $string:array|string, $replace:array|string, $offset:array|int, $length:array|int|null )",
        "info": "substr_replace() replaces a copy of string delimited by the offset and (optionally)length parameters with the string given in replace. "
    },
    "ƒ: quotemeta": {
        "type": "function",
        "label": "quotemeta( $string:string )",
        "apply": "quotemeta( $string:string )",
        "info": "Returns a version of str with a backslash character (\\)before every character that is among these: "
    },
    "ƒ: ord": {
        "type": "function",
        "label": "ord( $character:string )",
        "apply": "ord( $character:string )",
        "info": "Interprets the binary value of the first byte of character as an unsigned integer between 0 and 255."
    },
    "ƒ: chr": {
        "type": "function",
        "label": "chr( $codepoint:int )",
        "apply": "chr( $codepoint:int )",
        "info": "Returns a one-character string containing the character specified by interpreting codepoint as an unsigned integer."
    },
    "ƒ: ucfirst": {
        "type": "function",
        "label": "ucfirst( $string:string )",
        "apply": "ucfirst( $string:string )",
        "info": "Returns a string with the first character of string capitalized, if that character is an ASCII character in the range from \"a\" (0x61) to \"z\" (0x7a)."
    },
    "ƒ: lcfirst": {
        "type": "function",
        "label": "lcfirst( $string:string )",
        "apply": "lcfirst( $string:string )",
        "info": "Returns a string with the first character of string lowercased if that character is an ASCII character in the range \"A\" (0x41) to \"Z\" (0x5a)."
    },
    "ƒ: ucwords": {
        "type": "function",
        "label": "ucwords( $string:string, $separators:string )",
        "apply": "ucwords( $string:string, $separators:string )",
        "info": "Returns a string with the first character of each word in string capitalized, if that character is an ASCII character between \"a\" (0x61) and \"z\"(0x7a)."
    },
    "ƒ: strtr": {
        "type": "function",
        "label": "strtr( $string:string, $from:array|string, $to:?string )",
        "apply": "strtr( $string:string, $from:array|string, $to:?string )",
        "info": "Alternative signature (not supported with named arguments):"
    },
    "ƒ: strrev": {
        "type": "function",
        "label": "strrev( $string:string )",
        "apply": "strrev( $string:string )",
        "info": "Returns string, reversed."
    },
    "ƒ: similar_text": {
        "type": "function",
        "label": "similar_text( $string1:string, $string2:string, $percent: )",
        "apply": "similar_text( $string1:string, $string2:string, $percent: )",
        "info": "This calculates the similarity between two strings as described in Programming Classics: Implementing the World's Best Algorithms by Oliver (ISBN 0-131-00413-1). Note that this implementation does not use a stack as in Oliver's pseudo code, but recursive calls which may or may not speed up the whole process. Note also that the complexity of this algorithm is O(N**3) where N is the length of the longest string."
    },
    "ƒ: addcslashes": {
        "type": "function",
        "label": "addcslashes( $string:string, $characters:string )",
        "apply": "addcslashes( $string:string, $characters:string )",
        "info": "Returns a string with backslashes before characters that are listed in characters parameter. "
    },
    "ƒ: addslashes": {
        "type": "function",
        "label": "addslashes( $string:string )",
        "apply": "addslashes( $string:string )",
        "info": "Returns a string with backslashes added before characters that need to be escaped. These characters are:"
    },
    "ƒ: stripcslashes": {
        "type": "function",
        "label": "stripcslashes( $string:string )",
        "apply": "stripcslashes( $string:string )",
        "info": "Returns a string with backslashes stripped off. Recognizes C-like \\n, \\r ..., octal and hexadecimal representation."
    },
    "ƒ: stripslashes": {
        "type": "function",
        "label": "stripslashes( $string:string )",
        "apply": "stripslashes( $string:string )",
        "info": "Un-quotes a quoted string."
    },
    "ƒ: str_replace": {
        "type": "function",
        "label": "str_replace( $search:array|string, $replace:array|string, $subject:array|string, $count: )",
        "apply": "str_replace( $search:array|string, $replace:array|string, $subject:array|string, $count: )",
        "info": "This function returns a string or an array with all occurrences of search in subject replaced with the given replace value."
    },
    "ƒ: str_ireplace": {
        "type": "function",
        "label": "str_ireplace( $search:array|string, $replace:array|string, $subject:array|string, $count: )",
        "apply": "str_ireplace( $search:array|string, $replace:array|string, $subject:array|string, $count: )",
        "info": "This function returns a string or an array with all occurrences of search in subject (ignoring case) replaced with the given replace value."
    },
    "ƒ: hebrev": {
        "type": "function",
        "label": "hebrev( $string:string, $max_chars_per_line:int )",
        "apply": "hebrev( $string:string, $max_chars_per_line:int )",
        "info": "Converts logical Hebrew text to visual text."
    },
    "ƒ: nl2br": {
        "type": "function",
        "label": "nl2br( $string:string, $use_xhtml:bool )",
        "apply": "nl2br( $string:string, $use_xhtml:bool )",
        "info": "Returns string with <br \/> or <br> inserted before all newlines (\\r\\n,\\n\\r,\\n and \\r)."
    },
    "ƒ: strip_tags": {
        "type": "function",
        "label": "strip_tags( $string:string, $allowed_tags:array|string|null )",
        "apply": "strip_tags( $string:string, $allowed_tags:array|string|null )",
        "info": "This function tries to return a string with all NULL bytes, HTML and PHP tags stripped from a given string.  It uses the same tag stripping state machine as the fgetss() function."
    },
    "ƒ: setlocale": {
        "type": "function",
        "label": "setlocale( $category:int, $locales:, $rest: )",
        "apply": "setlocale( $category:int, $locales:, $rest: )",
        "info": "Alternative signature (not supported with named arguments):"
    },
    "ƒ: parse_str": {
        "type": "function",
        "label": "parse_str( $string:string, $result: )",
        "apply": "parse_str( $string:string, $result: )",
        "info": "Parses string as if it were the query string passed via a URL and sets variables in the current scope (or in the array if result is provided)."
    },
    "ƒ: str_getcsv": {
        "type": "function",
        "label": "str_getcsv( $string:string, $separator:string, $enclosure:string, $escape:string )",
        "apply": "str_getcsv( $string:string, $separator:string, $enclosure:string, $escape:string )",
        "info": "Parses a string input for fields in CSV format and returns an array containing the fields read."
    },
    "ƒ: str_repeat": {
        "type": "function",
        "label": "str_repeat( $string:string, $times:int )",
        "apply": "str_repeat( $string:string, $times:int )",
        "info": "Returns string repeated times times."
    },
    "ƒ: count_chars": {
        "type": "function",
        "label": "count_chars( $string:string, $mode:int )",
        "apply": "count_chars( $string:string, $mode:int )",
        "info": "Counts the number of occurrences of every byte-value (0..255) in string and returns it in various ways."
    },
    "ƒ: strnatcmp": {
        "type": "function",
        "label": "strnatcmp( $string1:string, $string2:string )",
        "apply": "strnatcmp( $string1:string, $string2:string )",
        "info": "This function implements a comparison algorithm that orders alphanumeric strings in the way a human being would, this is described as a \"natural ordering\".  Note that this comparison is case sensitive."
    },
    "ƒ: localeconv": {
        "type": "function",
        "label": "localeconv()",
        "apply": "localeconv()",
        "info": "Returns an associative array containing localized numeric and monetary formatting information."
    },
    "ƒ: strnatcasecmp": {
        "type": "function",
        "label": "strnatcasecmp( $string1:string, $string2:string )",
        "apply": "strnatcasecmp( $string1:string, $string2:string )",
        "info": "This function implements a comparison algorithm that orders alphanumeric strings in the way a human being would.  The behaviour of this function is similar to strnatcmp(), except that the comparison is not case sensitive.  For more information see: Martin Pool's \u00bb\u00a0Natural Order String Comparison page."
    },
    "ƒ: substr_count": {
        "type": "function",
        "label": "substr_count( $haystack:string, $needle:string, $offset:int, $length:?int )",
        "apply": "substr_count( $haystack:string, $needle:string, $offset:int, $length:?int )",
        "info": "substr_count() returns the number of times the needle substring occurs in the haystack string. Please note that needle is case sensitive."
    },
    "ƒ: str_pad": {
        "type": "function",
        "label": "str_pad( $string:string, $length:int, $pad_string:string, $pad_type:int )",
        "apply": "str_pad( $string:string, $length:int, $pad_string:string, $pad_type:int )",
        "info": "This function returns the string string padded on the left, the right, or both sides to the specified padding length. If the optional argument pad_string is not supplied, the string is padded with spaces, otherwise it is padded with characters from pad_string up to the limit."
    },
    "ƒ: sscanf": {
        "type": "function",
        "label": "sscanf( $string:string, $format:string, $vars:mixed )",
        "apply": "sscanf( $string:string, $format:string, $vars:mixed )",
        "info": "The function sscanf() is the input analog of printf(). sscanf() reads from the string string and interprets it according to the specified format. "
    },
    "ƒ: str_rot13": {
        "type": "function",
        "label": "str_rot13( $string:string )",
        "apply": "str_rot13( $string:string )",
        "info": "Performs the ROT13 encoding on the string argument and returns the resulting string."
    },
    "ƒ: str_shuffle": {
        "type": "function",
        "label": "str_shuffle( $string:string )",
        "apply": "str_shuffle( $string:string )",
        "info": "str_shuffle() shuffles a string.  One permutation of all possible is created."
    },
    "ƒ: str_word_count": {
        "type": "function",
        "label": "str_word_count( $string:string, $format:int, $characters:?string )",
        "apply": "str_word_count( $string:string, $format:int, $characters:?string )",
        "info": "Counts the number of words inside string. If the optional format is not specified, then the return value will be an integer representing the number of words found. In the event the format is specified, the return value will be an array, content of which is dependent on the format. The possible value for the format and the resultant outputs are listed below."
    },
    "ƒ: str_split": {
        "type": "function",
        "label": "str_split( $string:string, $length:int )",
        "apply": "str_split( $string:string, $length:int )",
        "info": "Converts a string to an array. "
    },
    "ƒ: strpbrk": {
        "type": "function",
        "label": "strpbrk( $string:string, $characters:string )",
        "apply": "strpbrk( $string:string, $characters:string )",
        "info": "strpbrk() searches the string string for a characters."
    },
    "ƒ: substr_compare": {
        "type": "function",
        "label": "substr_compare( $haystack:string, $needle:string, $offset:int, $length:?int, $case_insensitive:bool )",
        "apply": "substr_compare( $haystack:string, $needle:string, $offset:int, $length:?int, $case_insensitive:bool )",
        "info": "substr_compare() compares haystack from position offset with needle up to length characters."
    },
    "ƒ: utf8_encode": {
        "type": "function",
        "label": "utf8_encode( $string:string )",
        "apply": "utf8_encode( $string:string )",
        "info": "This function converts the string string from the ISO-8859-1 encoding to UTF-8."
    },
    "ƒ: utf8_decode": {
        "type": "function",
        "label": "utf8_decode( $string:string )",
        "apply": "utf8_decode( $string:string )",
        "info": "This function converts the string string from the UTF-8 encoding to ISO-8859-1. Bytes in the string which are not valid UTF-8, and UTF-8 characters which do not exist in ISO-8859-1 (that is, code points above U+00FF) are replaced with ?."
    },
    "ƒ: opendir": {
        "type": "function",
        "label": "opendir( $directory:string, $context: )",
        "apply": "opendir( $directory:string, $context: )",
        "info": "Opens up a directory handle to be used in subsequent closedir(), readdir(), and rewinddir() calls."
    },
    "ƒ: dir": {
        "type": "function",
        "label": "dir( $directory:string, $context: )",
        "apply": "dir( $directory:string, $context: )",
        "info": "A pseudo-object-oriented mechanism for reading a directory.  The given directory is opened."
    },
    "ƒ: closedir": {
        "type": "function",
        "label": "closedir( $dir_handle: )",
        "apply": "closedir( $dir_handle: )",
        "info": "Closes the directory stream indicated by dir_handle. The stream must have previously been opened by opendir()."
    },
    "ƒ: chdir": {
        "type": "function",
        "label": "chdir( $directory:string )",
        "apply": "chdir( $directory:string )",
        "info": "Changes PHP's current directory to directory."
    },
    "ƒ: getcwd": {
        "type": "function",
        "label": "getcwd()",
        "apply": "getcwd()",
        "info": "Gets the current working directory."
    },
    "ƒ: rewinddir": {
        "type": "function",
        "label": "rewinddir( $dir_handle: )",
        "apply": "rewinddir( $dir_handle: )",
        "info": "Resets the directory stream indicated by dir_handle to the beginning of the directory."
    },
    "ƒ: readdir": {
        "type": "function",
        "label": "readdir( $dir_handle: )",
        "apply": "readdir( $dir_handle: )",
        "info": "Returns the name of the next entry in the directory. The entries are returned in the order in which they are stored by the filesystem."
    },
    "ƒ: scandir": {
        "type": "function",
        "label": "scandir( $directory:string, $sorting_order:int, $context: )",
        "apply": "scandir( $directory:string, $sorting_order:int, $context: )",
        "info": "Returns an array of files and directories from the directory."
    },
    "ƒ: glob": {
        "type": "function",
        "label": "glob( $pattern:string, $flags:int )",
        "apply": "glob( $pattern:string, $flags:int )",
        "info": "The glob() function searches for all the pathnames matching pattern according to the rules used by the libc glob() function, which is similar to the rules used by common shells."
    },
    "ƒ: exec": {
        "type": "function",
        "label": "exec( $command:string, $output:, $result_code: )",
        "apply": "exec( $command:string, $output:, $result_code: )",
        "info": "exec() executes the given command."
    },
    "ƒ: system": {
        "type": "function",
        "label": "system( $command:string, $result_code: )",
        "apply": "system( $command:string, $result_code: )",
        "info": "system() is just like the C version of the function in that it executes the given command and outputs the result."
    },
    "ƒ: passthru": {
        "type": "function",
        "label": "passthru( $command:string, $result_code: )",
        "apply": "passthru( $command:string, $result_code: )",
        "info": "The passthru() function is similar to the exec() function in that it executes a command. This function should be used in place of exec() or system() when the output from the Unix command is binary data which needs to be passed directly back to the browser.  A common use for this is to execute something like the pbmplus utilities that can output an image stream directly.  By setting the Content-type to image\/gif and then calling a pbmplus program to output a gif, you can create PHP scripts that output images directly."
    },
    "ƒ: escapeshellcmd": {
        "type": "function",
        "label": "escapeshellcmd( $command:string )",
        "apply": "escapeshellcmd( $command:string )",
        "info": "escapeshellcmd() escapes any characters in a string that might be used to trick a shell command into executing arbitrary commands.  This function should be used to make sure that any data coming from user input is escaped before this data is passed to the exec() or system() functions, or to the backtick operator."
    },
    "ƒ: escapeshellarg": {
        "type": "function",
        "label": "escapeshellarg( $arg:string )",
        "apply": "escapeshellarg( $arg:string )",
        "info": "escapeshellarg() adds single quotes around a string and quotes\/escapes any existing single quotes allowing you to pass a string directly to a shell function and having it be treated as a single safe argument.  This function should be used to escape individual arguments to shell functions coming from user input.  The shell functions include exec(), system() and the backtick operator."
    },
    "ƒ: shell_exec": {
        "type": "function",
        "label": "shell_exec( $command:string )",
        "apply": "shell_exec( $command:string )",
        "info": "This function is identical to the backtick operator."
    },
    "ƒ: proc_nice": {
        "type": "function",
        "label": "proc_nice( $priority:int )",
        "apply": "proc_nice( $priority:int )",
        "info": "proc_nice() changes the priority of the current process by the amount specified in priority. A positive priority will lower the priority of the current process, whereas a negative priority will raise the priority."
    },
    "ƒ: flock": {
        "type": "function",
        "label": "flock( $stream:, $operation:int, $would_block: )",
        "apply": "flock( $stream:, $operation:int, $would_block: )",
        "info": "flock() allows you to perform a simple reader\/writer model which can be used on virtually every platform (including most Unix derivatives and even Windows)."
    },
    "ƒ: get_meta_tags": {
        "type": "function",
        "label": "get_meta_tags( $filename:string, $use_include_path:bool )",
        "apply": "get_meta_tags( $filename:string, $use_include_path:bool )",
        "info": "Opens filename and parses it line by line for <meta> tags in the file. The parsing stops at <\/head>."
    },
    "ƒ: pclose": {
        "type": "function",
        "label": "pclose( $handle: )",
        "apply": "pclose( $handle: )",
        "info": "Closes a file pointer to a pipe opened by popen()."
    },
    "ƒ: popen": {
        "type": "function",
        "label": "popen( $command:string, $mode:string )",
        "apply": "popen( $command:string, $mode:string )",
        "info": "Opens a pipe to a process executed by forking the command given by command."
    },
    "ƒ: readfile": {
        "type": "function",
        "label": "readfile( $filename:string, $use_include_path:bool, $context: )",
        "apply": "readfile( $filename:string, $use_include_path:bool, $context: )",
        "info": "Reads a file and writes it to the output buffer."
    },
    "ƒ: rewind": {
        "type": "function",
        "label": "rewind( $stream: )",
        "apply": "rewind( $stream: )",
        "info": "Sets the file position indicator for stream to the beginning of the file stream."
    },
    "ƒ: rmdir": {
        "type": "function",
        "label": "rmdir( $directory:string, $context: )",
        "apply": "rmdir( $directory:string, $context: )",
        "info": "Attempts to remove the directory named by directory.The directory must be empty, and the relevant permissions must permit this.A E_WARNING level error will be generated on failure."
    },
    "ƒ: umask": {
        "type": "function",
        "label": "umask( $mask:?int )",
        "apply": "umask( $mask:?int )",
        "info": "umask() sets PHP's umask to mask & 0777 and returns the old umask. When PHP is being used as a server module, the umask is restored when each request is finished."
    },
    "ƒ: fclose": {
        "type": "function",
        "label": "fclose( $stream: )",
        "apply": "fclose( $stream: )",
        "info": "The file pointed to by stream is closed."
    },
    "ƒ: feof": {
        "type": "function",
        "label": "feof( $stream: )",
        "apply": "feof( $stream: )",
        "info": "Tests for end-of-file on a file pointer."
    },
    "ƒ: fgetc": {
        "type": "function",
        "label": "fgetc( $stream: )",
        "apply": "fgetc( $stream: )",
        "info": "Gets a character from the given file pointer."
    },
    "ƒ: fgets": {
        "type": "function",
        "label": "fgets( $stream:, $length:?int )",
        "apply": "fgets( $stream:, $length:?int )",
        "info": "Gets a line from file pointer."
    },
    "ƒ: fread": {
        "type": "function",
        "label": "fread( $stream:, $length:int )",
        "apply": "fread( $stream:, $length:int )",
        "info": "fread() reads up to length bytes from the file pointer referenced by stream. Reading stops as soon as one of the following conditions is met:"
    },
    "ƒ: fopen": {
        "type": "function",
        "label": "fopen( $filename:string, $mode:string, $use_include_path:bool, $context: )",
        "apply": "fopen( $filename:string, $mode:string, $use_include_path:bool, $context: )",
        "info": "fopen() binds a named resource, specified by filename, to a stream. "
    },
    "ƒ: fscanf": {
        "type": "function",
        "label": "fscanf( $stream:, $format:string, $vars:mixed )",
        "apply": "fscanf( $stream:, $format:string, $vars:mixed )",
        "info": "The function fscanf() is similar to sscanf(), but it takes its input from a file associated with stream and interprets the input according to the specified format. "
    },
    "ƒ: fpassthru": {
        "type": "function",
        "label": "fpassthru( $stream: )",
        "apply": "fpassthru( $stream: )",
        "info": "Reads to EOF on the given file pointer from the current position and writes the results to the output buffer."
    },
    "ƒ: ftruncate": {
        "type": "function",
        "label": "ftruncate( $stream:, $size:int )",
        "apply": "ftruncate( $stream:, $size:int )",
        "info": "Takes the filepointer, stream, and truncates the file to length, size."
    },
    "ƒ: fstat": {
        "type": "function",
        "label": "fstat( $stream: )",
        "apply": "fstat( $stream: )",
        "info": "Gathers the statistics of the file opened by the file pointer stream. This function is similar to the stat() function except that it operates on an open file pointer instead of a filename."
    },
    "ƒ: fseek": {
        "type": "function",
        "label": "fseek( $stream:, $offset:int, $whence:int )",
        "apply": "fseek( $stream:, $offset:int, $whence:int )",
        "info": "Sets the file position indicator for the file referenced by stream. The new position, measured in bytes from the beginning of the file, is obtained by adding offset to the position specified by whence."
    },
    "ƒ: ftell": {
        "type": "function",
        "label": "ftell( $stream: )",
        "apply": "ftell( $stream: )",
        "info": "Returns the position of the file pointer referenced by stream."
    },
    "ƒ: fflush": {
        "type": "function",
        "label": "fflush( $stream: )",
        "apply": "fflush( $stream: )",
        "info": "This function forces a write of all buffered output to the resource pointed to by the file stream."
    },
    "ƒ: fsync": {
        "type": "function",
        "label": "fsync( $stream: )",
        "apply": "fsync( $stream: )",
        "info": "This function synchronizes changes to the file, including its meta-data. This is similar to fflush(),but it also instructs the operating system to write to the storage media."
    },
    "ƒ: fdatasync": {
        "type": "function",
        "label": "fdatasync( $stream: )",
        "apply": "fdatasync( $stream: )",
        "info": "This function synchronizes stream contents to storage media, just like fsync() does,but it does not synchronize file meta-data.Note that this function is only effectively different in POSIX systems.In Windows, this function is aliased to fsync()."
    },
    "ƒ: fwrite": {
        "type": "function",
        "label": "fwrite( $stream:, $data:string, $length:?int )",
        "apply": "fwrite( $stream:, $data:string, $length:?int )",
        "info": "fwrite() writes the contents of data to the file stream pointed to by stream. "
    },
    "ƒ: fputs": {
        "type": "function",
        "label": "fputs( $stream:, $data:string, $length:?int )",
        "apply": "fputs( $stream:, $data:string, $length:?int )",
        "info": "This function is an alias of: fwrite()."
    },
    "ƒ: mkdir": {
        "type": "function",
        "label": "mkdir( $directory:string, $permissions:int, $recursive:bool, $context: )",
        "apply": "mkdir( $directory:string, $permissions:int, $recursive:bool, $context: )",
        "info": "Attempts to create the directory specified by directory."
    },
    "ƒ: rename": {
        "type": "function",
        "label": "rename( $from:string, $to:string, $context: )",
        "apply": "rename( $from:string, $to:string, $context: )",
        "info": "Attempts to rename from to to, moving it between directories if necessary.If renaming a file and to exists,it will be overwritten. If renaming a directory and to exists,this function will emit a warning."
    },
    "ƒ: copy": {
        "type": "function",
        "label": "copy( $from:string, $to:string, $context: )",
        "apply": "copy( $from:string, $to:string, $context: )",
        "info": "Makes a copy of the file from to to."
    },
    "ƒ: tempnam": {
        "type": "function",
        "label": "tempnam( $directory:string, $prefix:string )",
        "apply": "tempnam( $directory:string, $prefix:string )",
        "info": "Creates a file with a unique filename, with access permission set to 0600, in the specified directory.If the directory does not exist or is not writable, tempnam() may generate a file in the system's temporary directory, and return the full path to that file, including its name."
    },
    "ƒ: tmpfile": {
        "type": "function",
        "label": "tmpfile()",
        "apply": "tmpfile()",
        "info": "Creates a temporary file with a unique name in read-write-binary (w+b) mode and returns a file handle."
    },
    "ƒ: file": {
        "type": "function",
        "label": "file( $filename:string, $flags:int, $context: )",
        "apply": "file( $filename:string, $flags:int, $context: )",
        "info": "Reads an entire file into an array."
    },
    "ƒ: file_get_contents": {
        "type": "function",
        "label": "file_get_contents( $filename:string, $use_include_path:bool, $context:, $offset:int, $length:?int )",
        "apply": "file_get_contents( $filename:string, $use_include_path:bool, $context:, $offset:int, $length:?int )",
        "info": " This function is similar to file(), except that file_get_contents() returns the file in a string, starting at the specified offset up to length bytes. On failure, file_get_contents() will return false."
    },
    "ƒ: unlink": {
        "type": "function",
        "label": "unlink( $filename:string, $context: )",
        "apply": "unlink( $filename:string, $context: )",
        "info": "Deletes filename.  Similar to the Unix C unlink()function. An E_WARNING level error will be generated on failure."
    },
    "ƒ: file_put_contents": {
        "type": "function",
        "label": "file_put_contents( $filename:string, $data:mixed, $flags:int, $context: )",
        "apply": "file_put_contents( $filename:string, $data:mixed, $flags:int, $context: )",
        "info": " This function is identical to calling fopen(), fwrite() and fclose() successively to write data to a file."
    },
    "ƒ: fputcsv": {
        "type": "function",
        "label": "fputcsv( $stream:, $fields:array, $separator:string, $enclosure:string, $escape:string, $eol:string )",
        "apply": "fputcsv( $stream:, $fields:array, $separator:string, $enclosure:string, $escape:string, $eol:string )",
        "info": "fputcsv() formats a line (passed as a fields array) as CSV and writes it (terminated by a newline) to the specified file stream. "
    },
    "ƒ: fgetcsv": {
        "type": "function",
        "label": "fgetcsv( $stream:, $length:?int, $separator:string, $enclosure:string, $escape:string )",
        "apply": "fgetcsv( $stream:, $length:?int, $separator:string, $enclosure:string, $escape:string )",
        "info": "Similar to fgets() except that fgetcsv() parses the line it reads for fields in CSV format and returns an array containing the fields read."
    },
    "ƒ: realpath": {
        "type": "function",
        "label": "realpath( $path:string )",
        "apply": "realpath( $path:string )",
        "info": "realpath() expands all symbolic links and resolves references to \/.\/, \/..\/ and extra \/ characters in the input path and returns the canonicalized absolute pathname.  "
    },
    "ƒ: fnmatch": {
        "type": "function",
        "label": "fnmatch( $pattern:string, $filename:string, $flags:int )",
        "apply": "fnmatch( $pattern:string, $filename:string, $flags:int )",
        "info": "fnmatch() checks if the passed filename would match the given shell wildcard pattern."
    },
    "ƒ: sys_get_temp_dir": {
        "type": "function",
        "label": "sys_get_temp_dir()",
        "apply": "sys_get_temp_dir()",
        "info": "Returns the path of the directory PHP stores temporary files in by default."
    },
    "ƒ: fileatime": {
        "type": "function",
        "label": "fileatime( $filename:string )",
        "apply": "fileatime( $filename:string )",
        "info": "Gets the last access time of the given file."
    },
    "ƒ: filectime": {
        "type": "function",
        "label": "filectime( $filename:string )",
        "apply": "filectime( $filename:string )",
        "info": "Gets the inode change time of a file."
    },
    "ƒ: filegroup": {
        "type": "function",
        "label": "filegroup( $filename:string )",
        "apply": "filegroup( $filename:string )",
        "info": "Gets the file group. The group ID is returned in numerical format, use posix_getgrgid() to resolve it to a group name."
    },
    "ƒ: fileinode": {
        "type": "function",
        "label": "fileinode( $filename:string )",
        "apply": "fileinode( $filename:string )",
        "info": "Gets the file inode."
    },
    "ƒ: filemtime": {
        "type": "function",
        "label": "filemtime( $filename:string )",
        "apply": "filemtime( $filename:string )",
        "info": "This function returns the time when the data blocks of a file were being written to, that is, the time when the content of the file was changed."
    },
    "ƒ: fileowner": {
        "type": "function",
        "label": "fileowner( $filename:string )",
        "apply": "fileowner( $filename:string )",
        "info": "Gets the file owner."
    },
    "ƒ: fileperms": {
        "type": "function",
        "label": "fileperms( $filename:string )",
        "apply": "fileperms( $filename:string )",
        "info": "Gets permissions for the given file."
    },
    "ƒ: filesize": {
        "type": "function",
        "label": "filesize( $filename:string )",
        "apply": "filesize( $filename:string )",
        "info": "Gets the size for the given file."
    },
    "ƒ: filetype": {
        "type": "function",
        "label": "filetype( $filename:string )",
        "apply": "filetype( $filename:string )",
        "info": "Returns the type of the given file."
    },
    "ƒ: file_exists": {
        "type": "function",
        "label": "file_exists( $filename:string )",
        "apply": "file_exists( $filename:string )",
        "info": "Checks whether a file or directory exists."
    },
    "ƒ: is_writable": {
        "type": "function",
        "label": "is_writable( $filename:string )",
        "apply": "is_writable( $filename:string )",
        "info": "Returns true if the filename exists and is writable.  The filename argument may be a directory name allowing you to check if a directory is writable."
    },
    "ƒ: is_writeable": {
        "type": "function",
        "label": "is_writeable( $filename:string )",
        "apply": "is_writeable( $filename:string )",
        "info": "This function is an alias of: is_writable()."
    },
    "ƒ: is_readable": {
        "type": "function",
        "label": "is_readable( $filename:string )",
        "apply": "is_readable( $filename:string )",
        "info": "Tells whether a file exists and is readable."
    },
    "ƒ: is_executable": {
        "type": "function",
        "label": "is_executable( $filename:string )",
        "apply": "is_executable( $filename:string )",
        "info": "Tells whether the filename is executable."
    },
    "ƒ: is_file": {
        "type": "function",
        "label": "is_file( $filename:string )",
        "apply": "is_file( $filename:string )",
        "info": "Tells whether the given file is a regular file."
    },
    "ƒ: is_dir": {
        "type": "function",
        "label": "is_dir( $filename:string )",
        "apply": "is_dir( $filename:string )",
        "info": "Tells whether the given filename is a directory."
    },
    "ƒ: is_link": {
        "type": "function",
        "label": "is_link( $filename:string )",
        "apply": "is_link( $filename:string )",
        "info": "Tells whether the given file is a symbolic link."
    },
    "ƒ: stat": {
        "type": "function",
        "label": "stat( $filename:string )",
        "apply": "stat( $filename:string )",
        "info": "Gathers the statistics of the file named by filename.  If filename is a symbolic link, statistics are from the file itself, not the symlink.Prior to PHP 7.4.0, on Windows NTS builds the size,atime, mtime and ctime statistics have been from the symlink, in this case."
    },
    "ƒ: lstat": {
        "type": "function",
        "label": "lstat( $filename:string )",
        "apply": "lstat( $filename:string )",
        "info": "Gathers the statistics of the file or symbolic link named by filename.  "
    },
    "ƒ: chown": {
        "type": "function",
        "label": "chown( $filename:string, $user:string|int )",
        "apply": "chown( $filename:string, $user:string|int )",
        "info": "Attempts to change the owner of the file filename to user user. Only the superuser may change the owner of a file."
    },
    "ƒ: chgrp": {
        "type": "function",
        "label": "chgrp( $filename:string, $group:string|int )",
        "apply": "chgrp( $filename:string, $group:string|int )",
        "info": "Attempts to change the group of the file filename to group."
    },
    "ƒ: lchown": {
        "type": "function",
        "label": "lchown( $filename:string, $user:string|int )",
        "apply": "lchown( $filename:string, $user:string|int )",
        "info": "Attempts to change the owner of the symlink filename to user user."
    },
    "ƒ: lchgrp": {
        "type": "function",
        "label": "lchgrp( $filename:string, $group:string|int )",
        "apply": "lchgrp( $filename:string, $group:string|int )",
        "info": "Attempts to change the group of the symlink filename to group."
    },
    "ƒ: chmod": {
        "type": "function",
        "label": "chmod( $filename:string, $permissions:int )",
        "apply": "chmod( $filename:string, $permissions:int )",
        "info": "Attempts to change the mode of the specified file to that given in permissions."
    },
    "ƒ: touch": {
        "type": "function",
        "label": "touch( $filename:string, $mtime:?int, $atime:?int )",
        "apply": "touch( $filename:string, $mtime:?int, $atime:?int )",
        "info": "Attempts to set the access and modification times of the file named in the filename parameter to the value given in mtime. Note that the access time is always modified, regardless of the number of parameters."
    },
    "ƒ: clearstatcache": {
        "type": "function",
        "label": "clearstatcache( $clear_realpath_cache:bool, $filename:string )",
        "apply": "clearstatcache( $clear_realpath_cache:bool, $filename:string )",
        "info": "When you use stat(), lstat(), or any of the other functions listed in the affected functions list (below),PHP caches the information those functions return in order to provide faster performance. However, in certain cases, you may want to clear the cached information. For instance, if the same file is being checked multiple times within a single script, and that file is in danger of being removed or changed during that script's operation, you may elect to clear the status cache.  In these cases, you can use the clearstatcache() function to clear the information that PHP caches about a file."
    },
    "ƒ: disk_total_space": {
        "type": "function",
        "label": "disk_total_space( $directory:string )",
        "apply": "disk_total_space( $directory:string )",
        "info": "Given a string containing a directory, this function will return the total number of bytes on the corresponding filesystem or disk partition."
    },
    "ƒ: disk_free_space": {
        "type": "function",
        "label": "disk_free_space( $directory:string )",
        "apply": "disk_free_space( $directory:string )",
        "info": "Given a string containing a directory, this function will return the number of bytes available on the corresponding filesystem or disk partition."
    },
    "ƒ: diskfreespace": {
        "type": "function",
        "label": "diskfreespace( $directory:string )",
        "apply": "diskfreespace( $directory:string )",
        "info": "This function is an alias of: disk_free_space()."
    },
    "ƒ: realpath_cache_get": {
        "type": "function",
        "label": "realpath_cache_get()",
        "apply": "realpath_cache_get()",
        "info": "Get the contents of the realpath cache."
    },
    "ƒ: realpath_cache_size": {
        "type": "function",
        "label": "realpath_cache_size()",
        "apply": "realpath_cache_size()",
        "info": "Get the amount of memory used by the realpath cache."
    },
    "ƒ: sprintf": {
        "type": "function",
        "label": "sprintf( $format:string, $values:mixed )",
        "apply": "sprintf( $format:string, $values:mixed )",
        "info": "Returns a string produced according to the formatting string format."
    },
    "ƒ: printf": {
        "type": "function",
        "label": "printf( $format:string, $values:mixed )",
        "apply": "printf( $format:string, $values:mixed )",
        "info": "Produces output according to format."
    },
    "ƒ: vprintf": {
        "type": "function",
        "label": "vprintf( $format:string, $values:array )",
        "apply": "vprintf( $format:string, $values:array )",
        "info": "Display array values as a formatted string according to format (which is described in the documentation for sprintf())."
    },
    "ƒ: vsprintf": {
        "type": "function",
        "label": "vsprintf( $format:string, $values:array )",
        "apply": "vsprintf( $format:string, $values:array )",
        "info": "Operates as sprintf() but accepts an array of arguments, rather than a variable number of arguments."
    },
    "ƒ: fprintf": {
        "type": "function",
        "label": "fprintf( $stream:, $format:string, $values:mixed )",
        "apply": "fprintf( $stream:, $format:string, $values:mixed )",
        "info": "Write a string produced according to format to the stream resource specified by stream."
    },
    "ƒ: vfprintf": {
        "type": "function",
        "label": "vfprintf( $stream:, $format:string, $values:array )",
        "apply": "vfprintf( $stream:, $format:string, $values:array )",
        "info": "Write a string produced according to format to the stream resource specified by stream."
    },
    "ƒ: fsockopen": {
        "type": "function",
        "label": "fsockopen( $hostname:string, $port:int, $error_code:, $error_message:, $timeout:?float )",
        "apply": "fsockopen( $hostname:string, $port:int, $error_code:, $error_message:, $timeout:?float )",
        "info": "Initiates a socket connection to the resource specified by hostname."
    },
    "ƒ: pfsockopen": {
        "type": "function",
        "label": "pfsockopen( $hostname:string, $port:int, $error_code:, $error_message:, $timeout:?float )",
        "apply": "pfsockopen( $hostname:string, $port:int, $error_code:, $error_message:, $timeout:?float )",
        "info": "This function behaves exactly as fsockopen() with the difference that the connection is not closed after the script finishes.It is the persistent version of fsockopen()."
    },
    "ƒ: http_build_query": {
        "type": "function",
        "label": "http_build_query( $data:object|array, $numeric_prefix:string, $arg_separator:?string, $encoding_type:int )",
        "apply": "http_build_query( $data:object|array, $numeric_prefix:string, $arg_separator:?string, $encoding_type:int )",
        "info": "Generates a URL-encoded query string from the associative (or indexed)array provided."
    },
    "ƒ: image_type_to_mime_type": {
        "type": "function",
        "label": "image_type_to_mime_type( $image_type:int )",
        "apply": "image_type_to_mime_type( $image_type:int )",
        "info": "The image_type_to_mime_type() function will determine the Mime-Type for an IMAGETYPE constant."
    },
    "ƒ: image_type_to_extension": {
        "type": "function",
        "label": "image_type_to_extension( $image_type:int, $include_dot:bool )",
        "apply": "image_type_to_extension( $image_type:int, $include_dot:bool )",
        "info": "Returns the extension for the given IMAGETYPE_XXX constant."
    },
    "ƒ: getimagesize": {
        "type": "function",
        "label": "getimagesize( $filename:string, $image_info: )",
        "apply": "getimagesize( $filename:string, $image_info: )",
        "info": "The getimagesize() function will determine the size of any supported given image file and return the dimensions along with the file type and a height\/width text string to be used inside a normal HTML IMG tag and the correspondent HTTP content type."
    },
    "ƒ: getimagesizefromstring": {
        "type": "function",
        "label": "getimagesizefromstring( $string:string, $image_info: )",
        "apply": "getimagesizefromstring( $string:string, $image_info: )",
        "info": "Identical to getimagesize() except that getimagesizefromstring()accepts a string instead of a file name as the first parameter."
    },
    "ƒ: phpinfo": {
        "type": "function",
        "label": "phpinfo( $flags:int )",
        "apply": "phpinfo( $flags:int )",
        "info": "Outputs a large amount of information about the current state of  PHP. This includes information about PHP compilation options and extensions,the PHP version, server information and environment (if compiled as a module), the PHP environment, OS version information, paths, master and local values of configuration options, HTTP headers, and the PHP License."
    },
    "ƒ: phpversion": {
        "type": "function",
        "label": "phpversion( $extension:?string )",
        "apply": "phpversion( $extension:?string )",
        "info": "Returns a string containing the version of the currently running PHP parser or extension."
    },
    "ƒ: phpcredits": {
        "type": "function",
        "label": "phpcredits( $flags:int )",
        "apply": "phpcredits( $flags:int )",
        "info": "This function prints out the credits listing the PHP developers,modules, etc. It generates the appropriate HTML codes to insert the information in a page. "
    },
    "ƒ: php_sapi_name": {
        "type": "function",
        "label": "php_sapi_name()",
        "apply": "php_sapi_name()",
        "info": "Returns a lowercase string that describes the type of interface (the Server API, SAPI) that PHP is using. For example, in CLI PHP this string will be \"cli\" whereas with Apache it may have several different values depending on the exact SAPI used. Possible values are listed below."
    },
    "ƒ: php_uname": {
        "type": "function",
        "label": "php_uname( $mode:string )",
        "apply": "php_uname( $mode:string )",
        "info": "php_uname() returns a description of the operating system PHP is running on.  This is the same string you see at the very top of the phpinfo() output.  For the name of just the operating system, consider using the PHP_OS constant, but keep in mind this constant will contain the operating system PHP was built on."
    },
    "ƒ: php_ini_scanned_files": {
        "type": "function",
        "label": "php_ini_scanned_files()",
        "apply": "php_ini_scanned_files()",
        "info": "php_ini_scanned_files() returns a comma-separated list of configuration files parsed after php.ini. The directories searched are set by a compile time option and, optionally, by an environment variable at run time: more information can be found in the installation guide."
    },
    "ƒ: php_ini_loaded_file": {
        "type": "function",
        "label": "php_ini_loaded_file()",
        "apply": "php_ini_loaded_file()",
        "info": "Check if a php.ini file is loaded, and retrieve its path."
    },
    "ƒ: iptcembed": {
        "type": "function",
        "label": "iptcembed( $iptc_data:string, $filename:string, $spool:int )",
        "apply": "iptcembed( $iptc_data:string, $filename:string, $spool:int )",
        "info": "Embeds binary IPTC data into a JPEG image."
    },
    "ƒ: iptcparse": {
        "type": "function",
        "label": "iptcparse( $iptc_block:string )",
        "apply": "iptcparse( $iptc_block:string )",
        "info": "Parses an \u00bb\u00a0IPTC block into its single tags."
    },
    "ƒ: levenshtein": {
        "type": "function",
        "label": "levenshtein( $string1:string, $string2:string, $insertion_cost:int, $replacement_cost:int, $deletion_cost:int )",
        "apply": "levenshtein( $string1:string, $string2:string, $insertion_cost:int, $replacement_cost:int, $deletion_cost:int )",
        "info": "The Levenshtein distance is defined as the minimal number of characters you have to replace, insert or delete to transform string1 into string2.The complexity of the algorithm is O(m*n),where n and m are the length of string1 and string2 (rather good when compared to similar_text(), which is O(max(n,m)**3),but still expensive)."
    },
    "ƒ: readlink": {
        "type": "function",
        "label": "readlink( $path:string )",
        "apply": "readlink( $path:string )",
        "info": "readlink() does the same as the readlink C function."
    },
    "ƒ: linkinfo": {
        "type": "function",
        "label": "linkinfo( $path:string )",
        "apply": "linkinfo( $path:string )",
        "info": "Gets information about a link.  "
    },
    "ƒ: symlink": {
        "type": "function",
        "label": "symlink( $target:string, $link:string )",
        "apply": "symlink( $target:string, $link:string )",
        "info": "symlink() creates a symbolic link to the existing target with the specified name link."
    },
    "ƒ: link": {
        "type": "function",
        "label": "link( $target:string, $link:string )",
        "apply": "link( $target:string, $link:string )",
        "info": "link() creates a hard link."
    },
    "ƒ: mail": {
        "type": "function",
        "label": "mail( $to:string, $subject:string, $message:string, $additional_headers:array|string, $additional_params:string )",
        "apply": "mail( $to:string, $subject:string, $message:string, $additional_headers:array|string, $additional_params:string )",
        "info": "Sends an email."
    },
    "ƒ: abs": {
        "type": "function",
        "label": "abs( $num:int|float )",
        "apply": "abs( $num:int|float )",
        "info": "Returns the absolute value of num. "
    },
    "ƒ: ceil": {
        "type": "function",
        "label": "ceil( $num:int|float )",
        "apply": "ceil( $num:int|float )",
        "info": "Returns the next highest integer value by rounding up num if necessary. "
    },
    "ƒ: floor": {
        "type": "function",
        "label": "floor( $num:int|float )",
        "apply": "floor( $num:int|float )",
        "info": "Returns the next lowest integer value (as float) by rounding down num if necessary. "
    },
    "ƒ: round": {
        "type": "function",
        "label": "round( $num:int|float, $precision:int, $mode:int )",
        "apply": "round( $num:int|float, $precision:int, $mode:int )",
        "info": "Returns the rounded value of num to specified precision (number of digits after the decimal point).precision can also be negative or zero (default)."
    },
    "ƒ: sin": {
        "type": "function",
        "label": "sin( $num:float )",
        "apply": "sin( $num:float )",
        "info": "sin() returns the sine of the num parameter.  The num parameter is in radians."
    },
    "ƒ: cos": {
        "type": "function",
        "label": "cos( $num:float )",
        "apply": "cos( $num:float )",
        "info": "cos() returns the cosine of the num parameter.  The num parameter is in radians."
    },
    "ƒ: tan": {
        "type": "function",
        "label": "tan( $num:float )",
        "apply": "tan( $num:float )",
        "info": "tan() returns the tangent of the num parameter.  The num parameter is in radians."
    },
    "ƒ: asin": {
        "type": "function",
        "label": "asin( $num:float )",
        "apply": "asin( $num:float )",
        "info": "Returns the arc sine of num in radians.asin() is the inverse function of sin(), which means that a==sin(asin(a)) for every value of a that is within asin()'s range."
    },
    "ƒ: acos": {
        "type": "function",
        "label": "acos( $num:float )",
        "apply": "acos( $num:float )",
        "info": "Returns the arc cosine of num in radians.acos() is the inverse function of cos(), which means that a==cos(acos(a)) for every value of a that is within acos()' range."
    },
    "ƒ: atan": {
        "type": "function",
        "label": "atan( $num:float )",
        "apply": "atan( $num:float )",
        "info": "Returns the arc tangent of num in radians.atan() is the inverse function of tan(), which means that a==tan(atan(a)) for every value of a that is within atan()'s range."
    },
    "ƒ: atanh": {
        "type": "function",
        "label": "atanh( $num:float )",
        "apply": "atanh( $num:float )",
        "info": "Returns the inverse hyperbolic tangent of num, i.e. the value whose hyperbolic tangent is num."
    },
    "ƒ: atan2": {
        "type": "function",
        "label": "atan2( $y:float, $x:float )",
        "apply": "atan2( $y:float, $x:float )",
        "info": "This function calculates the arc tangent of the two variables x and y.  It is similar to calculating the arc tangent of y \/ x, except that the signs of both arguments are used to determine the quadrant of the result."
    },
    "ƒ: sinh": {
        "type": "function",
        "label": "sinh( $num:float )",
        "apply": "sinh( $num:float )",
        "info": "Returns the hyperbolic sine of num,defined as (exp($num) - exp(-$num))\/2."
    },
    "ƒ: cosh": {
        "type": "function",
        "label": "cosh( $num:float )",
        "apply": "cosh( $num:float )",
        "info": "Returns the hyperbolic cosine of num,defined as (exp($num) + exp(-$num))\/2."
    },
    "ƒ: tanh": {
        "type": "function",
        "label": "tanh( $num:float )",
        "apply": "tanh( $num:float )",
        "info": "Returns the hyperbolic tangent of num,defined as sinh($num)\/cosh($num)."
    },
    "ƒ: asinh": {
        "type": "function",
        "label": "asinh( $num:float )",
        "apply": "asinh( $num:float )",
        "info": "Returns the inverse hyperbolic sine of num, i.e. the value whose hyperbolic sine is num."
    },
    "ƒ: acosh": {
        "type": "function",
        "label": "acosh( $num:float )",
        "apply": "acosh( $num:float )",
        "info": "Returns the inverse hyperbolic cosine of num, i.e. the value whose hyperbolic cosine is num."
    },
    "ƒ: expm1": {
        "type": "function",
        "label": "expm1( $num:float )",
        "apply": "expm1( $num:float )",
        "info": "expm1() returns the equivalent to 'exp(num) -  1' computed in a way that is accurate even if the value of num is near zero,a case where 'exp (num) - 1' would be inaccurate due to subtraction of two numbers that are nearly equal."
    },
    "ƒ: log1p": {
        "type": "function",
        "label": "log1p( $num:float )",
        "apply": "log1p( $num:float )",
        "info": "log1p() returns log(1 +num) computed in a way that is accurate even when the value of num is close to zero.log() might only return log(1) in this case due to lack of precision."
    },
    "ƒ: pi": {
        "type": "function",
        "label": "pi()",
        "apply": "pi()",
        "info": "Returns an approximation of pi.Also, you can use the M_PI constant which yields identical results to pi()."
    },
    "ƒ: is_finite": {
        "type": "function",
        "label": "is_finite( $num:float )",
        "apply": "is_finite( $num:float )",
        "info": "Checks whether num is a legal finite on this platform."
    },
    "ƒ: is_nan": {
        "type": "function",
        "label": "is_nan( $num:float )",
        "apply": "is_nan( $num:float )",
        "info": "Checks whether num is 'not a number', like the result of acos(1.01)."
    },
    "ƒ: intdiv": {
        "type": "function",
        "label": "intdiv( $num1:int, $num2:int )",
        "apply": "intdiv( $num1:int, $num2:int )",
        "info": "Returns the integer quotient of the division of num1 by num2."
    },
    "ƒ: is_infinite": {
        "type": "function",
        "label": "is_infinite( $num:float )",
        "apply": "is_infinite( $num:float )",
        "info": "Returns true if num is infinite (positive or negative), like the result of log(0) or any value too big to fit into a float on this platform."
    },
    "ƒ: pow": {
        "type": "function",
        "label": "pow( $num:mixed, $exponent:mixed )",
        "apply": "pow( $num:mixed, $exponent:mixed )",
        "info": "Returns num raised to the power of exponent. "
    },
    "ƒ: exp": {
        "type": "function",
        "label": "exp( $num:float )",
        "apply": "exp( $num:float )",
        "info": "Returns e raised to the power of num."
    },
    "ƒ: log": {
        "type": "function",
        "label": "log( $num:float, $base:float )",
        "apply": "log( $num:float, $base:float )",
        "info": "If the optional base parameter is specified, log() returns logbase num, otherwise log() returns the natural logarithm of num."
    },
    "ƒ: log10": {
        "type": "function",
        "label": "log10( $num:float )",
        "apply": "log10( $num:float )",
        "info": "Returns the base-10 logarithm of num."
    },
    "ƒ: sqrt": {
        "type": "function",
        "label": "sqrt( $num:float )",
        "apply": "sqrt( $num:float )",
        "info": "Returns the square root of num."
    },
    "ƒ: hypot": {
        "type": "function",
        "label": "hypot( $x:float, $y:float )",
        "apply": "hypot( $x:float, $y:float )",
        "info": "hypot() returns the length of the hypotenuse of a right-angle triangle with sides of length x and y, or the distance of the point (x, y) from the origin.This is equivalent to sqrt(x*x + y*y)."
    },
    "ƒ: deg2rad": {
        "type": "function",
        "label": "deg2rad( $num:float )",
        "apply": "deg2rad( $num:float )",
        "info": "This function converts num from degrees to the radian equivalent."
    },
    "ƒ: rad2deg": {
        "type": "function",
        "label": "rad2deg( $num:float )",
        "apply": "rad2deg( $num:float )",
        "info": "This function converts num from radian to degrees."
    },
    "ƒ: bindec": {
        "type": "function",
        "label": "bindec( $binary_string:string )",
        "apply": "bindec( $binary_string:string )",
        "info": "Returns the decimal equivalent of the binary number represented by the binary_string argument."
    },
    "ƒ: hexdec": {
        "type": "function",
        "label": "hexdec( $hex_string:string )",
        "apply": "hexdec( $hex_string:string )",
        "info": "Returns the decimal equivalent of the hexadecimal number represented by the hex_string argument.hexdec() converts a hexadecimal string to a decimal number. "
    },
    "ƒ: octdec": {
        "type": "function",
        "label": "octdec( $octal_string:string )",
        "apply": "octdec( $octal_string:string )",
        "info": "Returns the decimal equivalent of the octal number represented by the octal_string argument."
    },
    "ƒ: decbin": {
        "type": "function",
        "label": "decbin( $num:int )",
        "apply": "decbin( $num:int )",
        "info": "Returns a string containing a binary representation of the given num argument."
    },
    "ƒ: decoct": {
        "type": "function",
        "label": "decoct( $num:int )",
        "apply": "decoct( $num:int )",
        "info": "Returns a string containing an octal representation of the given num argument. The largest number that can be converted depends on the platform in use. For 32-bit platforms this is usually 4294967295 in decimal resulting in 37777777777. For 64-bit platforms this is usually 9223372036854775807 in decimal resulting in 777777777777777777777."
    },
    "ƒ: dechex": {
        "type": "function",
        "label": "dechex( $num:int )",
        "apply": "dechex( $num:int )",
        "info": "Returns a string containing a hexadecimal representation of the given unsigned num argument."
    },
    "ƒ: base_convert": {
        "type": "function",
        "label": "base_convert( $num:string, $from_base:int, $to_base:int )",
        "apply": "base_convert( $num:string, $from_base:int, $to_base:int )",
        "info": "Returns a string containing num represented in base to_base.  The base in which num is given is specified in from_base.  Both from_base and to_base have to be between 2 and 36, inclusive.  Digits in numbers with a base higher than 10 will be represented with the letters a-z,with a meaning 10, b meaning 11 and z meaning 35.The case of the letters doesn't matter, i.e.num is interpreted case-insensitively."
    },
    "ƒ: number_format": {
        "type": "function",
        "label": "number_format( $num:float, $decimals:int, $decimal_separator:?string, $thousands_separator:?string )",
        "apply": "number_format( $num:float, $decimals:int, $decimal_separator:?string, $thousands_separator:?string )",
        "info": "Formats a number with grouped thousands and optionally decimal digits."
    },
    "ƒ: fmod": {
        "type": "function",
        "label": "fmod( $num1:float, $num2:float )",
        "apply": "fmod( $num1:float, $num2:float )",
        "info": "Returns the floating point remainder of dividing the dividend (num1) by the divisor (num2).The remainder (r) is defined as: num1 = i * num2 + r, for some integer i. If num2 is non-zero, r has the same sign as num1 and a magnitude less than the magnitude of num2."
    },
    "ƒ: fdiv": {
        "type": "function",
        "label": "fdiv( $num1:float, $num2:float )",
        "apply": "fdiv( $num1:float, $num2:float )",
        "info": "Returns the floating point result of dividing the num1 by the num2.If the num2 is zero, then one of INF,-INF, or NAN will be returned."
    },
    "ƒ: microtime": {
        "type": "function",
        "label": "microtime( $as_float:bool )",
        "apply": "microtime( $as_float:bool )",
        "info": "microtime() returns the current Unix timestamp with microseconds. This function is only available on operating systems that support the gettimeofday() system call."
    },
    "ƒ: gettimeofday": {
        "type": "function",
        "label": "gettimeofday( $as_float:bool )",
        "apply": "gettimeofday( $as_float:bool )",
        "info": "This is an interface to gettimeofday(2). It returns an associative array containing the data returned from the system call."
    },
    "ƒ: getrusage": {
        "type": "function",
        "label": "getrusage( $mode:int )",
        "apply": "getrusage( $mode:int )",
        "info": "This is an interface to getrusage(2). It gets data returned from the system call. "
    },
    "ƒ: pack": {
        "type": "function",
        "label": "pack( $format:string, $values:mixed )",
        "apply": "pack( $format:string, $values:mixed )",
        "info": "Pack given arguments into a binary string according to format. "
    },
    "ƒ: unpack": {
        "type": "function",
        "label": "unpack( $format:string, $string:string, $offset:int )",
        "apply": "unpack( $format:string, $string:string, $offset:int )",
        "info": "Unpacks from a binary string into an array according to the given format. "
    },
    "ƒ: password_get_info": {
        "type": "function",
        "label": "password_get_info( $hash:string )",
        "apply": "password_get_info( $hash:string )",
        "info": "When passed in a valid hash created by an algorithm supported by password_hash(), this function will return an array of information about that hash."
    },
    "ƒ: password_hash": {
        "type": "function",
        "label": "password_hash( $password:string, $algo:string|int|null, $options:array )",
        "apply": "password_hash( $password:string, $algo:string|int|null, $options:array )",
        "info": "password_hash() creates a new password hash using a strong one-way hashing algorithm."
    },
    "ƒ: password_needs_rehash": {
        "type": "function",
        "label": "password_needs_rehash( $hash:string, $algo:string|int|null, $options:array )",
        "apply": "password_needs_rehash( $hash:string, $algo:string|int|null, $options:array )",
        "info": "This function checks to see if the supplied hash implements the algorithm and options provided. If not, it is assumed that the hash needs to be rehashed."
    },
    "ƒ: password_verify": {
        "type": "function",
        "label": "password_verify( $password:string, $hash:string )",
        "apply": "password_verify( $password:string, $hash:string )",
        "info": "Verifies that the given hash matches the given password.password_verify() is compatible with crypt().Therefore, password hashes created by crypt() can be used with password_verify()."
    },
    "ƒ: password_algos": {
        "type": "function",
        "label": "password_algos()",
        "apply": "password_algos()",
        "info": "Returns a complete list of all registered password hashing algorithm IDs as an array of strings."
    },
    "ƒ: proc_open": {
        "type": "function",
        "label": "proc_open( $command:array|string, $descriptor_spec:array, $pipes:, $cwd:?string, $env_vars:?array, $options:?array )",
        "apply": "proc_open( $command:array|string, $descriptor_spec:array, $pipes:, $cwd:?string, $env_vars:?array, $options:?array )",
        "info": "proc_open() is similar to popen()but provides a much greater degree of control over the program execution."
    },
    "ƒ: proc_close": {
        "type": "function",
        "label": "proc_close( $process: )",
        "apply": "proc_close( $process: )",
        "info": "proc_close() is similar to pclose()except that it only works on processes opened by proc_open().proc_close() waits for the process to terminate, and returns its exit code.  Open pipes to that process are closed when this function is called, in order to avoid a deadlock - the child process may not be able to exit while the pipes are open."
    },
    "ƒ: proc_terminate": {
        "type": "function",
        "label": "proc_terminate( $process:, $signal:int )",
        "apply": "proc_terminate( $process:, $signal:int )",
        "info": "Signals a process (created using proc_open()) that it should terminate.proc_terminate() returns immediately and does not wait for the process to terminate."
    },
    "ƒ: proc_get_status": {
        "type": "function",
        "label": "proc_get_status( $process: )",
        "apply": "proc_get_status( $process: )",
        "info": "proc_get_status() fetches data about a process opened using proc_open()."
    },
    "ƒ: quoted_printable_decode": {
        "type": "function",
        "label": "quoted_printable_decode( $string:string )",
        "apply": "quoted_printable_decode( $string:string )",
        "info": "This function returns an 8-bit binary string corresponding to the decoded quoted printable string (according to \u00bb\u00a0RFC2045, section 6.7, not \u00bb\u00a0RFC2821, section 4.5.2, so additional periods are not stripped from the beginning of line)."
    },
    "ƒ: quoted_printable_encode": {
        "type": "function",
        "label": "quoted_printable_encode( $string:string )",
        "apply": "quoted_printable_encode( $string:string )",
        "info": "Returns a quoted printable string created according to \u00bb\u00a0RFC2045, section 6.7."
    },
    "ƒ: mt_srand": {
        "type": "function",
        "label": "mt_srand( $seed:int, $mode:int )",
        "apply": "mt_srand( $seed:int, $mode:int )",
        "info": "Seeds the random number generator with seed or with a random value if no seed is given."
    },
    "ƒ: srand": {
        "type": "function",
        "label": "srand( $seed:int, $mode:int )",
        "apply": "srand( $seed:int, $mode:int )",
        "info": "Seeds the random number generator with seed or with a random value if seed is 0."
    },
    "ƒ: rand": {
        "type": "function",
        "label": "rand( $min:int, $max:int )",
        "apply": "rand( $min:int, $max:int )",
        "info": "If called without the optional min,max arguments rand()returns a pseudo-random integer between 0 and getrandmax().  If you want a random number between 5 and 15 (inclusive), for example, use rand(5,15)."
    },
    "ƒ: mt_rand": {
        "type": "function",
        "label": "mt_rand( $min:int, $max:int )",
        "apply": "mt_rand( $min:int, $max:int )",
        "info": "Many random number generators of older libcs have dubious or unknown characteristics and are slow.The mt_rand() function is a drop-in replacement for the older rand(). It uses a random number generator with known characteristics using the \u00bb\u00a0Mersenne Twister, which will produce random numbers four times faster than what the average libc rand() provides."
    },
    "ƒ: mt_getrandmax": {
        "type": "function",
        "label": "mt_getrandmax()",
        "apply": "mt_getrandmax()",
        "info": "Returns the maximum value that can be returned by a call to mt_rand()."
    },
    "ƒ: getrandmax": {
        "type": "function",
        "label": "getrandmax()",
        "apply": "getrandmax()",
        "info": "Returns the maximum value that can be returned by a call to rand()."
    },
    "ƒ: random_bytes": {
        "type": "function",
        "label": "random_bytes( $length:int )",
        "apply": "random_bytes( $length:int )",
        "info": "Generates an arbitrary length string of cryptographic random bytes that are suitable for cryptographic use, such as when generating salts, keys or initialization vectors."
    },
    "ƒ: random_int": {
        "type": "function",
        "label": "random_int( $min:int, $max:int )",
        "apply": "random_int( $min:int, $max:int )",
        "info": "Generates cryptographic random integers that are suitable for use where unbiased results are critical, such as when shuffling a deck of cards for a poker game."
    },
    "ƒ: soundex": {
        "type": "function",
        "label": "soundex( $string:string )",
        "apply": "soundex( $string:string )",
        "info": "Calculates the soundex key of string."
    },
    "ƒ: stream_select": {
        "type": "function",
        "label": "stream_select( $read:?array, $write:?array, $except:?array, $seconds:?int, $microseconds:?int )",
        "apply": "stream_select( $read:?array, $write:?array, $except:?array, $seconds:?int, $microseconds:?int )",
        "info": "The stream_select() function accepts arrays of streams and waits for them to change status. Its operation is equivalent to that of the socket_select() function except in that it acts on streams."
    },
    "ƒ: stream_context_create": {
        "type": "function",
        "label": "stream_context_create( $options:?array, $params:?array )",
        "apply": "stream_context_create( $options:?array, $params:?array )",
        "info": "Creates and returns a stream context with any options supplied in options preset."
    },
    "ƒ: stream_context_set_params": {
        "type": "function",
        "label": "stream_context_set_params( $context:, $params:array )",
        "apply": "stream_context_set_params( $context:, $params:array )",
        "info": "Sets parameters on the specified context."
    },
    "ƒ: stream_context_get_params": {
        "type": "function",
        "label": "stream_context_get_params( $context: )",
        "apply": "stream_context_get_params( $context: )",
        "info": "Retrieves parameter and options information from the stream or context."
    },
    "ƒ: stream_context_set_option": {
        "type": "function",
        "label": "stream_context_set_option( $context:, $wrapper_or_options:array|string, $option_name:?string, $value:mixed )",
        "apply": "stream_context_set_option( $context:, $wrapper_or_options:array|string, $option_name:?string, $value:mixed )",
        "info": "Sets an option on the specified context.  value is set to option for wrapper "
    },
    "ƒ: stream_context_get_options": {
        "type": "function",
        "label": "stream_context_get_options( $stream_or_context: )",
        "apply": "stream_context_get_options( $stream_or_context: )",
        "info": "Returns an array of options on the specified stream or context."
    },
    "ƒ: stream_context_get_default": {
        "type": "function",
        "label": "stream_context_get_default( $options:?array )",
        "apply": "stream_context_get_default( $options:?array )",
        "info": "Returns the default stream context which is used whenever file operations (fopen(), file_get_contents(), etc...)are called without a context parameter.  Options for the default context can optionally be specified with this function using the same syntax as stream_context_create()."
    },
    "ƒ: stream_context_set_default": {
        "type": "function",
        "label": "stream_context_set_default( $options:array )",
        "apply": "stream_context_set_default( $options:array )",
        "info": "Set the default stream context which will be used whenever file operations (fopen(), file_get_contents(), etc...)are called without a context parameter. Uses the same syntax as stream_context_create()."
    },
    "ƒ: stream_filter_prepend": {
        "type": "function",
        "label": "stream_filter_prepend( $stream:, $filter_name:string, $mode:int, $params:mixed )",
        "apply": "stream_filter_prepend( $stream:, $filter_name:string, $mode:int, $params:mixed )",
        "info": "Adds filtername to the list of filters attached to stream."
    },
    "ƒ: stream_filter_append": {
        "type": "function",
        "label": "stream_filter_append( $stream:, $filter_name:string, $mode:int, $params:mixed )",
        "apply": "stream_filter_append( $stream:, $filter_name:string, $mode:int, $params:mixed )",
        "info": "Adds filtername to the list of filters attached to stream.  "
    },
    "ƒ: stream_filter_remove": {
        "type": "function",
        "label": "stream_filter_remove( $stream_filter: )",
        "apply": "stream_filter_remove( $stream_filter: )",
        "info": "Removes a stream filter previously added to a stream with stream_filter_prepend() or stream_filter_append().  Any data remaining in the filter's internal buffer will be flushed through to the next filter before removing it."
    },
    "ƒ: stream_socket_client": {
        "type": "function",
        "label": "stream_socket_client( $address:string, $error_code:, $error_message:, $timeout:?float, $flags:int, $context: )",
        "apply": "stream_socket_client( $address:string, $error_code:, $error_message:, $timeout:?float, $flags:int, $context: )",
        "info": "Initiates a stream or datagram connection to the destination specified by address.  The type of socket created is determined by the transport specified using standard URL formatting:transport:\/\/target.  For Internet Domain sockets (AF_INET) such as TCP and UDP, the target portion of the address parameter should consist of a hostname or IP address followed by a colon and a port number.  For Unix domain sockets, the target portion should point to the socket file on the filesystem."
    },
    "ƒ: stream_socket_server": {
        "type": "function",
        "label": "stream_socket_server( $address:string, $error_code:, $error_message:, $flags:int, $context: )",
        "apply": "stream_socket_server( $address:string, $error_code:, $error_message:, $flags:int, $context: )",
        "info": "Creates a stream or datagram socket on the specified address.    "
    },
    "ƒ: stream_socket_accept": {
        "type": "function",
        "label": "stream_socket_accept( $socket:, $timeout:?float, $peer_name: )",
        "apply": "stream_socket_accept( $socket:, $timeout:?float, $peer_name: )",
        "info": "Accept a connection on a socket previously created by stream_socket_server()."
    },
    "ƒ: stream_socket_get_name": {
        "type": "function",
        "label": "stream_socket_get_name( $socket:, $remote:bool )",
        "apply": "stream_socket_get_name( $socket:, $remote:bool )",
        "info": "Returns the local or remote name of a given socket connection."
    },
    "ƒ: stream_socket_recvfrom": {
        "type": "function",
        "label": "stream_socket_recvfrom( $socket:, $length:int, $flags:int, $address: )",
        "apply": "stream_socket_recvfrom( $socket:, $length:int, $flags:int, $address: )",
        "info": "stream_socket_recvfrom() accepts data from a remote socket up to length bytes."
    },
    "ƒ: stream_socket_sendto": {
        "type": "function",
        "label": "stream_socket_sendto( $socket:, $data:string, $flags:int, $address:string )",
        "apply": "stream_socket_sendto( $socket:, $data:string, $flags:int, $address:string )",
        "info": "Sends the specified data through the socket.  "
    },
    "ƒ: stream_socket_enable_crypto": {
        "type": "function",
        "label": "stream_socket_enable_crypto( $stream:, $enable:bool, $crypto_method:?int, $session_stream: )",
        "apply": "stream_socket_enable_crypto( $stream:, $enable:bool, $crypto_method:?int, $session_stream: )",
        "info": "Enable or disable encryption on the stream."
    },
    "ƒ: stream_socket_shutdown": {
        "type": "function",
        "label": "stream_socket_shutdown( $stream:, $mode:int )",
        "apply": "stream_socket_shutdown( $stream:, $mode:int )",
        "info": "Shutdowns (partially or not) a full-duplex connection."
    },
    "ƒ: stream_socket_pair": {
        "type": "function",
        "label": "stream_socket_pair( $domain:int, $type:int, $protocol:int )",
        "apply": "stream_socket_pair( $domain:int, $type:int, $protocol:int )",
        "info": "stream_socket_pair() creates a pair of connected,indistinguishable socket streams. This function is commonly used in IPC (Inter-Process Communication).     "
    },
    "ƒ: stream_copy_to_stream": {
        "type": "function",
        "label": "stream_copy_to_stream( $from:, $to:, $length:?int, $offset:int )",
        "apply": "stream_copy_to_stream( $from:, $to:, $length:?int, $offset:int )",
        "info": "Makes a copy of up to length bytes of data from the current position (or from the offset position, if specified) in from to to. If length is null, all remaining content in from will be copied."
    },
    "ƒ: stream_get_contents": {
        "type": "function",
        "label": "stream_get_contents( $stream:, $length:?int, $offset:int )",
        "apply": "stream_get_contents( $stream:, $length:?int, $offset:int )",
        "info": " Identical to file_get_contents(), except that stream_get_contents() operates on an already open stream resource and returns the remaining contents in a string, up to length bytes and starting at the specified offset."
    },
    "ƒ: stream_supports_lock": {
        "type": "function",
        "label": "stream_supports_lock( $stream: )",
        "apply": "stream_supports_lock( $stream: )",
        "info": "Tells whether the stream supports locking through flock()."
    },
    "ƒ: stream_set_write_buffer": {
        "type": "function",
        "label": "stream_set_write_buffer( $stream:, $size:int )",
        "apply": "stream_set_write_buffer( $stream:, $size:int )",
        "info": "Sets the buffering for write operations on the given stream to size bytes."
    },
    "ƒ: set_file_buffer": {
        "type": "function",
        "label": "set_file_buffer( $stream:, $size:int )",
        "apply": "set_file_buffer( $stream:, $size:int )",
        "info": "This function is an alias of: stream_set_write_buffer()."
    },
    "ƒ: stream_set_read_buffer": {
        "type": "function",
        "label": "stream_set_read_buffer( $stream:, $size:int )",
        "apply": "stream_set_read_buffer( $stream:, $size:int )",
        "info": "Sets the read buffer. It's the equivalent of stream_set_write_buffer(),but for read operations."
    },
    "ƒ: stream_set_blocking": {
        "type": "function",
        "label": "stream_set_blocking( $stream:, $enable:bool )",
        "apply": "stream_set_blocking( $stream:, $enable:bool )",
        "info": "Sets blocking or non-blocking mode on a stream."
    },
    "ƒ: socket_set_blocking": {
        "type": "function",
        "label": "socket_set_blocking( $stream:, $enable:bool )",
        "apply": "socket_set_blocking( $stream:, $enable:bool )",
        "info": "This function is an alias of:  stream_set_blocking()."
    },
    "ƒ: stream_get_meta_data": {
        "type": "function",
        "label": "stream_get_meta_data( $stream: )",
        "apply": "stream_get_meta_data( $stream: )",
        "info": "Returns information about an existing stream."
    },
    "ƒ: socket_get_status": {
        "type": "function",
        "label": "socket_get_status( $stream: )",
        "apply": "socket_get_status( $stream: )",
        "info": "This function is an alias of: stream_get_meta_data()."
    },
    "ƒ: stream_get_line": {
        "type": "function",
        "label": "stream_get_line( $stream:, $length:int, $ending:string )",
        "apply": "stream_get_line( $stream:, $length:int, $ending:string )",
        "info": "Gets a line from the given handle."
    },
    "ƒ: stream_resolve_include_path": {
        "type": "function",
        "label": "stream_resolve_include_path( $filename:string )",
        "apply": "stream_resolve_include_path( $filename:string )",
        "info": "Resolve filename against the include path according to the same rules as fopen()\/include."
    },
    "ƒ: stream_get_wrappers": {
        "type": "function",
        "label": "stream_get_wrappers()",
        "apply": "stream_get_wrappers()",
        "info": "Retrieve list of registered streams available on the running system."
    },
    "ƒ: stream_get_transports": {
        "type": "function",
        "label": "stream_get_transports()",
        "apply": "stream_get_transports()",
        "info": "Returns an indexed array containing the name of all socket transports available on the running system."
    },
    "ƒ: stream_is_local": {
        "type": "function",
        "label": "stream_is_local( $stream: )",
        "apply": "stream_is_local( $stream: )",
        "info": "Checks if a stream, or a URL, is a local one or not."
    },
    "ƒ: stream_isatty": {
        "type": "function",
        "label": "stream_isatty( $stream: )",
        "apply": "stream_isatty( $stream: )",
        "info": "Determines if stream stream refers to a valid terminal type device.This is a more portable version of posix_isatty(), since it works on Windows systems too."
    },
    "ƒ: stream_set_chunk_size": {
        "type": "function",
        "label": "stream_set_chunk_size( $stream:, $size:int )",
        "apply": "stream_set_chunk_size( $stream:, $size:int )",
        "info": "Set the stream chunk size."
    },
    "ƒ: stream_set_timeout": {
        "type": "function",
        "label": "stream_set_timeout( $stream:, $seconds:int, $microseconds:int )",
        "apply": "stream_set_timeout( $stream:, $seconds:int, $microseconds:int )",
        "info": "Sets the timeout value on stream,expressed in the sum of seconds and microseconds. "
    },
    "ƒ: socket_set_timeout": {
        "type": "function",
        "label": "socket_set_timeout( $stream:, $seconds:int, $microseconds:int )",
        "apply": "socket_set_timeout( $stream:, $seconds:int, $microseconds:int )",
        "info": "This function is an alias of: stream_set_timeout()."
    },
    "ƒ: gettype": {
        "type": "function",
        "label": "gettype( $value:mixed )",
        "apply": "gettype( $value:mixed )",
        "info": "Returns the type of the PHP variable value. For type checking, use is_* functions."
    },
    "ƒ: get_debug_type": {
        "type": "function",
        "label": "get_debug_type( $value:mixed )",
        "apply": "get_debug_type( $value:mixed )",
        "info": "Returns the resolved name of the PHP variable value.This function will resolve objects to their class name, resources to their resource type name, and scalar values to their common name as would be used in type declarations."
    },
    "ƒ: settype": {
        "type": "function",
        "label": "settype( $var:mixed, $type:string )",
        "apply": "settype( $var:mixed, $type:string )",
        "info": "Set the type of variable var to type."
    },
    "ƒ: intval": {
        "type": "function",
        "label": "intval( $value:mixed, $base:int )",
        "apply": "intval( $value:mixed, $base:int )",
        "info": "Returns the int value of value,using the specified base for the conversion (the default is base 10). intval() should not be used on objects, as doing so will emit an E_WARNING level error and return 1."
    },
    "ƒ: floatval": {
        "type": "function",
        "label": "floatval( $value:mixed )",
        "apply": "floatval( $value:mixed )",
        "info": "Gets the float value of value."
    },
    "ƒ: doubleval": {
        "type": "function",
        "label": "doubleval( $value:mixed )",
        "apply": "doubleval( $value:mixed )",
        "info": "This function is an alias of: floatval()."
    },
    "ƒ: boolval": {
        "type": "function",
        "label": "boolval( $value:mixed )",
        "apply": "boolval( $value:mixed )",
        "info": "Returns the bool value of value."
    },
    "ƒ: strval": {
        "type": "function",
        "label": "strval( $value:mixed )",
        "apply": "strval( $value:mixed )",
        "info": "Get the string value of a variable.See the documentation on string for more information on converting to string."
    },
    "ƒ: is_null": {
        "type": "function",
        "label": "is_null( $value:mixed )",
        "apply": "is_null( $value:mixed )",
        "info": "Finds whether the given variable is null."
    },
    "ƒ: is_resource": {
        "type": "function",
        "label": "is_resource( $value:mixed )",
        "apply": "is_resource( $value:mixed )",
        "info": "Finds whether the given variable is a resource."
    },
    "ƒ: is_bool": {
        "type": "function",
        "label": "is_bool( $value:mixed )",
        "apply": "is_bool( $value:mixed )",
        "info": "Finds whether the given variable is a boolean."
    },
    "ƒ: is_int": {
        "type": "function",
        "label": "is_int( $value:mixed )",
        "apply": "is_int( $value:mixed )",
        "info": "Finds whether the type of the given variable is integer."
    },
    "ƒ: is_integer": {
        "type": "function",
        "label": "is_integer( $value:mixed )",
        "apply": "is_integer( $value:mixed )",
        "info": "This function is an alias of: is_int()."
    },
    "ƒ: is_long": {
        "type": "function",
        "label": "is_long( $value:mixed )",
        "apply": "is_long( $value:mixed )",
        "info": "This function is an alias of: is_int()."
    },
    "ƒ: is_float": {
        "type": "function",
        "label": "is_float( $value:mixed )",
        "apply": "is_float( $value:mixed )",
        "info": "Finds whether the type of the given variable is float."
    },
    "ƒ: is_double": {
        "type": "function",
        "label": "is_double( $value:mixed )",
        "apply": "is_double( $value:mixed )",
        "info": "This function is an alias of: is_float()."
    },
    "ƒ: is_numeric": {
        "type": "function",
        "label": "is_numeric( $value:mixed )",
        "apply": "is_numeric( $value:mixed )",
        "info": "Determines if the given variable is a number or a numeric string."
    },
    "ƒ: is_string": {
        "type": "function",
        "label": "is_string( $value:mixed )",
        "apply": "is_string( $value:mixed )",
        "info": "Finds whether the type of the given variable is string."
    },
    "ƒ: is_array": {
        "type": "function",
        "label": "is_array( $value:mixed )",
        "apply": "is_array( $value:mixed )",
        "info": "Finds whether the given variable is an array."
    },
    "ƒ: is_object": {
        "type": "function",
        "label": "is_object( $value:mixed )",
        "apply": "is_object( $value:mixed )",
        "info": "Finds whether the given variable is an object."
    },
    "ƒ: is_scalar": {
        "type": "function",
        "label": "is_scalar( $value:mixed )",
        "apply": "is_scalar( $value:mixed )",
        "info": "Finds whether the given variable is a scalar."
    },
    "ƒ: is_callable": {
        "type": "function",
        "label": "is_callable( $value:mixed, $syntax_only:bool, $callable_name: )",
        "apply": "is_callable( $value:mixed, $syntax_only:bool, $callable_name: )",
        "info": "Verify that a value is a callable."
    },
    "ƒ: is_iterable": {
        "type": "function",
        "label": "is_iterable( $value:mixed )",
        "apply": "is_iterable( $value:mixed )",
        "info": "Verify that the contents of a variable is accepted by the iterable pseudo-type, i.e. that it is either an array or an object implementing Traversable "
    },
    "ƒ: is_countable": {
        "type": "function",
        "label": "is_countable( $value:mixed )",
        "apply": "is_countable( $value:mixed )",
        "info": "Verify that the contents of a variable is an array or an object implementing Countable "
    },
    "ƒ: uniqid": {
        "type": "function",
        "label": "uniqid( $prefix:string, $more_entropy:bool )",
        "apply": "uniqid( $prefix:string, $more_entropy:bool )",
        "info": "Gets a prefixed unique identifier based on the current time in microseconds."
    },
    "ƒ: parse_url": {
        "type": "function",
        "label": "parse_url( $url:string, $component:int )",
        "apply": "parse_url( $url:string, $component:int )",
        "info": "This function parses a URL and returns an associative array containing any of the various components of the URL that are present.The values of the array elements are not URL decoded."
    },
    "ƒ: urlencode": {
        "type": "function",
        "label": "urlencode( $string:string )",
        "apply": "urlencode( $string:string )",
        "info": "This function is convenient when encoding a string to be used in a query part of a URL, as a convenient way to pass variables to the next page."
    },
    "ƒ: urldecode": {
        "type": "function",
        "label": "urldecode( $string:string )",
        "apply": "urldecode( $string:string )",
        "info": "Decodes any %##encoding in the given string. Plus symbols ('+') are decoded to a space character."
    },
    "ƒ: rawurlencode": {
        "type": "function",
        "label": "rawurlencode( $string:string )",
        "apply": "rawurlencode( $string:string )",
        "info": "Encodes the given string according to \u00bb\u00a0RFC 3986."
    },
    "ƒ: rawurldecode": {
        "type": "function",
        "label": "rawurldecode( $string:string )",
        "apply": "rawurldecode( $string:string )",
        "info": "Returns a string in which the sequences with percent (%) signs followed by two hex digits have been replaced with literal characters."
    },
    "ƒ: get_headers": {
        "type": "function",
        "label": "get_headers( $url:string, $associative:bool, $context: )",
        "apply": "get_headers( $url:string, $associative:bool, $context: )",
        "info": "get_headers() returns an array with the headers sent by the server in response to a HTTP request."
    },
    "ƒ: stream_bucket_make_writeable": {
        "type": "function",
        "label": "stream_bucket_make_writeable( $brigade: )",
        "apply": "stream_bucket_make_writeable( $brigade: )",
        "info": "This function is called whenever there is the need to access and operate on the content contains in a brigade. It is typically called from php_user_filter::filter()."
    },
    "ƒ: stream_bucket_prepend": {
        "type": "function",
        "label": "stream_bucket_prepend( $brigade:, $bucket:object )",
        "apply": "stream_bucket_prepend( $brigade:, $bucket:object )",
        "info": "This function can be called to prepend a bucket to a bucket brigade. It is typically called from php_user_filter::filter()."
    },
    "ƒ: stream_bucket_append": {
        "type": "function",
        "label": "stream_bucket_append( $brigade:, $bucket:object )",
        "apply": "stream_bucket_append( $brigade:, $bucket:object )",
        "info": "This function is currently not documented; only its argument list is available."
    },
    "ƒ: stream_bucket_new": {
        "type": "function",
        "label": "stream_bucket_new( $stream:, $buffer:string )",
        "apply": "stream_bucket_new( $stream:, $buffer:string )",
        "info": "This function is currently not documented; only its argument list is available."
    },
    "ƒ: stream_get_filters": {
        "type": "function",
        "label": "stream_get_filters()",
        "apply": "stream_get_filters()",
        "info": "Retrieve the list of registered filters on the running system."
    },
    "ƒ: stream_filter_register": {
        "type": "function",
        "label": "stream_filter_register( $filter_name:string, $class:string )",
        "apply": "stream_filter_register( $filter_name:string, $class:string )",
        "info": "stream_filter_register() allows you to implement your own filter on any registered stream used with all the other filesystem functions (such as fopen(),fread() etc.)."
    },
    "ƒ: convert_uuencode": {
        "type": "function",
        "label": "convert_uuencode( $string:string )",
        "apply": "convert_uuencode( $string:string )",
        "info": "convert_uuencode() encodes a string using the uuencode algorithm."
    },
    "ƒ: convert_uudecode": {
        "type": "function",
        "label": "convert_uudecode( $string:string )",
        "apply": "convert_uudecode( $string:string )",
        "info": "convert_uudecode() decodes a uuencoded string."
    },
    "ƒ: var_dump": {
        "type": "function",
        "label": "var_dump( $value:mixed, $values:mixed )",
        "apply": "var_dump( $value:mixed, $values:mixed )",
        "info": "This function displays structured information about one or more expressions that includes its type and value. Arrays and objects are explored recursively with values indented to show structure."
    },
    "ƒ: var_export": {
        "type": "function",
        "label": "var_export( $value:mixed, $return:bool )",
        "apply": "var_export( $value:mixed, $return:bool )",
        "info": "var_export() gets structured information about the given variable. It is similar to var_dump()with one exception: the returned representation is valid PHP code."
    },
    "ƒ: debug_zval_dump": {
        "type": "function",
        "label": "debug_zval_dump( $value:mixed, $values:mixed )",
        "apply": "debug_zval_dump( $value:mixed, $values:mixed )",
        "info": "Dumps a string representation of an internal zval (Zend value) structure to output.This is mostly useful for understanding or debugging implementation details of the Zend Engine or PHP extensions."
    },
    "ƒ: serialize": {
        "type": "function",
        "label": "serialize( $value:mixed )",
        "apply": "serialize( $value:mixed )",
        "info": "Generates a storable representation of a value."
    },
    "ƒ: unserialize": {
        "type": "function",
        "label": "unserialize( $data:string, $options:array )",
        "apply": "unserialize( $data:string, $options:array )",
        "info": "unserialize() takes a single serialized variable and converts it back into a PHP value.  "
    },
    "ƒ: memory_get_usage": {
        "type": "function",
        "label": "memory_get_usage( $real_usage:bool )",
        "apply": "memory_get_usage( $real_usage:bool )",
        "info": "Returns the amount of memory, in bytes, that's currently being allocated to your PHP script."
    },
    "ƒ: memory_get_peak_usage": {
        "type": "function",
        "label": "memory_get_peak_usage( $real_usage:bool )",
        "apply": "memory_get_peak_usage( $real_usage:bool )",
        "info": "Returns the peak of memory, in bytes, that's been allocated to your PHP script."
    },
    "ƒ: version_compare": {
        "type": "function",
        "label": "version_compare( $version1:string, $version2:string, $operator:?string )",
        "apply": "version_compare( $version1:string, $version2:string, $operator:?string )",
        "info": "version_compare() compares two \"PHP-standardized\"version number strings."
    },
    "ƒ: class_implements": {
        "type": "function",
        "label": "class_implements( $object_or_class:, $autoload:bool )",
        "apply": "class_implements( $object_or_class:, $autoload:bool )",
        "info": "This function returns an array with the names of the interfaces that the given object_or_class and its parents implement."
    },
    "ƒ: class_parents": {
        "type": "function",
        "label": "class_parents( $object_or_class:, $autoload:bool )",
        "apply": "class_parents( $object_or_class:, $autoload:bool )",
        "info": "This function returns an array with the name of the parent classes of the given object_or_class."
    },
    "ƒ: class_uses": {
        "type": "function",
        "label": "class_uses( $object_or_class:, $autoload:bool )",
        "apply": "class_uses( $object_or_class:, $autoload:bool )",
        "info": "This function returns an array with the names of the traits that the given object_or_class uses. This does however not include any traits used by a parent class."
    },
    "ƒ: spl_autoload": {
        "type": "function",
        "label": "spl_autoload( $class:string, $file_extensions:?string )",
        "apply": "spl_autoload( $class:string, $file_extensions:?string )",
        "info": "This function is intended to be used as a default implementation for __autoload(). If nothing else is specified and spl_autoload_register() is called without any parameters then this function will be used for any later call to __autoload(). "
    },
    "ƒ: spl_autoload_call": {
        "type": "function",
        "label": "spl_autoload_call( $class:string )",
        "apply": "spl_autoload_call( $class:string )",
        "info": "This function can be used to manually search for a class or interface using the registered __autoload functions."
    },
    "ƒ: spl_autoload_extensions": {
        "type": "function",
        "label": "spl_autoload_extensions( $file_extensions:?string )",
        "apply": "spl_autoload_extensions( $file_extensions:?string )",
        "info": "This function can modify and check the file extensions that the built in __autoload() fallback function spl_autoload() will be using."
    },
    "ƒ: spl_autoload_functions": {
        "type": "function",
        "label": "spl_autoload_functions()",
        "apply": "spl_autoload_functions()",
        "info": "Get all registered __autoload() functions."
    },
    "ƒ: spl_autoload_register": {
        "type": "function",
        "label": "spl_autoload_register( $callback:?callable, $throw:bool, $prepend:bool )",
        "apply": "spl_autoload_register( $callback:?callable, $throw:bool, $prepend:bool )",
        "info": "Register a function with the spl provided __autoload queue. If the queue is not yet activated it will be activated.  "
    },
    "ƒ: spl_autoload_unregister": {
        "type": "function",
        "label": "spl_autoload_unregister( $callback:callable )",
        "apply": "spl_autoload_unregister( $callback:callable )",
        "info": "Removes a function from the autoload queue. If the queue is activated and empty after removing the given function then it will be deactivated."
    },
    "ƒ: spl_classes": {
        "type": "function",
        "label": "spl_classes()",
        "apply": "spl_classes()",
        "info": "This function returns an array with the current available SPL classes."
    },
    "ƒ: spl_object_hash": {
        "type": "function",
        "label": "spl_object_hash( $object:object )",
        "apply": "spl_object_hash( $object:object )",
        "info": "This function returns a unique identifier for the object. This id can be used as a hash key for storing objects, or for identifying an object, as long as the object is not destroyed. Once the object is destroyed, its hash may be reused for other objects. This behavior is similar to spl_object_id()."
    },
    "ƒ: spl_object_id": {
        "type": "function",
        "label": "spl_object_id( $object:object )",
        "apply": "spl_object_id( $object:object )",
        "info": "This function returns a unique identifier for the object. The object id is unique for the lifetime of the object. Once the object is destroyed, its id may be reused for other objects. This behavior is similar to spl_object_hash()."
    },
    "ƒ: iterator_apply": {
        "type": "function",
        "label": "iterator_apply( $iterator:Traversable, $callback:callable, $args:?array )",
        "apply": "iterator_apply( $iterator:Traversable, $callback:callable, $args:?array )",
        "info": "Calls a function for every element in an iterator."
    },
    "ƒ: iterator_count": {
        "type": "function",
        "label": "iterator_count( $iterator:Traversable )",
        "apply": "iterator_count( $iterator:Traversable )",
        "info": "Count the elements in an iterator.iterator_count() is not guaranteed to retain the current position of the iterator."
    },
    "ƒ: iterator_to_array": {
        "type": "function",
        "label": "iterator_to_array( $iterator:Traversable, $preserve_keys:bool )",
        "apply": "iterator_to_array( $iterator:Traversable, $preserve_keys:bool )",
        "info": "Copy the elements of an iterator into an array."
    },
    "ƒ: posix_kill": {
        "type": "function",
        "label": "posix_kill( $process_id:int, $signal:int )",
        "apply": "posix_kill( $process_id:int, $signal:int )",
        "info": "Send the signal signal to the process with the process identifier process_id."
    },
    "ƒ: posix_getpid": {
        "type": "function",
        "label": "posix_getpid()",
        "apply": "posix_getpid()",
        "info": "Return the process identifier of the current process."
    },
    "ƒ: posix_getppid": {
        "type": "function",
        "label": "posix_getppid()",
        "apply": "posix_getppid()",
        "info": "Return the process identifier of the parent process of the current process."
    },
    "ƒ: posix_getuid": {
        "type": "function",
        "label": "posix_getuid()",
        "apply": "posix_getuid()",
        "info": "Return the numeric real user ID of the current process. "
    },
    "ƒ: posix_setuid": {
        "type": "function",
        "label": "posix_setuid( $user_id:int )",
        "apply": "posix_setuid( $user_id:int )",
        "info": "Set the real user ID of the current process. This is a privileged function that needs appropriate privileges (usually root) on the system to be able to perform this function."
    },
    "ƒ: posix_geteuid": {
        "type": "function",
        "label": "posix_geteuid()",
        "apply": "posix_geteuid()",
        "info": "Return the numeric effective user ID of the current process. See also posix_getpwuid() for information on how to convert this into a useable username."
    },
    "ƒ: posix_seteuid": {
        "type": "function",
        "label": "posix_seteuid( $user_id:int )",
        "apply": "posix_seteuid( $user_id:int )",
        "info": "Set the effective user ID of the current process. This is a privileged function and needs appropriate privileges (usually root) on the system to be able to perform this function."
    },
    "ƒ: posix_getgid": {
        "type": "function",
        "label": "posix_getgid()",
        "apply": "posix_getgid()",
        "info": "Return the numeric real group ID of the current process."
    },
    "ƒ: posix_setgid": {
        "type": "function",
        "label": "posix_setgid( $group_id:int )",
        "apply": "posix_setgid( $group_id:int )",
        "info": "Set the real group ID of the current process. This is a privileged function and needs appropriate privileges (usually root) on the system to be able to perform this function. The appropriate order of function calls is posix_setgid() first,posix_setuid() last."
    },
    "ƒ: posix_getegid": {
        "type": "function",
        "label": "posix_getegid()",
        "apply": "posix_getegid()",
        "info": "Return the numeric effective group ID of the current process. "
    },
    "ƒ: posix_setegid": {
        "type": "function",
        "label": "posix_setegid( $group_id:int )",
        "apply": "posix_setegid( $group_id:int )",
        "info": "Set the effective group ID of the current process. This is a privileged function and needs appropriate privileges (usually root) on the system to be able to perform this function."
    },
    "ƒ: posix_getgroups": {
        "type": "function",
        "label": "posix_getgroups()",
        "apply": "posix_getgroups()",
        "info": "Gets the group set of the current process."
    },
    "ƒ: posix_getlogin": {
        "type": "function",
        "label": "posix_getlogin()",
        "apply": "posix_getlogin()",
        "info": "Returns the login name of the user owning the current process."
    },
    "ƒ: posix_getpgrp": {
        "type": "function",
        "label": "posix_getpgrp()",
        "apply": "posix_getpgrp()",
        "info": "Return the process group identifier of the current process. "
    },
    "ƒ: posix_setsid": {
        "type": "function",
        "label": "posix_setsid()",
        "apply": "posix_setsid()",
        "info": "Make the current process a session leader. "
    },
    "ƒ: posix_setpgid": {
        "type": "function",
        "label": "posix_setpgid( $process_id:int, $process_group_id:int )",
        "apply": "posix_setpgid( $process_id:int, $process_group_id:int )",
        "info": "Let the process process_id join the process group process_group_id. "
    },
    "ƒ: posix_getpgid": {
        "type": "function",
        "label": "posix_getpgid( $process_id:int )",
        "apply": "posix_getpgid( $process_id:int )",
        "info": "Returns the process group identifier of the process process_id or false on failure."
    },
    "ƒ: posix_getsid": {
        "type": "function",
        "label": "posix_getsid( $process_id:int )",
        "apply": "posix_getsid( $process_id:int )",
        "info": "Return the session id of the process process_id.The session id of a process is the process group id of the session leader."
    },
    "ƒ: posix_uname": {
        "type": "function",
        "label": "posix_uname()",
        "apply": "posix_uname()",
        "info": "Gets information about the system."
    },
    "ƒ: posix_times": {
        "type": "function",
        "label": "posix_times()",
        "apply": "posix_times()",
        "info": "Gets information about the current CPU usage."
    },
    "ƒ: posix_ctermid": {
        "type": "function",
        "label": "posix_ctermid()",
        "apply": "posix_ctermid()",
        "info": "Generates a string which is the pathname for the current controlling terminal for the process.  On error this will set errno, which can be checked using posix_get_last_error()"
    },
    "ƒ: posix_ttyname": {
        "type": "function",
        "label": "posix_ttyname( $file_descriptor: )",
        "apply": "posix_ttyname( $file_descriptor: )",
        "info": "Returns a string for the absolute path to the current terminal device that is open on the file descriptor file_descriptor."
    },
    "ƒ: posix_isatty": {
        "type": "function",
        "label": "posix_isatty( $file_descriptor: )",
        "apply": "posix_isatty( $file_descriptor: )",
        "info": "Determines if the file descriptor file_descriptor refers to a valid terminal type device."
    },
    "ƒ: posix_getcwd": {
        "type": "function",
        "label": "posix_getcwd()",
        "apply": "posix_getcwd()",
        "info": "Gets the absolute pathname of the script's current working directory.On error, it sets errno which can be checked using posix_get_last_error()"
    },
    "ƒ: posix_mkfifo": {
        "type": "function",
        "label": "posix_mkfifo( $filename:string, $permissions:int )",
        "apply": "posix_mkfifo( $filename:string, $permissions:int )",
        "info": "posix_mkfifo() creates a special FIFO file which exists in the file system and acts as a bidirectional communication endpoint for processes."
    },
    "ƒ: posix_mknod": {
        "type": "function",
        "label": "posix_mknod( $filename:string, $flags:int, $major:int, $minor:int )",
        "apply": "posix_mknod( $filename:string, $flags:int, $major:int, $minor:int )",
        "info": "Creates a special or ordinary file."
    },
    "ƒ: posix_access": {
        "type": "function",
        "label": "posix_access( $filename:string, $flags:int )",
        "apply": "posix_access( $filename:string, $flags:int )",
        "info": "posix_access() checks the user's permission of a file."
    },
    "ƒ: posix_getgrnam": {
        "type": "function",
        "label": "posix_getgrnam( $name:string )",
        "apply": "posix_getgrnam( $name:string )",
        "info": "Gets information about a group provided its name. "
    },
    "ƒ: posix_getgrgid": {
        "type": "function",
        "label": "posix_getgrgid( $group_id:int )",
        "apply": "posix_getgrgid( $group_id:int )",
        "info": "Gets information about a group provided its id."
    },
    "ƒ: posix_getpwnam": {
        "type": "function",
        "label": "posix_getpwnam( $username:string )",
        "apply": "posix_getpwnam( $username:string )",
        "info": "Returns an array of information about the given user."
    },
    "ƒ: posix_getpwuid": {
        "type": "function",
        "label": "posix_getpwuid( $user_id:int )",
        "apply": "posix_getpwuid( $user_id:int )",
        "info": "Returns an array of information about the user referenced by the given user ID."
    },
    "ƒ: posix_getrlimit": {
        "type": "function",
        "label": "posix_getrlimit()",
        "apply": "posix_getrlimit()",
        "info": "posix_getrlimit() returns an array of information about the current resource's soft and hard limits."
    },
    "ƒ: posix_setrlimit": {
        "type": "function",
        "label": "posix_setrlimit( $resource:int, $soft_limit:int, $hard_limit:int )",
        "apply": "posix_setrlimit( $resource:int, $soft_limit:int, $hard_limit:int )",
        "info": "posix_setrlimit() sets the soft and hard limits for a given system resource."
    },
    "ƒ: posix_get_last_error": {
        "type": "function",
        "label": "posix_get_last_error()",
        "apply": "posix_get_last_error()",
        "info": "Retrieve the error number set by the last posix function that failed.The system error message associated with the errno may be checked with posix_strerror()."
    },
    "ƒ: posix_errno": {
        "type": "function",
        "label": "posix_errno()",
        "apply": "posix_errno()",
        "info": "This function is an alias of: posix_get_last_error()."
    },
    "ƒ: posix_strerror": {
        "type": "function",
        "label": "posix_strerror( $error_code:int )",
        "apply": "posix_strerror( $error_code:int )",
        "info": "Returns the POSIX system error message associated with the given error_code.  You may get the error_code parameter by calling posix_get_last_error()."
    },
    "ƒ: posix_initgroups": {
        "type": "function",
        "label": "posix_initgroups( $username:string, $group_id:int )",
        "apply": "posix_initgroups( $username:string, $group_id:int )",
        "info": "Calculates the group access list for the user specified in name."
    },
    "ƒ: session_name": {
        "type": "function",
        "label": "session_name( $name:?string )",
        "apply": "session_name( $name:?string )",
        "info": "session_name() returns the name of the current session. If name is given,session_name() will update the session name and return the old session name."
    },
    "ƒ: session_module_name": {
        "type": "function",
        "label": "session_module_name( $module:?string )",
        "apply": "session_module_name( $module:?string )",
        "info": "session_module_name() gets the name of the current session module, which is also known as session.save_handler."
    },
    "ƒ: session_save_path": {
        "type": "function",
        "label": "session_save_path( $path:?string )",
        "apply": "session_save_path( $path:?string )",
        "info": "session_save_path() returns the path of the current directory used to save session data. "
    },
    "ƒ: session_id": {
        "type": "function",
        "label": "session_id( $id:?string )",
        "apply": "session_id( $id:?string )",
        "info": "session_id() is used to get or set the session id for the current session."
    },
    "ƒ: session_create_id": {
        "type": "function",
        "label": "session_create_id( $prefix:string )",
        "apply": "session_create_id( $prefix:string )",
        "info": "session_create_id() is used to create new session id for the current session. It returns collision free session id."
    },
    "ƒ: session_regenerate_id": {
        "type": "function",
        "label": "session_regenerate_id( $delete_old_session:bool )",
        "apply": "session_regenerate_id( $delete_old_session:bool )",
        "info": "session_regenerate_id() will replace the current session id with a new one, and keep the current session information."
    },
    "ƒ: session_decode": {
        "type": "function",
        "label": "session_decode( $data:string )",
        "apply": "session_decode( $data:string )",
        "info": "session_decode() decodes the serialized session data provided in $data, and populates the $_SESSION superglobal with the result."
    },
    "ƒ: session_encode": {
        "type": "function",
        "label": "session_encode()",
        "apply": "session_encode()",
        "info": "session_encode() returns a serialized string of the contents of the current session data stored in the $_SESSION superglobal."
    },
    "ƒ: session_destroy": {
        "type": "function",
        "label": "session_destroy()",
        "apply": "session_destroy()",
        "info": "session_destroy() destroys all of the data associated with the current session. It does not unset any of the global variables associated with the session, or unset the session cookie.To use the session variables again, session_start() has to be called."
    },
    "ƒ: session_unset": {
        "type": "function",
        "label": "session_unset()",
        "apply": "session_unset()",
        "info": "The session_unset() function frees all session variables currently registered."
    },
    "ƒ: session_gc": {
        "type": "function",
        "label": "session_gc()",
        "apply": "session_gc()",
        "info": "session_gc() is used to perform session data GC(garbage collection). PHP does probability based session GC by default."
    },
    "ƒ: session_get_cookie_params": {
        "type": "function",
        "label": "session_get_cookie_params()",
        "apply": "session_get_cookie_params()",
        "info": "Gets the session cookie parameters."
    },
    "ƒ: session_write_close": {
        "type": "function",
        "label": "session_write_close()",
        "apply": "session_write_close()",
        "info": "End the current session and store session data."
    },
    "ƒ: session_abort": {
        "type": "function",
        "label": "session_abort()",
        "apply": "session_abort()",
        "info": "session_abort() finishes session without saving data. Thus the original values in session data are kept."
    },
    "ƒ: session_reset": {
        "type": "function",
        "label": "session_reset()",
        "apply": "session_reset()",
        "info": "session_reset() reinitializes a session with original values stored in session storage. This function requires an active session and discards changes in $_SESSION."
    },
    "ƒ: session_status": {
        "type": "function",
        "label": "session_status()",
        "apply": "session_status()",
        "info": "session_status() is used to return the current session status."
    },
    "ƒ: session_register_shutdown": {
        "type": "function",
        "label": "session_register_shutdown()",
        "apply": "session_register_shutdown()",
        "info": "Registers session_write_close() as a shutdown function."
    },
    "ƒ: session_commit": {
        "type": "function",
        "label": "session_commit()",
        "apply": "session_commit()",
        "info": "This function is an alias of: session_write_close()."
    },
    "ƒ: session_set_save_handler": {
        "type": "function",
        "label": "session_set_save_handler( $open:, $close:, $read:callable, $write:callable, $destroy:callable, $gc:callable, $create_sid:callable, $validate_sid:callable, $update_timestamp:callable )",
        "apply": "session_set_save_handler( $open:, $close:, $read:callable, $write:callable, $destroy:callable, $gc:callable, $create_sid:callable, $validate_sid:callable, $update_timestamp:callable )",
        "info": "It is possible to register the following prototype:"
    },
    "ƒ: session_cache_limiter": {
        "type": "function",
        "label": "session_cache_limiter( $value:?string )",
        "apply": "session_cache_limiter( $value:?string )",
        "info": "session_cache_limiter() returns the name of the current cache limiter."
    },
    "ƒ: session_cache_expire": {
        "type": "function",
        "label": "session_cache_expire( $value:?int )",
        "apply": "session_cache_expire( $value:?int )",
        "info": "session_cache_expire() returns the current setting of session.cache_expire. "
    },
    "ƒ: session_set_cookie_params": {
        "type": "function",
        "label": "session_set_cookie_params( $lifetime_or_options:array|int, $path:?string, $domain:?string, $secure:?bool, $httponly:?bool )",
        "apply": "session_set_cookie_params( $lifetime_or_options:array|int, $path:?string, $domain:?string, $secure:?bool, $httponly:?bool )",
        "info": "Alternative signature available as of PHP 7.3.0:"
    },
    "ƒ: session_start": {
        "type": "function",
        "label": "session_start( $options:array )",
        "apply": "session_start( $options:array )",
        "info": "session_start() creates a session or resumes the current one based on a session identifier passed via a GET or POST request, or passed via a cookie."
    },
    "ƒ: simplexml_load_file": {
        "type": "function",
        "label": "simplexml_load_file( $filename:string, $class_name:?string, $options:int, $namespace_or_prefix:string, $is_prefix:bool )",
        "apply": "simplexml_load_file( $filename:string, $class_name:?string, $options:int, $namespace_or_prefix:string, $is_prefix:bool )",
        "info": "Convert the well-formed XML document in the given file to an object."
    },
    "ƒ: simplexml_load_string": {
        "type": "function",
        "label": "simplexml_load_string( $data:string, $class_name:?string, $options:int, $namespace_or_prefix:string, $is_prefix:bool )",
        "apply": "simplexml_load_string( $data:string, $class_name:?string, $options:int, $namespace_or_prefix:string, $is_prefix:bool )",
        "info": "Takes a well-formed XML string and returns it as an object."
    },
    "ƒ: simplexml_import_dom": {
        "type": "function",
        "label": "simplexml_import_dom( $node:SimpleXMLElement|DOMNode, $class_name:?string )",
        "apply": "simplexml_import_dom( $node:SimpleXMLElement|DOMNode, $class_name:?string )",
        "info": "This function takes a node of a DOM document and makes it into a SimpleXML node. This new object can then be used as a native SimpleXML element. "
    },
    "ƒ: token_get_all": {
        "type": "function",
        "label": "token_get_all( $code:string, $flags:int )",
        "apply": "token_get_all( $code:string, $flags:int )",
        "info": "token_get_all() parses the given code string into PHP language tokens using the Zend engine's lexical scanner."
    },
    "ƒ: token_name": {
        "type": "function",
        "label": "token_name( $id:int )",
        "apply": "token_name( $id:int )",
        "info": "token_name() gets the symbolic name for a PHP id value. "
    },
    "ƒ: xml_parser_create": {
        "type": "function",
        "label": "xml_parser_create( $encoding:?string )",
        "apply": "xml_parser_create( $encoding:?string )",
        "info": "xml_parser_create() creates a new XML parser and returns a XMLParser instance to be used by the other XML functions."
    },
    "ƒ: xml_parser_create_ns": {
        "type": "function",
        "label": "xml_parser_create_ns( $encoding:?string, $separator:string )",
        "apply": "xml_parser_create_ns( $encoding:?string, $separator:string )",
        "info": "xml_parser_create_ns() creates a new XML parser with XML namespace support and returns a XMLParser instance to be used by the other XML functions."
    },
    "ƒ: xml_set_object": {
        "type": "function",
        "label": "xml_set_object( $parser:XMLParser, $object:object )",
        "apply": "xml_set_object( $parser:XMLParser, $object:object )",
        "info": "This function allows to use parser inside object. All callback functions could be set with xml_set_element_handler() etc and assumed to be methods of object."
    },
    "ƒ: xml_set_element_handler": {
        "type": "function",
        "label": "xml_set_element_handler( $parser:XMLParser, $start_handler:, $end_handler: )",
        "apply": "xml_set_element_handler( $parser:XMLParser, $start_handler:, $end_handler: )",
        "info": "Sets the element handler functions for the XML parser.start_handler and end_handler are strings containing the names of functions that must exist when xml_parse()is called for parser."
    },
    "ƒ: xml_set_character_data_handler": {
        "type": "function",
        "label": "xml_set_character_data_handler( $parser:XMLParser, $handler: )",
        "apply": "xml_set_character_data_handler( $parser:XMLParser, $handler: )",
        "info": "Sets the character data handler function for the XML parser parser."
    },
    "ƒ: xml_set_processing_instruction_handler": {
        "type": "function",
        "label": "xml_set_processing_instruction_handler( $parser:XMLParser, $handler: )",
        "apply": "xml_set_processing_instruction_handler( $parser:XMLParser, $handler: )",
        "info": "Sets the processing instruction (PI) handler function for the XML parser parser."
    },
    "ƒ: xml_set_default_handler": {
        "type": "function",
        "label": "xml_set_default_handler( $parser:XMLParser, $handler: )",
        "apply": "xml_set_default_handler( $parser:XMLParser, $handler: )",
        "info": "Sets the default handler function for the XML parser parser."
    },
    "ƒ: xml_set_unparsed_entity_decl_handler": {
        "type": "function",
        "label": "xml_set_unparsed_entity_decl_handler( $parser:XMLParser, $handler: )",
        "apply": "xml_set_unparsed_entity_decl_handler( $parser:XMLParser, $handler: )",
        "info": "Sets the unparsed entity declaration handler function for the XML parser parser."
    },
    "ƒ: xml_set_notation_decl_handler": {
        "type": "function",
        "label": "xml_set_notation_decl_handler( $parser:XMLParser, $handler: )",
        "apply": "xml_set_notation_decl_handler( $parser:XMLParser, $handler: )",
        "info": "Sets the notation declaration handler function for the XML parser parser."
    },
    "ƒ: xml_set_external_entity_ref_handler": {
        "type": "function",
        "label": "xml_set_external_entity_ref_handler( $parser:XMLParser, $handler: )",
        "apply": "xml_set_external_entity_ref_handler( $parser:XMLParser, $handler: )",
        "info": "Sets the external entity reference handler function for the XML parser parser."
    },
    "ƒ: xml_set_start_namespace_decl_handler": {
        "type": "function",
        "label": "xml_set_start_namespace_decl_handler( $parser:XMLParser, $handler: )",
        "apply": "xml_set_start_namespace_decl_handler( $parser:XMLParser, $handler: )",
        "info": "Set a handler to be called when a namespace is declared. Namespace declarations occur inside start tags. But the namespace declaration start handler is called before the start tag handler for each namespace declared in that start tag."
    },
    "ƒ: xml_set_end_namespace_decl_handler": {
        "type": "function",
        "label": "xml_set_end_namespace_decl_handler( $parser:XMLParser, $handler: )",
        "apply": "xml_set_end_namespace_decl_handler( $parser:XMLParser, $handler: )",
        "info": "Set a handler to be called when leaving the scope of a namespace declaration. This will be called, for each namespace declaration, after the handler for the end tag of the element in which the namespace was declared."
    },
    "ƒ: xml_parse": {
        "type": "function",
        "label": "xml_parse( $parser:XMLParser, $data:string, $is_final:bool )",
        "apply": "xml_parse( $parser:XMLParser, $data:string, $is_final:bool )",
        "info": "xml_parse() parses an XML document. The handlers for the configured events are called as many times as necessary."
    },
    "ƒ: xml_parse_into_struct": {
        "type": "function",
        "label": "xml_parse_into_struct( $parser:XMLParser, $data:string, $values:, $index: )",
        "apply": "xml_parse_into_struct( $parser:XMLParser, $data:string, $values:, $index: )",
        "info": "This function parses an XML string into 2 parallel array structures, one (index) containing pointers to the location of the appropriate values in the values array. These last two parameters must be passed by reference."
    },
    "ƒ: xml_get_error_code": {
        "type": "function",
        "label": "xml_get_error_code( $parser:XMLParser )",
        "apply": "xml_get_error_code( $parser:XMLParser )",
        "info": "Gets the XML parser error code."
    },
    "ƒ: xml_error_string": {
        "type": "function",
        "label": "xml_error_string( $error_code:int )",
        "apply": "xml_error_string( $error_code:int )",
        "info": "Gets the XML parser error string associated with the given error_code."
    },
    "ƒ: xml_get_current_line_number": {
        "type": "function",
        "label": "xml_get_current_line_number( $parser:XMLParser )",
        "apply": "xml_get_current_line_number( $parser:XMLParser )",
        "info": "Gets the current line number for the given XML parser."
    },
    "ƒ: xml_get_current_column_number": {
        "type": "function",
        "label": "xml_get_current_column_number( $parser:XMLParser )",
        "apply": "xml_get_current_column_number( $parser:XMLParser )",
        "info": "Gets the current column number of the given XML parser."
    },
    "ƒ: apache_get_modules": {
        "type": "function",
        "label": "apache_get_modules()",
        "apply": "apache_get_modules()",
        "info": "Get a list of loaded Apache modules."
    },
    "ƒ: bcadd": {
        "type": "function",
        "label": "bcadd( $num1:string, $num2:string, $scale:?int )",
        "apply": "bcadd( $num1:string, $num2:string, $scale:?int )",
        "info": "Sums num1 and num2."
    },
    "ƒ: bcsub": {
        "type": "function",
        "label": "bcsub( $num1:string, $num2:string, $scale:?int )",
        "apply": "bcsub( $num1:string, $num2:string, $scale:?int )",
        "info": "Subtracts the num2 from the num1."
    },
    "ƒ: bcmul": {
        "type": "function",
        "label": "bcmul( $num1:string, $num2:string, $scale:?int )",
        "apply": "bcmul( $num1:string, $num2:string, $scale:?int )",
        "info": "Multiply the num1 by the num2."
    },
    "ƒ: bcdiv": {
        "type": "function",
        "label": "bcdiv( $num1:string, $num2:string, $scale:?int )",
        "apply": "bcdiv( $num1:string, $num2:string, $scale:?int )",
        "info": "Divides the num1 by the num2."
    },
    "ƒ: bcmod": {
        "type": "function",
        "label": "bcmod( $num1:string, $num2:string, $scale:?int )",
        "apply": "bcmod( $num1:string, $num2:string, $scale:?int )",
        "info": "Get the remainder of dividing num1 by num2.Unless num2 is zero, the result has the same sign as num1."
    },
    "ƒ: bcpowmod": {
        "type": "function",
        "label": "bcpowmod( $num:string, $exponent:string, $modulus:string, $scale:?int )",
        "apply": "bcpowmod( $num:string, $exponent:string, $modulus:string, $scale:?int )",
        "info": "Use the fast-exponentiation method to raise num to the power exponent with respect to the modulus modulus."
    },
    "ƒ: bcpow": {
        "type": "function",
        "label": "bcpow( $num:string, $exponent:string, $scale:?int )",
        "apply": "bcpow( $num:string, $exponent:string, $scale:?int )",
        "info": "Raise num to the power exponent. "
    },
    "ƒ: bcsqrt": {
        "type": "function",
        "label": "bcsqrt( $num:string, $scale:?int )",
        "apply": "bcsqrt( $num:string, $scale:?int )",
        "info": "Return the square root of the num."
    },
    "ƒ: bccomp": {
        "type": "function",
        "label": "bccomp( $num1:string, $num2:string, $scale:?int )",
        "apply": "bccomp( $num1:string, $num2:string, $scale:?int )",
        "info": "Compares the num1 to the num2 and returns the result as an integer.  "
    },
    "ƒ: bcscale": {
        "type": "function",
        "label": "bcscale( $scale:?int )",
        "apply": "bcscale( $scale:?int )",
        "info": "Sets the default scale parameter for all subsequent calls to bc math functions that do not explicitly specify a scale parameter."
    },
    "ƒ: exif_tagname": {
        "type": "function",
        "label": "exif_tagname( $index:int )",
        "apply": "exif_tagname( $index:int )",
        "info": null
    },
    "ƒ: exif_read_data": {
        "type": "function",
        "label": "exif_read_data( $file:, $required_sections:?string, $as_arrays:bool, $read_thumbnail:bool )",
        "apply": "exif_read_data( $file:, $required_sections:?string, $as_arrays:bool, $read_thumbnail:bool )",
        "info": "exif_read_data() reads the EXIF headers from an image file. This way you can read meta data generated by digital cameras."
    },
    "ƒ: exif_thumbnail": {
        "type": "function",
        "label": "exif_thumbnail( $file:, $width:, $height:, $image_type: )",
        "apply": "exif_thumbnail( $file:, $width:, $height:, $image_type: )",
        "info": "exif_thumbnail() reads the embedded thumbnail of an image. "
    },
    "ƒ: exif_imagetype": {
        "type": "function",
        "label": "exif_imagetype( $filename:string )",
        "apply": "exif_imagetype( $filename:string )",
        "info": "exif_imagetype() reads the first bytes of an image and checks its signature."
    },
    "ƒ: gd_info": {
        "type": "function",
        "label": "gd_info()",
        "apply": "gd_info()",
        "info": "Gets information about the version and capabilities of the installed GD library."
    },
    "ƒ: imageloadfont": {
        "type": "function",
        "label": "imageloadfont( $filename:string )",
        "apply": "imageloadfont( $filename:string )",
        "info": "imageloadfont() loads a user-defined bitmap and returns its identifier."
    },
    "ƒ: imagesetstyle": {
        "type": "function",
        "label": "imagesetstyle( $image:GdImage, $style:array )",
        "apply": "imagesetstyle( $image:GdImage, $style:array )",
        "info": "imagesetstyle() sets the style to be used by all line drawing functions (such as imageline()and imagepolygon()) when drawing with the special color IMG_COLOR_STYLED or lines of images with color IMG_COLOR_STYLEDBRUSHED."
    },
    "ƒ: imagecreatetruecolor": {
        "type": "function",
        "label": "imagecreatetruecolor( $width:int, $height:int )",
        "apply": "imagecreatetruecolor( $width:int, $height:int )",
        "info": "imagecreatetruecolor() returns an image object representing a black image of the specified size."
    },
    "ƒ: imageistruecolor": {
        "type": "function",
        "label": "imageistruecolor( $image:GdImage )",
        "apply": "imageistruecolor( $image:GdImage )",
        "info": "imageistruecolor() finds whether the image image is a truecolor image."
    },
    "ƒ: imagetruecolortopalette": {
        "type": "function",
        "label": "imagetruecolortopalette( $image:GdImage, $dither:bool, $num_colors:int )",
        "apply": "imagetruecolortopalette( $image:GdImage, $dither:bool, $num_colors:int )",
        "info": "imagetruecolortopalette() converts a truecolor image to a palette image. The code for this function was originally drawn from the Independent JPEG Group library code, which is excellent. The code has been modified to preserve as much alpha channel information as possible in the resulting palette, in addition to preserving colors as well as possible. This does not work as well as might be hoped. It is usually best to simply produce a truecolor output image instead, which guarantees the highest output quality."
    },
    "ƒ: imagepalettetotruecolor": {
        "type": "function",
        "label": "imagepalettetotruecolor( $image:GdImage )",
        "apply": "imagepalettetotruecolor( $image:GdImage )",
        "info": "Converts a palette based image, created by functions like imagecreate() to a true color image, like imagecreatetruecolor()."
    },
    "ƒ: imagecolormatch": {
        "type": "function",
        "label": "imagecolormatch( $image1:GdImage, $image2:GdImage )",
        "apply": "imagecolormatch( $image1:GdImage, $image2:GdImage )",
        "info": "Makes the colors of the palette version of an image more closely match the true color version."
    },
    "ƒ: imagesetthickness": {
        "type": "function",
        "label": "imagesetthickness( $image:GdImage, $thickness:int )",
        "apply": "imagesetthickness( $image:GdImage, $thickness:int )",
        "info": "imagesetthickness() sets the thickness of the lines drawn when drawing rectangles, polygons, arcs etc. to thickness pixels."
    },
    "ƒ: imagefilledellipse": {
        "type": "function",
        "label": "imagefilledellipse( $image:GdImage, $center_x:int, $center_y:int, $width:int, $height:int, $color:int )",
        "apply": "imagefilledellipse( $image:GdImage, $center_x:int, $center_y:int, $width:int, $height:int, $color:int )",
        "info": "Draws an ellipse centered at the specified coordinate on the given image."
    },
    "ƒ: imagefilledarc": {
        "type": "function",
        "label": "imagefilledarc( $image:GdImage, $center_x:int, $center_y:int, $width:int, $height:int, $start_angle:int, $end_angle:int, $color:int, $style:int )",
        "apply": "imagefilledarc( $image:GdImage, $center_x:int, $center_y:int, $width:int, $height:int, $start_angle:int, $end_angle:int, $color:int, $style:int )",
        "info": "Draws a partial arc centered at the specified coordinate in the given image."
    },
    "ƒ: imagealphablending": {
        "type": "function",
        "label": "imagealphablending( $image:GdImage, $enable:bool )",
        "apply": "imagealphablending( $image:GdImage, $enable:bool )",
        "info": "imagealphablending() allows for two different modes of drawing on truecolor images. In blending mode, the alpha channel component of the color supplied to all drawing function,such as imagesetpixel() determines how much of the underlying color should be allowed to shine through.  As a result, gd automatically blends the existing color at that point with the drawing color,and stores the result in the image.  The resulting pixel is opaque.  In non-blending mode, the drawing color is copied literally with its alpha channel information, replacing the destination pixel.  Blending mode is not available when drawing on palette images."
    },
    "ƒ: imagesavealpha": {
        "type": "function",
        "label": "imagesavealpha( $image:GdImage, $enable:bool )",
        "apply": "imagesavealpha( $image:GdImage, $enable:bool )",
        "info": "imagesavealpha() sets the flag which determines whether to retain full alpha channel information (as opposed to single-color transparency)when saving images.This is only supported for image formats which support full alpha channel information,i.e. PNG, WebP and AVIF."
    },
    "ƒ: imagelayereffect": {
        "type": "function",
        "label": "imagelayereffect( $image:GdImage, $effect:int )",
        "apply": "imagelayereffect( $image:GdImage, $effect:int )",
        "info": "Set the alpha blending flag to use layering effects."
    },
    "ƒ: imagecolorallocatealpha": {
        "type": "function",
        "label": "imagecolorallocatealpha( $image:GdImage, $red:int, $green:int, $blue:int, $alpha:int )",
        "apply": "imagecolorallocatealpha( $image:GdImage, $red:int, $green:int, $blue:int, $alpha:int )",
        "info": "imagecolorallocatealpha() behaves identically to imagecolorallocate() with the addition of the transparency parameter alpha."
    },
    "ƒ: imagecolorresolvealpha": {
        "type": "function",
        "label": "imagecolorresolvealpha( $image:GdImage, $red:int, $green:int, $blue:int, $alpha:int )",
        "apply": "imagecolorresolvealpha( $image:GdImage, $red:int, $green:int, $blue:int, $alpha:int )",
        "info": "This function is guaranteed to return a color index for a requested color, either the exact color or the closest possible alternative."
    },
    "ƒ: imagecolorclosestalpha": {
        "type": "function",
        "label": "imagecolorclosestalpha( $image:GdImage, $red:int, $green:int, $blue:int, $alpha:int )",
        "apply": "imagecolorclosestalpha( $image:GdImage, $red:int, $green:int, $blue:int, $alpha:int )",
        "info": "Returns the index of the color in the palette of the image which is \"closest\" to the specified RGB value and alpha level."
    },
    "ƒ: imagecolorexactalpha": {
        "type": "function",
        "label": "imagecolorexactalpha( $image:GdImage, $red:int, $green:int, $blue:int, $alpha:int )",
        "apply": "imagecolorexactalpha( $image:GdImage, $red:int, $green:int, $blue:int, $alpha:int )",
        "info": "Returns the index of the specified color+alpha in the palette of the image."
    },
    "ƒ: imagecopyresampled": {
        "type": "function",
        "label": "imagecopyresampled( $dst_image:GdImage, $src_image:GdImage, $dst_x:int, $dst_y:int, $src_x:int, $src_y:int, $dst_width:int, $dst_height:int, $src_width:int, $src_height:int )",
        "apply": "imagecopyresampled( $dst_image:GdImage, $src_image:GdImage, $dst_x:int, $dst_y:int, $src_x:int, $src_y:int, $dst_width:int, $dst_height:int, $src_width:int, $src_height:int )",
        "info": "imagecopyresampled() copies a rectangular portion of one image to another image, smoothly interpolating pixel values so that, in particular, reducing the size of an image still retains a great deal of clarity."
    },
    "ƒ: imagerotate": {
        "type": "function",
        "label": "imagerotate( $image:GdImage, $angle:float, $background_color:int, $ignore_transparent:bool )",
        "apply": "imagerotate( $image:GdImage, $angle:float, $background_color:int, $ignore_transparent:bool )",
        "info": "Rotates the image image using the given angle in degrees. "
    },
    "ƒ: imagesettile": {
        "type": "function",
        "label": "imagesettile( $image:GdImage, $tile:GdImage )",
        "apply": "imagesettile( $image:GdImage, $tile:GdImage )",
        "info": "imagesettile() sets the tile image to be used by all region filling functions (such as imagefill()and imagefilledpolygon()) when filling with the special color IMG_COLOR_TILED."
    },
    "ƒ: imagesetbrush": {
        "type": "function",
        "label": "imagesetbrush( $image:GdImage, $brush:GdImage )",
        "apply": "imagesetbrush( $image:GdImage, $brush:GdImage )",
        "info": "imagesetbrush() sets the brush image to be used by all line drawing functions (such as imageline()and imagepolygon()) when drawing with the special colors IMG_COLOR_BRUSHED or IMG_COLOR_STYLEDBRUSHED."
    },
    "ƒ: imagecreate": {
        "type": "function",
        "label": "imagecreate( $width:int, $height:int )",
        "apply": "imagecreate( $width:int, $height:int )",
        "info": "imagecreate() returns an image identifier representing a blank image of specified size."
    },
    "ƒ: imagetypes": {
        "type": "function",
        "label": "imagetypes()",
        "apply": "imagetypes()",
        "info": "Returns the image types supported by the current PHP installation."
    },
    "ƒ: imagecreatefromstring": {
        "type": "function",
        "label": "imagecreatefromstring( $data:string )",
        "apply": "imagecreatefromstring( $data:string )",
        "info": "imagecreatefromstring() returns an image identifier representing the image obtained from the given data.These types will be automatically detected if your build of PHP supports them: JPEG, PNG, GIF, BMP, WBMP, GD2, and WEBP."
    },
    "ƒ: imagecreatefromgif": {
        "type": "function",
        "label": "imagecreatefromgif( $filename:string )",
        "apply": "imagecreatefromgif( $filename:string )",
        "info": "imagecreatefromgif() returns an image identifier representing the image obtained from the given filename."
    },
    "ƒ: imagecreatefromjpeg": {
        "type": "function",
        "label": "imagecreatefromjpeg( $filename:string )",
        "apply": "imagecreatefromjpeg( $filename:string )",
        "info": "imagecreatefromjpeg() returns an image identifier representing the image obtained from the given filename."
    },
    "ƒ: imagecreatefrompng": {
        "type": "function",
        "label": "imagecreatefrompng( $filename:string )",
        "apply": "imagecreatefrompng( $filename:string )",
        "info": "imagecreatefrompng() returns an image identifier representing the image obtained from the given filename."
    },
    "ƒ: imagecreatefromwebp": {
        "type": "function",
        "label": "imagecreatefromwebp( $filename:string )",
        "apply": "imagecreatefromwebp( $filename:string )",
        "info": "imagecreatefromwebp() returns an image identifier representing the image obtained from the given filename.Note that animated WebP files cannot be read."
    },
    "ƒ: imagecreatefromxbm": {
        "type": "function",
        "label": "imagecreatefromxbm( $filename:string )",
        "apply": "imagecreatefromxbm( $filename:string )",
        "info": "imagecreatefromxbm() returns an image identifier representing the image obtained from the given filename."
    },
    "ƒ: imagecreatefromwbmp": {
        "type": "function",
        "label": "imagecreatefromwbmp( $filename:string )",
        "apply": "imagecreatefromwbmp( $filename:string )",
        "info": "imagecreatefromwbmp() returns an image identifier representing the image obtained from the given filename."
    },
    "ƒ: imagecreatefromgd": {
        "type": "function",
        "label": "imagecreatefromgd( $filename:string )",
        "apply": "imagecreatefromgd( $filename:string )",
        "info": "Create a new image from GD file or URL."
    },
    "ƒ: imagecreatefromgd2": {
        "type": "function",
        "label": "imagecreatefromgd2( $filename:string )",
        "apply": "imagecreatefromgd2( $filename:string )",
        "info": "Create a new image from GD2 file or URL."
    },
    "ƒ: imagecreatefromgd2part": {
        "type": "function",
        "label": "imagecreatefromgd2part( $filename:string, $x:int, $y:int, $width:int, $height:int )",
        "apply": "imagecreatefromgd2part( $filename:string, $x:int, $y:int, $width:int, $height:int )",
        "info": "Create a new image from a given part of GD2 file or URL."
    },
    "ƒ: imagecreatefrombmp": {
        "type": "function",
        "label": "imagecreatefrombmp( $filename:string )",
        "apply": "imagecreatefrombmp( $filename:string )",
        "info": "imagecreatefrombmp() returns an image identifier representing the image obtained from the given filename."
    },
    "ƒ: imagecreatefromtga": {
        "type": "function",
        "label": "imagecreatefromtga( $filename:string )",
        "apply": "imagecreatefromtga( $filename:string )",
        "info": "imagecreatefromtga() returns an image object representing the image obtained from the given filename."
    },
    "ƒ: imagexbm": {
        "type": "function",
        "label": "imagexbm( $image:GdImage, $filename:?string, $foreground_color:?int )",
        "apply": "imagexbm( $image:GdImage, $filename:?string, $foreground_color:?int )",
        "info": "Outputs or save an XBM version of the given image. "
    },
    "ƒ: imagegif": {
        "type": "function",
        "label": "imagegif( $image:GdImage, $file: )",
        "apply": "imagegif( $image:GdImage, $file: )",
        "info": "imagegif() creates the GIF file in file from the image image. The image argument is the return from the imagecreate() or imagecreatefrom*function."
    },
    "ƒ: imagepng": {
        "type": "function",
        "label": "imagepng( $image:GdImage, $file:, $quality:int, $filters:int )",
        "apply": "imagepng( $image:GdImage, $file:, $quality:int, $filters:int )",
        "info": "Outputs or saves a PNG image from the given image."
    },
    "ƒ: imagewebp": {
        "type": "function",
        "label": "imagewebp( $image:GdImage, $file:, $quality:int )",
        "apply": "imagewebp( $image:GdImage, $file:, $quality:int )",
        "info": "Outputs or saves a WebP version of the given image. "
    },
    "ƒ: imagejpeg": {
        "type": "function",
        "label": "imagejpeg( $image:GdImage, $file:, $quality:int )",
        "apply": "imagejpeg( $image:GdImage, $file:, $quality:int )",
        "info": "imagejpeg() creates a JPEG file from the given image."
    },
    "ƒ: imagewbmp": {
        "type": "function",
        "label": "imagewbmp( $image:GdImage, $file:, $foreground_color:?int )",
        "apply": "imagewbmp( $image:GdImage, $file:, $foreground_color:?int )",
        "info": "imagewbmp() outputs or save a WBMP version of the given image. "
    },
    "ƒ: imagegd": {
        "type": "function",
        "label": "imagegd( $image:GdImage, $file:?string )",
        "apply": "imagegd( $image:GdImage, $file:?string )",
        "info": "Outputs a GD image to the given file."
    },
    "ƒ: imagegd2": {
        "type": "function",
        "label": "imagegd2( $image:GdImage, $file:?string, $chunk_size:int, $mode:int )",
        "apply": "imagegd2( $image:GdImage, $file:?string, $chunk_size:int, $mode:int )",
        "info": "Outputs a GD2 image to the given file."
    },
    "ƒ: imagebmp": {
        "type": "function",
        "label": "imagebmp( $image:GdImage, $file:, $compressed:bool )",
        "apply": "imagebmp( $image:GdImage, $file:, $compressed:bool )",
        "info": "Outputs or saves a BMP version of the given image."
    },
    "ƒ: imagedestroy": {
        "type": "function",
        "label": "imagedestroy( $image:GdImage )",
        "apply": "imagedestroy( $image:GdImage )",
        "info": "Note: "
    },
    "ƒ: imagecolorallocate": {
        "type": "function",
        "label": "imagecolorallocate( $image:GdImage, $red:int, $green:int, $blue:int )",
        "apply": "imagecolorallocate( $image:GdImage, $red:int, $green:int, $blue:int )",
        "info": "Returns a color identifier representing the color composed of the given RGB components."
    },
    "ƒ: imagepalettecopy": {
        "type": "function",
        "label": "imagepalettecopy( $dst:GdImage, $src:GdImage )",
        "apply": "imagepalettecopy( $dst:GdImage, $src:GdImage )",
        "info": "imagepalettecopy() copies the palette from the src image to the dst image."
    },
    "ƒ: imagecolorat": {
        "type": "function",
        "label": "imagecolorat( $image:GdImage, $x:int, $y:int )",
        "apply": "imagecolorat( $image:GdImage, $x:int, $y:int )",
        "info": "Returns the index of the color of the pixel at the specified location in the image specified by image."
    },
    "ƒ: imagecolorclosest": {
        "type": "function",
        "label": "imagecolorclosest( $image:GdImage, $red:int, $green:int, $blue:int )",
        "apply": "imagecolorclosest( $image:GdImage, $red:int, $green:int, $blue:int )",
        "info": "Returns the index of the color in the palette of the image which is \"closest\" to the specified RGB value."
    },
    "ƒ: imagecolorclosesthwb": {
        "type": "function",
        "label": "imagecolorclosesthwb( $image:GdImage, $red:int, $green:int, $blue:int )",
        "apply": "imagecolorclosesthwb( $image:GdImage, $red:int, $green:int, $blue:int )",
        "info": "Get the index of the color which has the hue, white and blackness nearest the given color."
    },
    "ƒ: imagecolordeallocate": {
        "type": "function",
        "label": "imagecolordeallocate( $image:GdImage, $color:int )",
        "apply": "imagecolordeallocate( $image:GdImage, $color:int )",
        "info": "De-allocates a color previously allocated with imagecolorallocate() or imagecolorallocatealpha()."
    },
    "ƒ: imagecolorresolve": {
        "type": "function",
        "label": "imagecolorresolve( $image:GdImage, $red:int, $green:int, $blue:int )",
        "apply": "imagecolorresolve( $image:GdImage, $red:int, $green:int, $blue:int )",
        "info": "This function is guaranteed to return a color index for a requested color, either the exact color or the closest possible alternative."
    },
    "ƒ: imagecolorexact": {
        "type": "function",
        "label": "imagecolorexact( $image:GdImage, $red:int, $green:int, $blue:int )",
        "apply": "imagecolorexact( $image:GdImage, $red:int, $green:int, $blue:int )",
        "info": "Returns the index of the specified color in the palette of the image."
    },
    "ƒ: imagecolorset": {
        "type": "function",
        "label": "imagecolorset( $image:GdImage, $color:int, $red:int, $green:int, $blue:int, $alpha:int )",
        "apply": "imagecolorset( $image:GdImage, $color:int, $red:int, $green:int, $blue:int, $alpha:int )",
        "info": "This sets the specified index in the palette to the specified color. This is useful for creating flood-fill-like effects in palleted images without the overhead of performing the actual flood-fill."
    },
    "ƒ: imagecolorsforindex": {
        "type": "function",
        "label": "imagecolorsforindex( $image:GdImage, $color:int )",
        "apply": "imagecolorsforindex( $image:GdImage, $color:int )",
        "info": "Gets the color for a specified index."
    },
    "ƒ: imagegammacorrect": {
        "type": "function",
        "label": "imagegammacorrect( $image:GdImage, $input_gamma:float, $output_gamma:float )",
        "apply": "imagegammacorrect( $image:GdImage, $input_gamma:float, $output_gamma:float )",
        "info": "Applies gamma correction to the given gd image given an input and an output gamma."
    },
    "ƒ: imagesetpixel": {
        "type": "function",
        "label": "imagesetpixel( $image:GdImage, $x:int, $y:int, $color:int )",
        "apply": "imagesetpixel( $image:GdImage, $x:int, $y:int, $color:int )",
        "info": "imagesetpixel() draws a pixel at the specified coordinate."
    },
    "ƒ: imageline": {
        "type": "function",
        "label": "imageline( $image:GdImage, $x1:int, $y1:int, $x2:int, $y2:int, $color:int )",
        "apply": "imageline( $image:GdImage, $x1:int, $y1:int, $x2:int, $y2:int, $color:int )",
        "info": "Draws a line between the two given points."
    },
    "ƒ: imagedashedline": {
        "type": "function",
        "label": "imagedashedline( $image:GdImage, $x1:int, $y1:int, $x2:int, $y2:int, $color:int )",
        "apply": "imagedashedline( $image:GdImage, $x1:int, $y1:int, $x2:int, $y2:int, $color:int )",
        "info": "This function is deprecated. Use combination of imagesetstyle() and imageline()instead."
    },
    "ƒ: imagerectangle": {
        "type": "function",
        "label": "imagerectangle( $image:GdImage, $x1:int, $y1:int, $x2:int, $y2:int, $color:int )",
        "apply": "imagerectangle( $image:GdImage, $x1:int, $y1:int, $x2:int, $y2:int, $color:int )",
        "info": "imagerectangle() creates a rectangle starting at the specified coordinates."
    },
    "ƒ: imagefilledrectangle": {
        "type": "function",
        "label": "imagefilledrectangle( $image:GdImage, $x1:int, $y1:int, $x2:int, $y2:int, $color:int )",
        "apply": "imagefilledrectangle( $image:GdImage, $x1:int, $y1:int, $x2:int, $y2:int, $color:int )",
        "info": "Creates a rectangle filled with color in the given image starting at point 1 and ending at point 2.0, 0 is the top left corner of the image."
    },
    "ƒ: imagearc": {
        "type": "function",
        "label": "imagearc( $image:GdImage, $center_x:int, $center_y:int, $width:int, $height:int, $start_angle:int, $end_angle:int, $color:int )",
        "apply": "imagearc( $image:GdImage, $center_x:int, $center_y:int, $width:int, $height:int, $start_angle:int, $end_angle:int, $color:int )",
        "info": "imagearc() draws an arc of circle centered at the given coordinates."
    },
    "ƒ: imageellipse": {
        "type": "function",
        "label": "imageellipse( $image:GdImage, $center_x:int, $center_y:int, $width:int, $height:int, $color:int )",
        "apply": "imageellipse( $image:GdImage, $center_x:int, $center_y:int, $width:int, $height:int, $color:int )",
        "info": "Draws an ellipse centered at the specified coordinates."
    },
    "ƒ: imagefilltoborder": {
        "type": "function",
        "label": "imagefilltoborder( $image:GdImage, $x:int, $y:int, $border_color:int, $color:int )",
        "apply": "imagefilltoborder( $image:GdImage, $x:int, $y:int, $border_color:int, $color:int )",
        "info": "imagefilltoborder() performs a flood fill whose border color is defined by border_color.The starting point for the fill is x,y (top left is 0, 0) and the region is filled with color color."
    },
    "ƒ: imagefill": {
        "type": "function",
        "label": "imagefill( $image:GdImage, $x:int, $y:int, $color:int )",
        "apply": "imagefill( $image:GdImage, $x:int, $y:int, $color:int )",
        "info": "Performs a flood fill starting at the given coordinate (top left is 0, 0)with the given color in the image."
    },
    "ƒ: imagecolorstotal": {
        "type": "function",
        "label": "imagecolorstotal( $image:GdImage )",
        "apply": "imagecolorstotal( $image:GdImage )",
        "info": "Returns the number of colors in an image palette."
    },
    "ƒ: imagecolortransparent": {
        "type": "function",
        "label": "imagecolortransparent( $image:GdImage, $color:?int )",
        "apply": "imagecolortransparent( $image:GdImage, $color:?int )",
        "info": "Gets or sets the transparent color in the given image."
    },
    "ƒ: imageinterlace": {
        "type": "function",
        "label": "imageinterlace( $image:GdImage, $enable:?bool )",
        "apply": "imageinterlace( $image:GdImage, $enable:?bool )",
        "info": "imageinterlace() turns the interlace bit on or off."
    },
    "ƒ: imagepolygon": {
        "type": "function",
        "label": "imagepolygon( $image:GdImage, $points:array, $num_points_or_color:int, $color:?int )",
        "apply": "imagepolygon( $image:GdImage, $points:array, $num_points_or_color:int, $color:?int )",
        "info": "Signature as of PHP 8.0.0 (not supported with named arguments)"
    },
    "ƒ: imageopenpolygon": {
        "type": "function",
        "label": "imageopenpolygon( $image:GdImage, $points:array, $num_points_or_color:int, $color:?int )",
        "apply": "imageopenpolygon( $image:GdImage, $points:array, $num_points_or_color:int, $color:?int )",
        "info": "Signature as of PHP 8.0.0 (not supported with named arguments)"
    },
    "ƒ: imagefilledpolygon": {
        "type": "function",
        "label": "imagefilledpolygon( $image:GdImage, $points:array, $num_points_or_color:int, $color:?int )",
        "apply": "imagefilledpolygon( $image:GdImage, $points:array, $num_points_or_color:int, $color:?int )",
        "info": "Signature as of PHP 8.0.0 (not supported with named arguments)"
    },
    "ƒ: imagefontwidth": {
        "type": "function",
        "label": "imagefontwidth( $font:GdFont|int )",
        "apply": "imagefontwidth( $font:GdFont|int )",
        "info": "Returns the pixel width of a character in font."
    },
    "ƒ: imagefontheight": {
        "type": "function",
        "label": "imagefontheight( $font:GdFont|int )",
        "apply": "imagefontheight( $font:GdFont|int )",
        "info": "Returns the pixel height of a character in the specified font."
    },
    "ƒ: imagechar": {
        "type": "function",
        "label": "imagechar( $image:GdImage, $font:GdFont|int, $x:int, $y:int, $char:string, $color:int )",
        "apply": "imagechar( $image:GdImage, $font:GdFont|int, $x:int, $y:int, $char:string, $color:int )",
        "info": "imagechar() draws the first character of char in the image identified by image with its upper-left at x,y (top left is 0,0) with the color color."
    },
    "ƒ: imagecharup": {
        "type": "function",
        "label": "imagecharup( $image:GdImage, $font:GdFont|int, $x:int, $y:int, $char:string, $color:int )",
        "apply": "imagecharup( $image:GdImage, $font:GdFont|int, $x:int, $y:int, $char:string, $color:int )",
        "info": "Draws the character char vertically at the specified coordinate on the given image."
    },
    "ƒ: imagestring": {
        "type": "function",
        "label": "imagestring( $image:GdImage, $font:GdFont|int, $x:int, $y:int, $string:string, $color:int )",
        "apply": "imagestring( $image:GdImage, $font:GdFont|int, $x:int, $y:int, $string:string, $color:int )",
        "info": "Draws a string at the given coordinates."
    },
    "ƒ: imagestringup": {
        "type": "function",
        "label": "imagestringup( $image:GdImage, $font:GdFont|int, $x:int, $y:int, $string:string, $color:int )",
        "apply": "imagestringup( $image:GdImage, $font:GdFont|int, $x:int, $y:int, $string:string, $color:int )",
        "info": "Draws a string vertically at the given coordinates."
    },
    "ƒ: imagecopy": {
        "type": "function",
        "label": "imagecopy( $dst_image:GdImage, $src_image:GdImage, $dst_x:int, $dst_y:int, $src_x:int, $src_y:int, $src_width:int, $src_height:int )",
        "apply": "imagecopy( $dst_image:GdImage, $src_image:GdImage, $dst_x:int, $dst_y:int, $src_x:int, $src_y:int, $src_width:int, $src_height:int )",
        "info": "Copy a part of src_image onto dst_image starting at the x,y coordinates src_x, src_y  with a width of src_width and a height of src_height.  The portion defined will be copied onto the x,y coordinates, dst_x and dst_y."
    },
    "ƒ: imagecopymerge": {
        "type": "function",
        "label": "imagecopymerge( $dst_image:GdImage, $src_image:GdImage, $dst_x:int, $dst_y:int, $src_x:int, $src_y:int, $src_width:int, $src_height:int, $pct:int )",
        "apply": "imagecopymerge( $dst_image:GdImage, $src_image:GdImage, $dst_x:int, $dst_y:int, $src_x:int, $src_y:int, $src_width:int, $src_height:int, $pct:int )",
        "info": "Copy a part of src_image onto dst_image starting at the x,y coordinates src_x, src_y  with a width of src_width and a height of src_height.  The portion defined will be copied onto the x,y coordinates, dst_x and dst_y."
    },
    "ƒ: imagecopymergegray": {
        "type": "function",
        "label": "imagecopymergegray( $dst_image:GdImage, $src_image:GdImage, $dst_x:int, $dst_y:int, $src_x:int, $src_y:int, $src_width:int, $src_height:int, $pct:int )",
        "apply": "imagecopymergegray( $dst_image:GdImage, $src_image:GdImage, $dst_x:int, $dst_y:int, $src_x:int, $src_y:int, $src_width:int, $src_height:int, $pct:int )",
        "info": "imagecopymergegray() copy a part of src_image onto dst_image starting at the x,y coordinates src_x, src_y  with a width of src_width and a height of src_height.  The portion defined will be copied onto the x,y coordinates, dst_x and dst_y."
    },
    "ƒ: imagecopyresized": {
        "type": "function",
        "label": "imagecopyresized( $dst_image:GdImage, $src_image:GdImage, $dst_x:int, $dst_y:int, $src_x:int, $src_y:int, $dst_width:int, $dst_height:int, $src_width:int, $src_height:int )",
        "apply": "imagecopyresized( $dst_image:GdImage, $src_image:GdImage, $dst_x:int, $dst_y:int, $src_x:int, $src_y:int, $dst_width:int, $dst_height:int, $src_width:int, $src_height:int )",
        "info": "imagecopyresized() copies a rectangular portion of one image to another image.dst_image is the destination image,src_image is the source image identifier."
    },
    "ƒ: imagesx": {
        "type": "function",
        "label": "imagesx( $image:GdImage )",
        "apply": "imagesx( $image:GdImage )",
        "info": "Returns the width of the given image object."
    },
    "ƒ: imagesy": {
        "type": "function",
        "label": "imagesy( $image:GdImage )",
        "apply": "imagesy( $image:GdImage )",
        "info": "Returns the height of the given image object."
    },
    "ƒ: imagesetclip": {
        "type": "function",
        "label": "imagesetclip( $image:GdImage, $x1:int, $y1:int, $x2:int, $y2:int )",
        "apply": "imagesetclip( $image:GdImage, $x1:int, $y1:int, $x2:int, $y2:int )",
        "info": "imagesetclip() sets the current clipping rectangle, i.e.the area beyond which no pixels will be drawn."
    },
    "ƒ: imagegetclip": {
        "type": "function",
        "label": "imagegetclip( $image:GdImage )",
        "apply": "imagegetclip( $image:GdImage )",
        "info": "imagegetclip() retrieves the current clipping rectangle,i.e. the area beyond which no pixels will be drawn."
    },
    "ƒ: imageftbbox": {
        "type": "function",
        "label": "imageftbbox( $size:float, $angle:float, $font_filename:string, $string:string, $options:array )",
        "apply": "imageftbbox( $size:float, $angle:float, $font_filename:string, $string:string, $options:array )",
        "info": "This function calculates and returns the bounding box in pixels for a FreeType text."
    },
    "ƒ: imagefttext": {
        "type": "function",
        "label": "imagefttext( $image:GdImage, $size:float, $angle:float, $x:int, $y:int, $color:int, $font_filename:string, $text:string, $options:array )",
        "apply": "imagefttext( $image:GdImage, $size:float, $angle:float, $x:int, $y:int, $color:int, $font_filename:string, $text:string, $options:array )",
        "info": "Note: "
    },
    "ƒ: imagettfbbox": {
        "type": "function",
        "label": "imagettfbbox( $size:float, $angle:float, $font_filename:string, $string:string, $options:array )",
        "apply": "imagettfbbox( $size:float, $angle:float, $font_filename:string, $string:string, $options:array )",
        "info": "This function calculates and returns the bounding box in pixels for a TrueType text."
    },
    "ƒ: imagettftext": {
        "type": "function",
        "label": "imagettftext( $image:GdImage, $size:float, $angle:float, $x:int, $y:int, $color:int, $font_filename:string, $text:string, $options:array )",
        "apply": "imagettftext( $image:GdImage, $size:float, $angle:float, $x:int, $y:int, $color:int, $font_filename:string, $text:string, $options:array )",
        "info": "Writes the given text into the image using TrueType fonts."
    },
    "ƒ: imagefilter": {
        "type": "function",
        "label": "imagefilter( $image:GdImage, $filter:int, $args: )",
        "apply": "imagefilter( $image:GdImage, $filter:int, $args: )",
        "info": "imagefilter() applies the given filter filter on the image."
    },
    "ƒ: imageconvolution": {
        "type": "function",
        "label": "imageconvolution( $image:GdImage, $matrix:array, $divisor:float, $offset:float )",
        "apply": "imageconvolution( $image:GdImage, $matrix:array, $divisor:float, $offset:float )",
        "info": "Applies a convolution matrix on the image, using the given coefficient and offset."
    },
    "ƒ: imageflip": {
        "type": "function",
        "label": "imageflip( $image:GdImage, $mode:int )",
        "apply": "imageflip( $image:GdImage, $mode:int )",
        "info": "Flips the image image using the given mode. "
    },
    "ƒ: imageantialias": {
        "type": "function",
        "label": "imageantialias( $image:GdImage, $enable:bool )",
        "apply": "imageantialias( $image:GdImage, $enable:bool )",
        "info": "Activate the fast drawing antialiased methods for lines and wired polygons.It does not support alpha components. It works using a direct blend operation. It works only with truecolor images."
    },
    "ƒ: imagecrop": {
        "type": "function",
        "label": "imagecrop( $image:GdImage, $rectangle:array )",
        "apply": "imagecrop( $image:GdImage, $rectangle:array )",
        "info": "Crops an image to the given rectangular area and returns the resulting image.The given image is not modified."
    },
    "ƒ: imagecropauto": {
        "type": "function",
        "label": "imagecropauto( $image:GdImage, $mode:int, $threshold:float, $color:int )",
        "apply": "imagecropauto( $image:GdImage, $mode:int, $threshold:float, $color:int )",
        "info": "Automatically crops an image according to the given mode."
    },
    "ƒ: imagescale": {
        "type": "function",
        "label": "imagescale( $image:GdImage, $width:int, $height:int, $mode:int )",
        "apply": "imagescale( $image:GdImage, $width:int, $height:int, $mode:int )",
        "info": "imagescale() scales an image using the given interpolation algorithm."
    },
    "ƒ: imageaffine": {
        "type": "function",
        "label": "imageaffine( $image:GdImage, $affine:array, $clip:?array )",
        "apply": "imageaffine( $image:GdImage, $affine:array, $clip:?array )",
        "info": ""
    },
    "ƒ: imageaffinematrixget": {
        "type": "function",
        "label": "imageaffinematrixget( $type:int, $options: )",
        "apply": "imageaffinematrixget( $type:int, $options: )",
        "info": "Returns an affine transformation matrix."
    },
    "ƒ: imageaffinematrixconcat": {
        "type": "function",
        "label": "imageaffinematrixconcat( $matrix1:array, $matrix2:array )",
        "apply": "imageaffinematrixconcat( $matrix1:array, $matrix2:array )",
        "info": "Returns the concatenation of two affine transformation matrices,what is useful if multiple transformations should be applied to the same image in one go."
    },
    "ƒ: imagegetinterpolation": {
        "type": "function",
        "label": "imagegetinterpolation( $image:GdImage )",
        "apply": "imagegetinterpolation( $image:GdImage )",
        "info": "Gets the currently set interpolation method of the image."
    },
    "ƒ: imagesetinterpolation": {
        "type": "function",
        "label": "imagesetinterpolation( $image:GdImage, $method:int )",
        "apply": "imagesetinterpolation( $image:GdImage, $method:int )",
        "info": "Sets the interpolation method, setting an interpolation method affects the rendering of various functions in GD, such as the imagerotate() function."
    },
    "ƒ: imageresolution": {
        "type": "function",
        "label": "imageresolution( $image:GdImage, $resolution_x:?int, $resolution_y:?int )",
        "apply": "imageresolution( $image:GdImage, $resolution_x:?int, $resolution_y:?int )",
        "info": "imageresolution() allows to set and get the resolution of an image in DPI (dots per inch). If the optional parameters are null,the current resolution is returned as an indexed array. If only resolution_x is not null, the horizontal and vertical resolution are set to this value. If none of the optional parameters are null, the horizontal and vertical resolution are set to these values, respectively."
    },
    "ƒ: intl_get_error_code": {
        "type": "function",
        "label": "intl_get_error_code()",
        "apply": "intl_get_error_code()",
        "info": "Useful to handle errors occurred in static methods when there's no object to get error code from."
    },
    "ƒ: intl_get_error_message": {
        "type": "function",
        "label": "intl_get_error_message()",
        "apply": "intl_get_error_message()",
        "info": "Get error message from last internationalization function called."
    },
    "ƒ: intl_is_failure": {
        "type": "function",
        "label": "intl_is_failure( $errorCode:int )",
        "apply": "intl_is_failure( $errorCode:int )",
        "info": ""
    },
    "ƒ: intl_error_name": {
        "type": "function",
        "label": "intl_error_name( $errorCode:int )",
        "apply": "intl_error_name( $errorCode:int )",
        "info": "Return ICU error code name."
    },
    "ƒ: grapheme_strlen": {
        "type": "function",
        "label": "grapheme_strlen( $string:string )",
        "apply": "grapheme_strlen( $string:string )",
        "info": "Procedural style"
    },
    "ƒ: grapheme_strpos": {
        "type": "function",
        "label": "grapheme_strpos( $haystack:string, $needle:string, $offset:int )",
        "apply": "grapheme_strpos( $haystack:string, $needle:string, $offset:int )",
        "info": "Procedural style"
    },
    "ƒ: grapheme_stripos": {
        "type": "function",
        "label": "grapheme_stripos( $haystack:string, $needle:string, $offset:int )",
        "apply": "grapheme_stripos( $haystack:string, $needle:string, $offset:int )",
        "info": "Procedural style"
    },
    "ƒ: grapheme_strrpos": {
        "type": "function",
        "label": "grapheme_strrpos( $haystack:string, $needle:string, $offset:int )",
        "apply": "grapheme_strrpos( $haystack:string, $needle:string, $offset:int )",
        "info": "Procedural style"
    },
    "ƒ: grapheme_strripos": {
        "type": "function",
        "label": "grapheme_strripos( $haystack:string, $needle:string, $offset:int )",
        "apply": "grapheme_strripos( $haystack:string, $needle:string, $offset:int )",
        "info": "Procedural style"
    },
    "ƒ: grapheme_substr": {
        "type": "function",
        "label": "grapheme_substr( $string:string, $offset:int, $length:?int )",
        "apply": "grapheme_substr( $string:string, $offset:int, $length:?int )",
        "info": "Procedural style"
    },
    "ƒ: grapheme_strstr": {
        "type": "function",
        "label": "grapheme_strstr( $haystack:string, $needle:string, $beforeNeedle:bool )",
        "apply": "grapheme_strstr( $haystack:string, $needle:string, $beforeNeedle:bool )",
        "info": "Procedural style"
    },
    "ƒ: grapheme_stristr": {
        "type": "function",
        "label": "grapheme_stristr( $haystack:string, $needle:string, $beforeNeedle:bool )",
        "apply": "grapheme_stristr( $haystack:string, $needle:string, $beforeNeedle:bool )",
        "info": "Procedural style"
    },
    "ƒ: grapheme_extract": {
        "type": "function",
        "label": "grapheme_extract( $haystack:string, $size:int, $type:int, $offset:int, $next: )",
        "apply": "grapheme_extract( $haystack:string, $size:int, $type:int, $offset:int, $next: )",
        "info": "Procedural style"
    },
    "ƒ: idn_to_ascii": {
        "type": "function",
        "label": "idn_to_ascii( $domain:string, $flags:int, $variant:int, $idna_info: )",
        "apply": "idn_to_ascii( $domain:string, $flags:int, $variant:int, $idna_info: )",
        "info": "Procedural style"
    },
    "ƒ: idn_to_utf8": {
        "type": "function",
        "label": "idn_to_utf8( $domain:string, $flags:int, $variant:int, $idna_info: )",
        "apply": "idn_to_utf8( $domain:string, $flags:int, $variant:int, $idna_info: )",
        "info": "Procedural style"
    },
    "ƒ: sodium_crypto_aead_aes256gcm_is_available": {
        "type": "function",
        "label": "sodium_crypto_aead_aes256gcm_is_available()",
        "apply": "sodium_crypto_aead_aes256gcm_is_available()",
        "info": "The return value of this function depends on whether or not the hardware supports hardware-accelerated AES."
    },
    "ƒ: sodium_crypto_aead_aes256gcm_decrypt": {
        "type": "function",
        "label": "sodium_crypto_aead_aes256gcm_decrypt( $ciphertext:string, $additional_data:string, $nonce:string, $key:string )",
        "apply": "sodium_crypto_aead_aes256gcm_decrypt( $ciphertext:string, $additional_data:string, $nonce:string, $key:string )",
        "info": "Verify then decrypt with AES-256-GCM.Only available if sodium_crypto_aead_aes256gcm_is_available() returns true."
    },
    "ƒ: sodium_crypto_aead_aes256gcm_encrypt": {
        "type": "function",
        "label": "sodium_crypto_aead_aes256gcm_encrypt( $message:string, $additional_data:string, $nonce:string, $key:string )",
        "apply": "sodium_crypto_aead_aes256gcm_encrypt( $message:string, $additional_data:string, $nonce:string, $key:string )",
        "info": "Encrypt then authenticate with AES-256-GCM.Only available if sodium_crypto_aead_aes256gcm_is_available() returns true."
    },
    "ƒ: sodium_crypto_aead_aes256gcm_keygen": {
        "type": "function",
        "label": "sodium_crypto_aead_aes256gcm_keygen()",
        "apply": "sodium_crypto_aead_aes256gcm_keygen()",
        "info": "Generate a random key for use with sodium_crypto_aead_aes256gcm_encrypt() and sodium_crypto_aead_aes256gcm_decrypt()."
    },
    "ƒ: sodium_crypto_aead_chacha20poly1305_decrypt": {
        "type": "function",
        "label": "sodium_crypto_aead_chacha20poly1305_decrypt( $ciphertext:string, $additional_data:string, $nonce:string, $key:string )",
        "apply": "sodium_crypto_aead_chacha20poly1305_decrypt( $ciphertext:string, $additional_data:string, $nonce:string, $key:string )",
        "info": "Verify then decrypt with ChaCha20-Poly1305."
    },
    "ƒ: sodium_crypto_aead_chacha20poly1305_encrypt": {
        "type": "function",
        "label": "sodium_crypto_aead_chacha20poly1305_encrypt( $message:string, $additional_data:string, $nonce:string, $key:string )",
        "apply": "sodium_crypto_aead_chacha20poly1305_encrypt( $message:string, $additional_data:string, $nonce:string, $key:string )",
        "info": "Encrypt then authenticate with ChaCha20-Poly1305."
    },
    "ƒ: sodium_crypto_aead_chacha20poly1305_keygen": {
        "type": "function",
        "label": "sodium_crypto_aead_chacha20poly1305_keygen()",
        "apply": "sodium_crypto_aead_chacha20poly1305_keygen()",
        "info": "Generate a random key for use with sodium_crypto_aead_chacha20poly1305_encrypt() and sodium_crypto_aead_chacha20poly1305_decrypt()."
    },
    "ƒ: sodium_crypto_aead_chacha20poly1305_ietf_decrypt": {
        "type": "function",
        "label": "sodium_crypto_aead_chacha20poly1305_ietf_decrypt( $ciphertext:string, $additional_data:string, $nonce:string, $key:string )",
        "apply": "sodium_crypto_aead_chacha20poly1305_ietf_decrypt( $ciphertext:string, $additional_data:string, $nonce:string, $key:string )",
        "info": "Verify then decrypt with ChaCha20-Poly1305 (IETF variant)."
    },
    "ƒ: sodium_crypto_aead_chacha20poly1305_ietf_encrypt": {
        "type": "function",
        "label": "sodium_crypto_aead_chacha20poly1305_ietf_encrypt( $message:string, $additional_data:string, $nonce:string, $key:string )",
        "apply": "sodium_crypto_aead_chacha20poly1305_ietf_encrypt( $message:string, $additional_data:string, $nonce:string, $key:string )",
        "info": "Encrypt then authenticate with ChaCha20-Poly1305 (IETF variant)."
    },
    "ƒ: sodium_crypto_aead_chacha20poly1305_ietf_keygen": {
        "type": "function",
        "label": "sodium_crypto_aead_chacha20poly1305_ietf_keygen()",
        "apply": "sodium_crypto_aead_chacha20poly1305_ietf_keygen()",
        "info": "Generate a random key for use with sodium_crypto_aead_chacha20poly1305_ietf_encrypt() and sodium_crypto_aead_chacha20poly1305_ietf_decrypt()."
    },
    "ƒ: sodium_crypto_aead_xchacha20poly1305_ietf_decrypt": {
        "type": "function",
        "label": "sodium_crypto_aead_xchacha20poly1305_ietf_decrypt( $ciphertext:string, $additional_data:string, $nonce:string, $key:string )",
        "apply": "sodium_crypto_aead_xchacha20poly1305_ietf_decrypt( $ciphertext:string, $additional_data:string, $nonce:string, $key:string )",
        "info": "Verify then decrypt with ChaCha20-Poly1305 (eXtended-nonce variant)."
    },
    "ƒ: sodium_crypto_aead_xchacha20poly1305_ietf_keygen": {
        "type": "function",
        "label": "sodium_crypto_aead_xchacha20poly1305_ietf_keygen()",
        "apply": "sodium_crypto_aead_xchacha20poly1305_ietf_keygen()",
        "info": "Generate a random key for use with sodium_crypto_aead_xchacha20poly1305_ietf_encrypt() and sodium_crypto_aead_xchacha20poly1305_ietf_decrypt()."
    },
    "ƒ: sodium_crypto_aead_xchacha20poly1305_ietf_encrypt": {
        "type": "function",
        "label": "sodium_crypto_aead_xchacha20poly1305_ietf_encrypt( $message:string, $additional_data:string, $nonce:string, $key:string )",
        "apply": "sodium_crypto_aead_xchacha20poly1305_ietf_encrypt( $message:string, $additional_data:string, $nonce:string, $key:string )",
        "info": "Encrypt then authenticate with XChaCha20-Poly1305 (eXtended-nonce variant)."
    },
    "ƒ: sodium_crypto_auth": {
        "type": "function",
        "label": "sodium_crypto_auth( $message:string, $key:string )",
        "apply": "sodium_crypto_auth( $message:string, $key:string )",
        "info": "Symmetric message authentication via sodium_crypto_auth() provides integrity, but not confidentiality."
    },
    "ƒ: sodium_crypto_auth_keygen": {
        "type": "function",
        "label": "sodium_crypto_auth_keygen()",
        "apply": "sodium_crypto_auth_keygen()",
        "info": "Generate a key for use with sodium_crypto_auth() and sodium_crypto_auth_verify()."
    },
    "ƒ: sodium_crypto_auth_verify": {
        "type": "function",
        "label": "sodium_crypto_auth_verify( $mac:string, $message:string, $key:string )",
        "apply": "sodium_crypto_auth_verify( $mac:string, $message:string, $key:string )",
        "info": "Verify the authentication tag is valid for a given message and key."
    },
    "ƒ: sodium_crypto_box": {
        "type": "function",
        "label": "sodium_crypto_box( $message:string, $nonce:string, $key_pair:string )",
        "apply": "sodium_crypto_box( $message:string, $nonce:string, $key_pair:string )",
        "info": "Encrypt a message using asymmetric (public key) cryptography."
    },
    "ƒ: sodium_crypto_box_keypair": {
        "type": "function",
        "label": "sodium_crypto_box_keypair()",
        "apply": "sodium_crypto_box_keypair()",
        "info": "Generates a secret key and a public key as one string."
    },
    "ƒ: sodium_crypto_box_seed_keypair": {
        "type": "function",
        "label": "sodium_crypto_box_seed_keypair( $seed:string )",
        "apply": "sodium_crypto_box_seed_keypair( $seed:string )",
        "info": "Clamps the seed to form a secret key, derives the public key, and returns the two as a keypair."
    },
    "ƒ: sodium_crypto_box_keypair_from_secretkey_and_publickey": {
        "type": "function",
        "label": "sodium_crypto_box_keypair_from_secretkey_and_publickey( $secret_key:string, $public_key:string )",
        "apply": "sodium_crypto_box_keypair_from_secretkey_and_publickey( $secret_key:string, $public_key:string )",
        "info": "This function exists to satisfy the API requirements of e.g. crypto_box().Pass in one party's secret key and the other's public key, and you will obtain a \"keypair\" for your conversation."
    },
    "ƒ: sodium_crypto_box_open": {
        "type": "function",
        "label": "sodium_crypto_box_open( $ciphertext:string, $nonce:string, $key_pair:string )",
        "apply": "sodium_crypto_box_open( $ciphertext:string, $nonce:string, $key_pair:string )",
        "info": "Decrypt a message using asymmetric (public key) cryptography."
    },
    "ƒ: sodium_crypto_box_publickey": {
        "type": "function",
        "label": "sodium_crypto_box_publickey( $key_pair:string )",
        "apply": "sodium_crypto_box_publickey( $key_pair:string )",
        "info": "Given a keypair, fetch only the public key."
    },
    "ƒ: sodium_crypto_box_publickey_from_secretkey": {
        "type": "function",
        "label": "sodium_crypto_box_publickey_from_secretkey( $secret_key:string )",
        "apply": "sodium_crypto_box_publickey_from_secretkey( $secret_key:string )",
        "info": "Given a secret key, calculate the corresponding public key."
    },
    "ƒ: sodium_crypto_box_seal": {
        "type": "function",
        "label": "sodium_crypto_box_seal( $message:string, $public_key:string )",
        "apply": "sodium_crypto_box_seal( $message:string, $public_key:string )",
        "info": "Encrypt a message such that only the recipient can decrypt it."
    },
    "ƒ: sodium_crypto_box_seal_open": {
        "type": "function",
        "label": "sodium_crypto_box_seal_open( $ciphertext:string, $key_pair:string )",
        "apply": "sodium_crypto_box_seal_open( $ciphertext:string, $key_pair:string )",
        "info": "Decrypt a message that was encrypted with sodium_crypto_box_seal()"
    },
    "ƒ: sodium_crypto_box_secretkey": {
        "type": "function",
        "label": "sodium_crypto_box_secretkey( $key_pair:string )",
        "apply": "sodium_crypto_box_secretkey( $key_pair:string )",
        "info": "Given a keypair, fetch only the secret key."
    },
    "ƒ: sodium_crypto_core_ristretto255_add": {
        "type": "function",
        "label": "sodium_crypto_core_ristretto255_add( $p:string, $q:string )",
        "apply": "sodium_crypto_core_ristretto255_add( $p:string, $q:string )",
        "info": "Adds an element q to p.Available as of libsodium 1.0.18."
    },
    "ƒ: sodium_crypto_core_ristretto255_from_hash": {
        "type": "function",
        "label": "sodium_crypto_core_ristretto255_from_hash( $s:string )",
        "apply": "sodium_crypto_core_ristretto255_from_hash( $s:string )",
        "info": "Maps a 64-bytes vector s to a group element.Available as of libsodium 1.0.18."
    },
    "ƒ: sodium_crypto_core_ristretto255_is_valid_point": {
        "type": "function",
        "label": "sodium_crypto_core_ristretto255_is_valid_point( $s:string )",
        "apply": "sodium_crypto_core_ristretto255_is_valid_point( $s:string )",
        "info": "Determines if a point on the ristretto255 curve,in canonical form, on the main subgroup, and that the point doesn't have a small order.Available as of libsodium 1.0.18."
    },
    "ƒ: sodium_crypto_core_ristretto255_random": {
        "type": "function",
        "label": "sodium_crypto_core_ristretto255_random()",
        "apply": "sodium_crypto_core_ristretto255_random()",
        "info": "Generates a random key.Available as of libsodium 1.0.18."
    },
    "ƒ: sodium_crypto_core_ristretto255_scalar_add": {
        "type": "function",
        "label": "sodium_crypto_core_ristretto255_scalar_add( $x:string, $y:string )",
        "apply": "sodium_crypto_core_ristretto255_scalar_add( $x:string, $y:string )",
        "info": "Adds an element y to x.Available as of libsodium 1.0.18."
    },
    "ƒ: sodium_crypto_core_ristretto255_scalar_complement": {
        "type": "function",
        "label": "sodium_crypto_core_ristretto255_scalar_complement( $s:string )",
        "apply": "sodium_crypto_core_ristretto255_scalar_complement( $s:string )",
        "info": "Available as of libsodium 1.0.18."
    },
    "ƒ: sodium_crypto_core_ristretto255_scalar_invert": {
        "type": "function",
        "label": "sodium_crypto_core_ristretto255_scalar_invert( $s:string )",
        "apply": "sodium_crypto_core_ristretto255_scalar_invert( $s:string )",
        "info": "Inverts a scalar value.Available as of libsodium 1.0.18."
    },
    "ƒ: sodium_crypto_core_ristretto255_scalar_mul": {
        "type": "function",
        "label": "sodium_crypto_core_ristretto255_scalar_mul( $x:string, $y:string )",
        "apply": "sodium_crypto_core_ristretto255_scalar_mul( $x:string, $y:string )",
        "info": "Multiplies a scalar value.Available as of libsodium 1.0.18."
    },
    "ƒ: sodium_crypto_core_ristretto255_scalar_negate": {
        "type": "function",
        "label": "sodium_crypto_core_ristretto255_scalar_negate( $s:string )",
        "apply": "sodium_crypto_core_ristretto255_scalar_negate( $s:string )",
        "info": "Negates a scalar value.Available as of libsodium 1.0.18."
    },
    "ƒ: sodium_crypto_core_ristretto255_scalar_random": {
        "type": "function",
        "label": "sodium_crypto_core_ristretto255_scalar_random()",
        "apply": "sodium_crypto_core_ristretto255_scalar_random()",
        "info": "Generates a random key.Available as of libsodium 1.0.18."
    },
    "ƒ: sodium_crypto_core_ristretto255_scalar_reduce": {
        "type": "function",
        "label": "sodium_crypto_core_ristretto255_scalar_reduce( $s:string )",
        "apply": "sodium_crypto_core_ristretto255_scalar_reduce( $s:string )",
        "info": "Reduces a scalar value.Available as of libsodium 1.0.18."
    },
    "ƒ: sodium_crypto_core_ristretto255_scalar_sub": {
        "type": "function",
        "label": "sodium_crypto_core_ristretto255_scalar_sub( $x:string, $y:string )",
        "apply": "sodium_crypto_core_ristretto255_scalar_sub( $x:string, $y:string )",
        "info": "Subtracts a scalar y from x.Available as of libsodium 1.0.18."
    },
    "ƒ: sodium_crypto_core_ristretto255_sub": {
        "type": "function",
        "label": "sodium_crypto_core_ristretto255_sub( $p:string, $q:string )",
        "apply": "sodium_crypto_core_ristretto255_sub( $p:string, $q:string )",
        "info": "Subtracts an element q from p.Available as of libsodium 1.0.18."
    },
    "ƒ: sodium_crypto_kx_keypair": {
        "type": "function",
        "label": "sodium_crypto_kx_keypair()",
        "apply": "sodium_crypto_kx_keypair()",
        "info": "Create a new sodium keypair consisting of the secret key (32 bytes)followed by the public key (32 bytes). The keys can be retrieved by calling sodium_crypto_kx_secretkey() and sodium_crypto_kx_publickey(), respectively."
    },
    "ƒ: sodium_crypto_kx_publickey": {
        "type": "function",
        "label": "sodium_crypto_kx_publickey( $key_pair:string )",
        "apply": "sodium_crypto_kx_publickey( $key_pair:string )",
        "info": "Extract the public key from a crypto_kx keypair."
    },
    "ƒ: sodium_crypto_kx_secretkey": {
        "type": "function",
        "label": "sodium_crypto_kx_secretkey( $key_pair:string )",
        "apply": "sodium_crypto_kx_secretkey( $key_pair:string )",
        "info": "Extract the secret key from a crypto_kx keypair."
    },
    "ƒ: sodium_crypto_kx_seed_keypair": {
        "type": "function",
        "label": "sodium_crypto_kx_seed_keypair( $seed:string )",
        "apply": "sodium_crypto_kx_seed_keypair( $seed:string )",
        "info": ""
    },
    "ƒ: sodium_crypto_kx_client_session_keys": {
        "type": "function",
        "label": "sodium_crypto_kx_client_session_keys( $client_key_pair:string, $server_key:string )",
        "apply": "sodium_crypto_kx_client_session_keys( $client_key_pair:string, $server_key:string )",
        "info": "Calculate the client-side session keys, using the X25519 + BLAKE2b key-exchange method."
    },
    "ƒ: sodium_crypto_kx_server_session_keys": {
        "type": "function",
        "label": "sodium_crypto_kx_server_session_keys( $server_key_pair:string, $client_key:string )",
        "apply": "sodium_crypto_kx_server_session_keys( $server_key_pair:string, $client_key:string )",
        "info": "Calculate the server-side session keys, using the X25519 + BLAKE2b key-exchange method."
    },
    "ƒ: sodium_crypto_generichash": {
        "type": "function",
        "label": "sodium_crypto_generichash( $message:string, $key:string, $length:int )",
        "apply": "sodium_crypto_generichash( $message:string, $key:string, $length:int )",
        "info": "Hash a message with BLAKE2b."
    },
    "ƒ: sodium_crypto_generichash_keygen": {
        "type": "function",
        "label": "sodium_crypto_generichash_keygen()",
        "apply": "sodium_crypto_generichash_keygen()",
        "info": "Generate a random key for use with the generichash API."
    },
    "ƒ: sodium_crypto_generichash_init": {
        "type": "function",
        "label": "sodium_crypto_generichash_init( $key:string, $length:int )",
        "apply": "sodium_crypto_generichash_init( $key:string, $length:int )",
        "info": "The initialization method for the streaming generichash API."
    },
    "ƒ: sodium_crypto_generichash_update": {
        "type": "function",
        "label": "sodium_crypto_generichash_update( $state:string, $message:string )",
        "apply": "sodium_crypto_generichash_update( $state:string, $message:string )",
        "info": "Appends a message to the internal hash state."
    },
    "ƒ: sodium_crypto_generichash_final": {
        "type": "function",
        "label": "sodium_crypto_generichash_final( $state:string, $length:int )",
        "apply": "sodium_crypto_generichash_final( $state:string, $length:int )",
        "info": "The finalization method for the streaming generichash API."
    },
    "ƒ: sodium_crypto_kdf_derive_from_key": {
        "type": "function",
        "label": "sodium_crypto_kdf_derive_from_key( $subkey_length:int, $subkey_id:int, $context:string, $key:string )",
        "apply": "sodium_crypto_kdf_derive_from_key( $subkey_length:int, $subkey_id:int, $context:string, $key:string )",
        "info": "Derive a subkey from a root key and additional context."
    },
    "ƒ: sodium_crypto_kdf_keygen": {
        "type": "function",
        "label": "sodium_crypto_kdf_keygen()",
        "apply": "sodium_crypto_kdf_keygen()",
        "info": "Generates a random key suitable for serving as the root key for sodium_crypto_kdf_derive_from_key()."
    },
    "ƒ: sodium_crypto_pwhash": {
        "type": "function",
        "label": "sodium_crypto_pwhash( $length:int, $password:string, $salt:string, $opslimit:int, $memlimit:int, $algo:int )",
        "apply": "sodium_crypto_pwhash( $length:int, $password:string, $salt:string, $opslimit:int, $memlimit:int, $algo:int )",
        "info": "This function provides low-level access to libsodium's crypto_pwhash key derivation function. Unless you have specific reason to use this function, you should use sodium_crypto_pwhash_str() or password_hash() functions instead."
    },
    "ƒ: sodium_crypto_pwhash_str": {
        "type": "function",
        "label": "sodium_crypto_pwhash_str( $password:string, $opslimit:int, $memlimit:int )",
        "apply": "sodium_crypto_pwhash_str( $password:string, $opslimit:int, $memlimit:int )",
        "info": "Uses a CPU- and memory-hard hash algorithm along with a randomly-generated salt, and memory and CPU limits to generate an ASCII-encoded hash suitable for password storage."
    },
    "ƒ: sodium_crypto_pwhash_str_verify": {
        "type": "function",
        "label": "sodium_crypto_pwhash_str_verify( $hash:string, $password:string )",
        "apply": "sodium_crypto_pwhash_str_verify( $hash:string, $password:string )",
        "info": "Checks that a password hash created using sodium_crypto_pwhash_str() matches a given plain-text password. Note that the parameters are in the opposite order to the same parameters in the similar password_verify() function."
    },
    "ƒ: sodium_crypto_pwhash_str_needs_rehash": {
        "type": "function",
        "label": "sodium_crypto_pwhash_str_needs_rehash( $password:string, $opslimit:int, $memlimit:int )",
        "apply": "sodium_crypto_pwhash_str_needs_rehash( $password:string, $opslimit:int, $memlimit:int )",
        "info": "Determine whether or not to rehash a password, based on the current hash opslimit and memlimit."
    },
    "ƒ: sodium_crypto_pwhash_scryptsalsa208sha256": {
        "type": "function",
        "label": "sodium_crypto_pwhash_scryptsalsa208sha256( $length:int, $password:string, $salt:string, $opslimit:int, $memlimit:int )",
        "apply": "sodium_crypto_pwhash_scryptsalsa208sha256( $length:int, $password:string, $salt:string, $opslimit:int, $memlimit:int )",
        "info": "This is the scrypt counterpart to sodium_crypto_pwhash()."
    },
    "ƒ: sodium_crypto_pwhash_scryptsalsa208sha256_str": {
        "type": "function",
        "label": "sodium_crypto_pwhash_scryptsalsa208sha256_str( $password:string, $opslimit:int, $memlimit:int )",
        "apply": "sodium_crypto_pwhash_scryptsalsa208sha256_str( $password:string, $opslimit:int, $memlimit:int )",
        "info": ""
    },
    "ƒ: sodium_crypto_pwhash_scryptsalsa208sha256_str_verify": {
        "type": "function",
        "label": "sodium_crypto_pwhash_scryptsalsa208sha256_str_verify( $hash:string, $password:string )",
        "apply": "sodium_crypto_pwhash_scryptsalsa208sha256_str_verify( $hash:string, $password:string )",
        "info": ""
    },
    "ƒ: sodium_crypto_scalarmult": {
        "type": "function",
        "label": "sodium_crypto_scalarmult( $n:string, $p:string )",
        "apply": "sodium_crypto_scalarmult( $n:string, $p:string )",
        "info": "Elliptic Curve Diffie-Hellman. Calculates scalar n times point p, on an elliptic curve."
    },
    "ƒ: sodium_crypto_scalarmult_ristretto255": {
        "type": "function",
        "label": "sodium_crypto_scalarmult_ristretto255( $n:string, $p:string )",
        "apply": "sodium_crypto_scalarmult_ristretto255( $n:string, $p:string )",
        "info": "Calculates scalar n times point p.Available as of libsodium 1.0.18."
    },
    "ƒ: sodium_crypto_scalarmult_ristretto255_base": {
        "type": "function",
        "label": "sodium_crypto_scalarmult_ristretto255_base( $n:string )",
        "apply": "sodium_crypto_scalarmult_ristretto255_base( $n:string )",
        "info": "Given a secret key, calculates the corresponding public key.Available as of libsodium 1.0.18."
    },
    "ƒ: sodium_crypto_secretbox": {
        "type": "function",
        "label": "sodium_crypto_secretbox( $message:string, $nonce:string, $key:string )",
        "apply": "sodium_crypto_secretbox( $message:string, $nonce:string, $key:string )",
        "info": "Encrypt a message with a symmetric (shared) key."
    },
    "ƒ: sodium_crypto_secretbox_keygen": {
        "type": "function",
        "label": "sodium_crypto_secretbox_keygen()",
        "apply": "sodium_crypto_secretbox_keygen()",
        "info": "Generate a key for use with sodium_crypto_secretbox() and sodium_crypto_secretbox_open()."
    },
    "ƒ: sodium_crypto_secretbox_open": {
        "type": "function",
        "label": "sodium_crypto_secretbox_open( $ciphertext:string, $nonce:string, $key:string )",
        "apply": "sodium_crypto_secretbox_open( $ciphertext:string, $nonce:string, $key:string )",
        "info": "Decrypt an encrypted message with a symmetric (shared) key."
    },
    "ƒ: sodium_crypto_secretstream_xchacha20poly1305_keygen": {
        "type": "function",
        "label": "sodium_crypto_secretstream_xchacha20poly1305_keygen()",
        "apply": "sodium_crypto_secretstream_xchacha20poly1305_keygen()",
        "info": "Generate a random secretstream key."
    },
    "ƒ: sodium_crypto_secretstream_xchacha20poly1305_init_push": {
        "type": "function",
        "label": "sodium_crypto_secretstream_xchacha20poly1305_init_push( $key:string )",
        "apply": "sodium_crypto_secretstream_xchacha20poly1305_init_push( $key:string )",
        "info": "Initialize a secretstream context for encryption."
    },
    "ƒ: sodium_crypto_secretstream_xchacha20poly1305_push": {
        "type": "function",
        "label": "sodium_crypto_secretstream_xchacha20poly1305_push( $state:string, $message:string, $additional_data:string, $tag:int )",
        "apply": "sodium_crypto_secretstream_xchacha20poly1305_push( $state:string, $message:string, $additional_data:string, $tag:int )",
        "info": "Encrypt a chunk of data so that it can safely be decrypted in a streaming API."
    },
    "ƒ: sodium_crypto_secretstream_xchacha20poly1305_init_pull": {
        "type": "function",
        "label": "sodium_crypto_secretstream_xchacha20poly1305_init_pull( $header:string, $key:string )",
        "apply": "sodium_crypto_secretstream_xchacha20poly1305_init_pull( $header:string, $key:string )",
        "info": "Initialize a secretstream context for decryption."
    },
    "ƒ: sodium_crypto_secretstream_xchacha20poly1305_pull": {
        "type": "function",
        "label": "sodium_crypto_secretstream_xchacha20poly1305_pull( $state:string, $ciphertext:string, $additional_data:string )",
        "apply": "sodium_crypto_secretstream_xchacha20poly1305_pull( $state:string, $ciphertext:string, $additional_data:string )",
        "info": "Decrypt a chunk of data from an encrypted stream."
    },
    "ƒ: sodium_crypto_secretstream_xchacha20poly1305_rekey": {
        "type": "function",
        "label": "sodium_crypto_secretstream_xchacha20poly1305_rekey( $state:string )",
        "apply": "sodium_crypto_secretstream_xchacha20poly1305_rekey( $state:string )",
        "info": "Explicitly rotate the key in the secretstream state. Overwrites the value passed in."
    },
    "ƒ: sodium_crypto_shorthash": {
        "type": "function",
        "label": "sodium_crypto_shorthash( $message:string, $key:string )",
        "apply": "sodium_crypto_shorthash( $message:string, $key:string )",
        "info": "sodium_crypto_shorthash() wraps a hash function called SipHash-2-4, which is ideal for implementing hash tables that are not susceptible to hash collision denial of service attacks (Hash-DoS)."
    },
    "ƒ: sodium_crypto_shorthash_keygen": {
        "type": "function",
        "label": "sodium_crypto_shorthash_keygen()",
        "apply": "sodium_crypto_shorthash_keygen()",
        "info": "Generate a key for use with sodium_crypto_shorthash()."
    },
    "ƒ: sodium_crypto_sign": {
        "type": "function",
        "label": "sodium_crypto_sign( $message:string, $secret_key:string )",
        "apply": "sodium_crypto_sign( $message:string, $secret_key:string )",
        "info": "Sign a message with a secret key, that can be verified by the corresponding public key.This function attaches the signature to the message. See sodium_crypto_sign_detached()for detached signatures."
    },
    "ƒ: sodium_crypto_sign_detached": {
        "type": "function",
        "label": "sodium_crypto_sign_detached( $message:string, $secret_key:string )",
        "apply": "sodium_crypto_sign_detached( $message:string, $secret_key:string )",
        "info": "Sign a message with a secret key, that can be verified by the corresponding public key.This function returns a detached signature."
    },
    "ƒ: sodium_crypto_sign_ed25519_pk_to_curve25519": {
        "type": "function",
        "label": "sodium_crypto_sign_ed25519_pk_to_curve25519( $public_key:string )",
        "apply": "sodium_crypto_sign_ed25519_pk_to_curve25519( $public_key:string )",
        "info": "Given an Ed25519 public key, calculate the birationally equivalent X25519 public key."
    },
    "ƒ: sodium_crypto_sign_ed25519_sk_to_curve25519": {
        "type": "function",
        "label": "sodium_crypto_sign_ed25519_sk_to_curve25519( $secret_key:string )",
        "apply": "sodium_crypto_sign_ed25519_sk_to_curve25519( $secret_key:string )",
        "info": "Given an Ed25519 secret key, calculate the birationally equivalent X25519 secret key."
    },
    "ƒ: sodium_crypto_sign_keypair": {
        "type": "function",
        "label": "sodium_crypto_sign_keypair()",
        "apply": "sodium_crypto_sign_keypair()",
        "info": "Generate a random Ed25519 keypair as one string."
    },
    "ƒ: sodium_crypto_sign_keypair_from_secretkey_and_publickey": {
        "type": "function",
        "label": "sodium_crypto_sign_keypair_from_secretkey_and_publickey( $secret_key:string, $public_key:string )",
        "apply": "sodium_crypto_sign_keypair_from_secretkey_and_publickey( $secret_key:string, $public_key:string )",
        "info": "Join a secret key and public key together."
    },
    "ƒ: sodium_crypto_sign_open": {
        "type": "function",
        "label": "sodium_crypto_sign_open( $signed_message:string, $public_key:string )",
        "apply": "sodium_crypto_sign_open( $signed_message:string, $public_key:string )",
        "info": "Verify the signature attached to a message and return the message "
    },
    "ƒ: sodium_crypto_sign_publickey": {
        "type": "function",
        "label": "sodium_crypto_sign_publickey( $key_pair:string )",
        "apply": "sodium_crypto_sign_publickey( $key_pair:string )",
        "info": "Extract the Ed25519 public key from a keypair "
    },
    "ƒ: sodium_crypto_sign_secretkey": {
        "type": "function",
        "label": "sodium_crypto_sign_secretkey( $key_pair:string )",
        "apply": "sodium_crypto_sign_secretkey( $key_pair:string )",
        "info": "Extract the Ed25519 secret key from a keypair "
    },
    "ƒ: sodium_crypto_sign_publickey_from_secretkey": {
        "type": "function",
        "label": "sodium_crypto_sign_publickey_from_secretkey( $secret_key:string )",
        "apply": "sodium_crypto_sign_publickey_from_secretkey( $secret_key:string )",
        "info": "Extract the Ed25519 public key from the secret key "
    },
    "ƒ: sodium_crypto_sign_seed_keypair": {
        "type": "function",
        "label": "sodium_crypto_sign_seed_keypair( $seed:string )",
        "apply": "sodium_crypto_sign_seed_keypair( $seed:string )",
        "info": "Clamps the seed to form a secret key, derives the public key, and returns the two as a keypair."
    },
    "ƒ: sodium_crypto_sign_verify_detached": {
        "type": "function",
        "label": "sodium_crypto_sign_verify_detached( $signature:string, $message:string, $public_key:string )",
        "apply": "sodium_crypto_sign_verify_detached( $signature:string, $message:string, $public_key:string )",
        "info": "Verify signature for the message "
    },
    "ƒ: sodium_crypto_stream": {
        "type": "function",
        "label": "sodium_crypto_stream( $length:int, $nonce:string, $key:string )",
        "apply": "sodium_crypto_stream( $length:int, $nonce:string, $key:string )",
        "info": "Generate a deterministic sequence of bytes from a seed, using the XSalsa20 stream cipher."
    },
    "ƒ: sodium_crypto_stream_keygen": {
        "type": "function",
        "label": "sodium_crypto_stream_keygen()",
        "apply": "sodium_crypto_stream_keygen()",
        "info": "Generate a key for use with sodium_crypto_stream() and sodium_crypto_stream_xor()."
    },
    "ƒ: sodium_crypto_stream_xor": {
        "type": "function",
        "label": "sodium_crypto_stream_xor( $message:string, $nonce:string, $key:string )",
        "apply": "sodium_crypto_stream_xor( $message:string, $nonce:string, $key:string )",
        "info": "This function encrypts a message with XSalsa20, but does not provide any ciphertext guarantees about the plaintext."
    },
    "ƒ: sodium_crypto_stream_xchacha20": {
        "type": "function",
        "label": "sodium_crypto_stream_xchacha20( $length:int, $nonce:string, $key:string )",
        "apply": "sodium_crypto_stream_xchacha20( $length:int, $nonce:string, $key:string )",
        "info": "Expands the key and nonce into a keystream of pseudorandom bytes."
    },
    "ƒ: sodium_crypto_stream_xchacha20_keygen": {
        "type": "function",
        "label": "sodium_crypto_stream_xchacha20_keygen()",
        "apply": "sodium_crypto_stream_xchacha20_keygen()",
        "info": "Returns a secure random key for use with sodium_crypto_stream_xchacha20()."
    },
    "ƒ: sodium_crypto_stream_xchacha20_xor": {
        "type": "function",
        "label": "sodium_crypto_stream_xchacha20_xor( $message:string, $nonce:string, $key:string )",
        "apply": "sodium_crypto_stream_xchacha20_xor( $message:string, $nonce:string, $key:string )",
        "info": "Encrypts a message using a nonce and a secret key (no authentication)."
    },
    "ƒ: sodium_add": {
        "type": "function",
        "label": "sodium_add( $string1:string, $string2:string )",
        "apply": "sodium_add( $string1:string, $string2:string )",
        "info": "This adds the parameter string2 to string1, overwriting the value stored in string1. This function assumes both parameters are binary strings that represent unsigned integers in little-endian byte order."
    },
    "ƒ: sodium_compare": {
        "type": "function",
        "label": "sodium_compare( $string1:string, $string2:string )",
        "apply": "sodium_compare( $string1:string, $string2:string )",
        "info": "Compare two strings as if they were arbitrary-length, unsigned little-endian integers, without side-channel leakage."
    },
    "ƒ: sodium_increment": {
        "type": "function",
        "label": "sodium_increment( $string:string )",
        "apply": "sodium_increment( $string:string )",
        "info": "Treat the string as a little-endian unsigned integer, then increase it by 1.Constant-time."
    },
    "ƒ: sodium_memcmp": {
        "type": "function",
        "label": "sodium_memcmp( $string1:string, $string2:string )",
        "apply": "sodium_memcmp( $string1:string, $string2:string )",
        "info": "Compare two strings in constant-time."
    },
    "ƒ: sodium_memzero": {
        "type": "function",
        "label": "sodium_memzero( $string:string )",
        "apply": "sodium_memzero( $string:string )",
        "info": "sodium_memzero() zeroes out the string that is passed by reference."
    },
    "ƒ: sodium_pad": {
        "type": "function",
        "label": "sodium_pad( $string:string, $block_size:int )",
        "apply": "sodium_pad( $string:string, $block_size:int )",
        "info": "Right-pad a string to a desired length. Timing-safe."
    },
    "ƒ: sodium_unpad": {
        "type": "function",
        "label": "sodium_unpad( $string:string, $block_size:int )",
        "apply": "sodium_unpad( $string:string, $block_size:int )",
        "info": "Unpad a padded string. Timing-safe."
    },
    "ƒ: sodium_bin2hex": {
        "type": "function",
        "label": "sodium_bin2hex( $string:string )",
        "apply": "sodium_bin2hex( $string:string )",
        "info": "Converts a raw binary string into a hex-encoded string. Unlike the standard hex-encoding function,sodium_bin2hex() is constant-time (a property that is important for any code that touches cryptographic inputs, such as plaintexts or keys)."
    },
    "ƒ: sodium_hex2bin": {
        "type": "function",
        "label": "sodium_hex2bin( $string:string, $ignore:string )",
        "apply": "sodium_hex2bin( $string:string, $ignore:string )",
        "info": "Decodes a hexadecimally encoded binary string."
    },
    "ƒ: sodium_bin2base64": {
        "type": "function",
        "label": "sodium_bin2base64( $string:string, $id:int )",
        "apply": "sodium_bin2base64( $string:string, $id:int )",
        "info": "Converts a raw binary string into a base64-encoded string. Unlike base64_encode(),sodium_bin2base64() is constant-time (a property that is important for any code that touches cryptographic inputs, such as plaintexts or keys) and supports multiple character sets."
    },
    "ƒ: sodium_base642bin": {
        "type": "function",
        "label": "sodium_base642bin( $string:string, $id:int, $ignore:string )",
        "apply": "sodium_base642bin( $string:string, $id:int, $ignore:string )",
        "info": "Converts a base64 encoded string into raw binary. Unlike base64_decode(),sodium_base642bin() is constant-time (a property that is important for any code that touches cryptographic inputs, such as plaintexts or keys) and supports multiple character sets."
    },
    "ƒ: sodium_crypto_scalarmult_base": {
        "type": "function",
        "label": "sodium_crypto_scalarmult_base( $secret_key:string )",
        "apply": "sodium_crypto_scalarmult_base( $secret_key:string )",
        "info": "This function is an alias of: sodium_crypto_box_publickey_from_secretkey()."
    },
    "ƒ: zip_open": {
        "type": "function",
        "label": "zip_open( $filename:string )",
        "apply": "zip_open( $filename:string )",
        "info": "Opens a new zip archive for reading. "
    },
    "ƒ: zip_close": {
        "type": "function",
        "label": "zip_close( $zip: )",
        "apply": "zip_close( $zip: )",
        "info": "Closes the given ZIP file archive."
    },
    "ƒ: zip_read": {
        "type": "function",
        "label": "zip_read( $zip: )",
        "apply": "zip_read( $zip: )",
        "info": "Reads the next entry in a zip file archive."
    },
    "ƒ: zip_entry_open": {
        "type": "function",
        "label": "zip_entry_open( $zip_dp:, $zip_entry:, $mode:string )",
        "apply": "zip_entry_open( $zip_dp:, $zip_entry:, $mode:string )",
        "info": "Opens a directory entry in a zip file for reading."
    },
    "ƒ: zip_entry_close": {
        "type": "function",
        "label": "zip_entry_close( $zip_entry: )",
        "apply": "zip_entry_close( $zip_entry: )",
        "info": "Closes the specified directory entry."
    },
    "ƒ: zip_entry_read": {
        "type": "function",
        "label": "zip_entry_read( $zip_entry:, $len:int )",
        "apply": "zip_entry_read( $zip_entry:, $len:int )",
        "info": "Reads from an open directory entry."
    },
    "ƒ: zip_entry_name": {
        "type": "function",
        "label": "zip_entry_name( $zip_entry: )",
        "apply": "zip_entry_name( $zip_entry: )",
        "info": "Returns the name of the specified directory entry."
    },
    "ƒ: zip_entry_compressedsize": {
        "type": "function",
        "label": "zip_entry_compressedsize( $zip_entry: )",
        "apply": "zip_entry_compressedsize( $zip_entry: )",
        "info": "Returns the compressed size of the specified directory entry."
    },
    "ƒ: zip_entry_filesize": {
        "type": "function",
        "label": "zip_entry_filesize( $zip_entry: )",
        "apply": "zip_entry_filesize( $zip_entry: )",
        "info": "Returns the actual size of the specified directory entry."
    },
    "ƒ: zip_entry_compressionmethod": {
        "type": "function",
        "label": "zip_entry_compressionmethod( $zip_entry: )",
        "apply": "zip_entry_compressionmethod( $zip_entry: )",
        "info": "Returns the compression method of the directory entry specified by zip_entry."
    },
    "ƒ: opcache_reset": {
        "type": "function",
        "label": "opcache_reset()",
        "apply": "opcache_reset()",
        "info": "This function resets the entire opcode cache. After calling opcache_reset(), all scripts will be reloaded and reparsed the next time they are hit. This function only resets in-memory cache, not the file cache."
    },
    "ƒ: opcache_get_status": {
        "type": "function",
        "label": "opcache_get_status( $include_scripts:bool )",
        "apply": "opcache_get_status( $include_scripts:bool )",
        "info": "This function returns state information about the in-memory cache instance. It will not return any information about the file cache."
    },
    "ƒ: opcache_compile_file": {
        "type": "function",
        "label": "opcache_compile_file( $filename:string )",
        "apply": "opcache_compile_file( $filename:string )",
        "info": "This function compiles a PHP script and adds it to the opcode cache without executing it. This can be used to prime the cache after a Web server restart by pre-caching files that will be included in later requests."
    },
    "ƒ: opcache_invalidate": {
        "type": "function",
        "label": "opcache_invalidate( $filename:string, $force:bool )",
        "apply": "opcache_invalidate( $filename:string, $force:bool )",
        "info": "This function invalidates a particular script from the opcode cache. If force is unset or false, the script will only be invalidated if the modification time of the script is newer than the cached opcodes. This function only invalidates in-memory cache and not file cache."
    },
    "ƒ: opcache_get_configuration": {
        "type": "function",
        "label": "opcache_get_configuration()",
        "apply": "opcache_get_configuration()",
        "info": "This function returns configuration information about the cache instance "
    },
    "ƒ: opcache_is_script_cached": {
        "type": "function",
        "label": "opcache_is_script_cached( $filename:string )",
        "apply": "opcache_is_script_cached( $filename:string )",
        "info": "This function checks if a PHP script has been cached in OPCache. This can be used to more easily detect the \"warming\" of the cache for a particular script.This function only checks in-memory cache, not file cache."
    },
    "ƒ: xmlwriter_open_memory": {
        "type": "function",
        "label": "xmlwriter_open_memory()",
        "apply": "xmlwriter_open_memory()",
        "info": "Creates a new XMLWriter using memory for string output.  "
    },
    "ƒ: xmlwriter_set_indent": {
        "type": "function",
        "label": "xmlwriter_set_indent( $writer:XMLWriter, $enable:bool )",
        "apply": "xmlwriter_set_indent( $writer:XMLWriter, $enable:bool )",
        "info": "Toggles indentation on or off."
    },
    "ƒ: xmlwriter_set_indent_string": {
        "type": "function",
        "label": "xmlwriter_set_indent_string( $writer:XMLWriter, $indentation:string )",
        "apply": "xmlwriter_set_indent_string( $writer:XMLWriter, $indentation:string )",
        "info": "Sets the string which will be used to indent each element\/attribute of the resulting xml."
    },
    "ƒ: xmlwriter_start_comment": {
        "type": "function",
        "label": "xmlwriter_start_comment( $writer:XMLWriter )",
        "apply": "xmlwriter_start_comment( $writer:XMLWriter )",
        "info": "Starts a comment."
    },
    "ƒ: xmlwriter_end_comment": {
        "type": "function",
        "label": "xmlwriter_end_comment( $writer:XMLWriter )",
        "apply": "xmlwriter_end_comment( $writer:XMLWriter )",
        "info": "Ends the current comment.  "
    },
    "ƒ: xmlwriter_start_element": {
        "type": "function",
        "label": "xmlwriter_start_element( $writer:XMLWriter, $name:string )",
        "apply": "xmlwriter_start_element( $writer:XMLWriter, $name:string )",
        "info": "Starts an element."
    },
    "ƒ: xmlwriter_end_element": {
        "type": "function",
        "label": "xmlwriter_end_element( $writer:XMLWriter )",
        "apply": "xmlwriter_end_element( $writer:XMLWriter )",
        "info": "Ends the current element."
    },
    "ƒ: xmlwriter_full_end_element": {
        "type": "function",
        "label": "xmlwriter_full_end_element( $writer:XMLWriter )",
        "apply": "xmlwriter_full_end_element( $writer:XMLWriter )",
        "info": "End the current xml element. Writes an end tag even if the element is empty."
    },
    "ƒ: xmlwriter_start_element_ns": {
        "type": "function",
        "label": "xmlwriter_start_element_ns( $writer:XMLWriter, $prefix:?string, $name:string, $namespace:?string )",
        "apply": "xmlwriter_start_element_ns( $writer:XMLWriter, $prefix:?string, $name:string, $namespace:?string )",
        "info": "Starts a namespaced element."
    },
    "ƒ: xmlwriter_write_element": {
        "type": "function",
        "label": "xmlwriter_write_element( $writer:XMLWriter, $name:string, $content:?string )",
        "apply": "xmlwriter_write_element( $writer:XMLWriter, $name:string, $content:?string )",
        "info": "Writes a full element tag."
    },
    "ƒ: xmlwriter_end_cdata": {
        "type": "function",
        "label": "xmlwriter_end_cdata( $writer:XMLWriter )",
        "apply": "xmlwriter_end_cdata( $writer:XMLWriter )",
        "info": "Ends the current CDATA section.  "
    },
    "ƒ: xmlwriter_write_cdata": {
        "type": "function",
        "label": "xmlwriter_write_cdata( $writer:XMLWriter, $content:string )",
        "apply": "xmlwriter_write_cdata( $writer:XMLWriter, $content:string )",
        "info": "Writes a full CDATA."
    },
    "ƒ: xmlwriter_text": {
        "type": "function",
        "label": "xmlwriter_text( $writer:XMLWriter, $content:string )",
        "apply": "xmlwriter_text( $writer:XMLWriter, $content:string )",
        "info": "Object-oriented style"
    },
    "ƒ: xmlwriter_write_raw": {
        "type": "function",
        "label": "xmlwriter_write_raw( $writer:XMLWriter, $content:string )",
        "apply": "xmlwriter_write_raw( $writer:XMLWriter, $content:string )",
        "info": "Writes a raw xml text."
    },
    "ƒ: xmlwriter_start_document": {
        "type": "function",
        "label": "xmlwriter_start_document( $writer:XMLWriter, $version:?string, $encoding:?string, $standalone:?string )",
        "apply": "xmlwriter_start_document( $writer:XMLWriter, $version:?string, $encoding:?string, $standalone:?string )",
        "info": "Starts a document."
    },
    "ƒ: xmlwriter_end_document": {
        "type": "function",
        "label": "xmlwriter_end_document( $writer:XMLWriter )",
        "apply": "xmlwriter_end_document( $writer:XMLWriter )",
        "info": "Ends the current document."
    },
    "ƒ: xmlwriter_write_comment": {
        "type": "function",
        "label": "xmlwriter_write_comment( $writer:XMLWriter, $content:string )",
        "apply": "xmlwriter_write_comment( $writer:XMLWriter, $content:string )",
        "info": "Writes a full comment."
    },
    "ƒ: xmlwriter_start_dtd": {
        "type": "function",
        "label": "xmlwriter_start_dtd( $writer:XMLWriter, $qualifiedName:string, $publicId:?string, $systemId:?string )",
        "apply": "xmlwriter_start_dtd( $writer:XMLWriter, $qualifiedName:string, $publicId:?string, $systemId:?string )",
        "info": "Starts a DTD."
    },
    "ƒ: xmlwriter_end_dtd": {
        "type": "function",
        "label": "xmlwriter_end_dtd( $writer:XMLWriter )",
        "apply": "xmlwriter_end_dtd( $writer:XMLWriter )",
        "info": "Ends the DTD of the document."
    },
    "ƒ: xmlwriter_write_dtd": {
        "type": "function",
        "label": "xmlwriter_write_dtd( $writer:XMLWriter, $name:string, $publicId:?string, $systemId:?string, $content:?string )",
        "apply": "xmlwriter_write_dtd( $writer:XMLWriter, $name:string, $publicId:?string, $systemId:?string, $content:?string )",
        "info": "Writes a full DTD."
    },
    "ƒ: xmlwriter_start_dtd_element": {
        "type": "function",
        "label": "xmlwriter_start_dtd_element( $writer:XMLWriter, $qualifiedName:string )",
        "apply": "xmlwriter_start_dtd_element( $writer:XMLWriter, $qualifiedName:string )",
        "info": "Starts a DTD element."
    },
    "ƒ: xmlwriter_end_dtd_element": {
        "type": "function",
        "label": "xmlwriter_end_dtd_element( $writer:XMLWriter )",
        "apply": "xmlwriter_end_dtd_element( $writer:XMLWriter )",
        "info": "Ends the current DTD element."
    },
    "ƒ: xmlwriter_write_dtd_element": {
        "type": "function",
        "label": "xmlwriter_write_dtd_element( $writer:XMLWriter, $name:string, $content:string )",
        "apply": "xmlwriter_write_dtd_element( $writer:XMLWriter, $name:string, $content:string )",
        "info": "Writes a full DTD element."
    },
    "ƒ: xmlwriter_start_dtd_attlist": {
        "type": "function",
        "label": "xmlwriter_start_dtd_attlist( $writer:XMLWriter, $name:string )",
        "apply": "xmlwriter_start_dtd_attlist( $writer:XMLWriter, $name:string )",
        "info": "Starts a DTD attribute list."
    },
    "ƒ: xmlwriter_end_dtd_attlist": {
        "type": "function",
        "label": "xmlwriter_end_dtd_attlist( $writer:XMLWriter )",
        "apply": "xmlwriter_end_dtd_attlist( $writer:XMLWriter )",
        "info": "Ends the current DTD attribute list."
    },
    "ƒ: intlcal_create_instance": {
        "type": "function",
        "label": "intlcal_create_instance( $timezone:, $locale:?string )",
        "apply": "intlcal_create_instance( $timezone:, $locale:?string )",
        "info": "The calendar created will represent the time instance at which it was created, based on the system time. The fields can all be cleared by calling IntCalendar::clear() with no arguments. See also IntlGregorianCalendar::__construct()."
    },
    "ƒ: intlcal_get_keyword_values_for_locale": {
        "type": "function",
        "label": "intlcal_get_keyword_values_for_locale( $keyword:string, $locale:string, $onlyCommon:bool )",
        "apply": "intlcal_get_keyword_values_for_locale( $keyword:string, $locale:string, $onlyCommon:bool )",
        "info": "This function requires ICU 4.2 or later."
    },
    "ƒ: intlcal_get_now": {
        "type": "function",
        "label": "intlcal_get_now()",
        "apply": "intlcal_get_now()",
        "info": "The number of milliseconds  that have passed since the reference date. This number is derived from the system time."
    },
    "ƒ: intlcal_get_available_locales": {
        "type": "function",
        "label": "intlcal_get_available_locales()",
        "apply": "intlcal_get_available_locales()",
        "info": "Gives the list of locales for which calendars are installed. As of ICU 51,this is the list of all installed ICU locales."
    },
    "ƒ: intlcal_get": {
        "type": "function",
        "label": "intlcal_get( $calendar:IntlCalendar, $field:int )",
        "apply": "intlcal_get( $calendar:IntlCalendar, $field:int )",
        "info": "Gets the value for a specific field."
    },
    "ƒ: intlcal_get_time": {
        "type": "function",
        "label": "intlcal_get_time( $calendar:IntlCalendar )",
        "apply": "intlcal_get_time( $calendar:IntlCalendar )",
        "info": "Returns the time associated with this object, expressed as the number of milliseconds since the epoch."
    },
    "ƒ: intlcal_set_time": {
        "type": "function",
        "label": "intlcal_set_time( $calendar:IntlCalendar, $timestamp:float )",
        "apply": "intlcal_set_time( $calendar:IntlCalendar, $timestamp:float )",
        "info": "Sets the instant represented by this object. The instant is represented by a float whose value should be an integer number of milliseconds since the epoch (1 Jan 1970 00:00:00.000 UTC), ignoring leap seconds. All the field values will be recalculated accordingly."
    },
    "ƒ: intlcal_add": {
        "type": "function",
        "label": "intlcal_add( $calendar:IntlCalendar, $field:int, $value:int )",
        "apply": "intlcal_add( $calendar:IntlCalendar, $field:int, $value:int )",
        "info": "Other fields may need to adjusted \u2013 for instance, adding a month to the 31st of January will result in the 28th (or 29th) of February. Contrary to IntlCalendar::roll(), when a value wraps around, more significant fields may change. For instance, adding a day to the 31st of January will result in the 1st of February, not the 1st of January."
    },
    "ƒ: intlcal_set_time_zone": {
        "type": "function",
        "label": "intlcal_set_time_zone( $calendar:IntlCalendar, $timezone: )",
        "apply": "intlcal_set_time_zone( $calendar:IntlCalendar, $timezone: )",
        "info": "Defines a new timezone for this calendar. The time represented by the object is preserved to the detriment of the field values."
    },
    "ƒ: intlcal_after": {
        "type": "function",
        "label": "intlcal_after( $calendar:IntlCalendar, $other:IntlCalendar )",
        "apply": "intlcal_after( $calendar:IntlCalendar, $other:IntlCalendar )",
        "info": "Returns whether this object\u02bcs time succeeds the argument\u02bcs time."
    },
    "ƒ: intlcal_before": {
        "type": "function",
        "label": "intlcal_before( $calendar:IntlCalendar, $other:IntlCalendar )",
        "apply": "intlcal_before( $calendar:IntlCalendar, $other:IntlCalendar )",
        "info": "Returns whether this object\u02bcs time precedes the argument\u02bcs time."
    },
    "ƒ: intlcal_set": {
        "type": "function",
        "label": "intlcal_set( $calendar:IntlCalendar, $year:int, $month:int, $dayOfMonth:int, $hour:int, $minute:int, $second:int )",
        "apply": "intlcal_set( $calendar:IntlCalendar, $year:int, $month:int, $dayOfMonth:int, $hour:int, $minute:int, $second:int )",
        "info": "This method cannot be called with exactly four arguments."
    },
    "ƒ: intlcal_roll": {
        "type": "function",
        "label": "intlcal_roll( $calendar:IntlCalendar, $field:int, $value: )",
        "apply": "intlcal_roll( $calendar:IntlCalendar, $field:int, $value: )",
        "info": "Adds a (signed) amount to a field. The difference with respect to IntlCalendar::add() is that when the field value overflows, it does not carry into more significant fields."
    },
    "ƒ: intlcal_clear": {
        "type": "function",
        "label": "intlcal_clear( $calendar:IntlCalendar, $field:?int )",
        "apply": "intlcal_clear( $calendar:IntlCalendar, $field:?int )",
        "info": "Clears either all of the fields or a specific field. A cleared field is marked as unset, giving it the lowest priority against overlapping fields or even default values when calculating the time. Additionally, its value is set to 0, though given the field\u02bcs low priority, its value may have been internally set to another value by the time the field has finished been queried."
    },
    "ƒ: intlcal_field_difference": {
        "type": "function",
        "label": "intlcal_field_difference( $calendar:IntlCalendar, $timestamp:float, $field:int )",
        "apply": "intlcal_field_difference( $calendar:IntlCalendar, $timestamp:float, $field:int )",
        "info": "This method is meant to be called successively, first with the most significant field of interest down to the least significant field. To this end, as a side effect, this calendar\u02bcs value for the field specified is advanced by the amount returned."
    },
    "ƒ: intlcal_get_actual_maximum": {
        "type": "function",
        "label": "intlcal_get_actual_maximum( $calendar:IntlCalendar, $field:int )",
        "apply": "intlcal_get_actual_maximum( $calendar:IntlCalendar, $field:int )",
        "info": "For instance, in the gregorian calendar, the actual maximum value for the day of month would vary between 28 and 31, depending on the month and year of the current time."
    },
    "ƒ: intlcal_get_actual_minimum": {
        "type": "function",
        "label": "intlcal_get_actual_minimum( $calendar:IntlCalendar, $field:int )",
        "apply": "intlcal_get_actual_minimum( $calendar:IntlCalendar, $field:int )",
        "info": "For the Gregorian calendar, this is always the same as IntlCalendar::getMinimum()."
    },
    "ƒ: intlcal_get_day_of_week_type": {
        "type": "function",
        "label": "intlcal_get_day_of_week_type( $calendar:IntlCalendar, $dayOfWeek:int )",
        "apply": "intlcal_get_day_of_week_type( $calendar:IntlCalendar, $dayOfWeek:int )",
        "info": "This function requires ICU 4.4 or later."
    },
    "ƒ: intlcal_get_first_day_of_week": {
        "type": "function",
        "label": "intlcal_get_first_day_of_week( $calendar:IntlCalendar )",
        "apply": "intlcal_get_first_day_of_week( $calendar:IntlCalendar )",
        "info": "The week day deemed to start a week, either the default value for this locale or the value set with IntlCalendar::setFirstDayOfWeek()."
    },
    "ƒ: intlcal_get_least_maximum": {
        "type": "function",
        "label": "intlcal_get_least_maximum( $calendar:IntlCalendar, $field:int )",
        "apply": "intlcal_get_least_maximum( $calendar:IntlCalendar, $field:int )",
        "info": "Returns the smallest local maximumw for a field. This should be a value smaller or equal to that returned by IntlCalendar::getActualMaxmimum(), which is in its turn smaller or equal to that returned by IntlCalendar::getMaximum()."
    },
    "ƒ: intlcal_get_greatest_minimum": {
        "type": "function",
        "label": "intlcal_get_greatest_minimum( $calendar:IntlCalendar, $field:int )",
        "apply": "intlcal_get_greatest_minimum( $calendar:IntlCalendar, $field:int )",
        "info": "Returns the largest local minimum for a field. This should be a value larger or equal to that returned by IntlCalendar::getActualMinimum(), which is in its turn larger or equal to that returned by IntlCalendar::getMinimum(). All these three functions return the same value for the Gregorian calendar."
    },
    "ƒ: intlcal_get_locale": {
        "type": "function",
        "label": "intlcal_get_locale( $calendar:IntlCalendar, $type:int )",
        "apply": "intlcal_get_locale( $calendar:IntlCalendar, $type:int )",
        "info": "Returns the locale used by this calendar object."
    },
    "ƒ: intlcal_get_maximum": {
        "type": "function",
        "label": "intlcal_get_maximum( $calendar:IntlCalendar, $field:int )",
        "apply": "intlcal_get_maximum( $calendar:IntlCalendar, $field:int )",
        "info": "Gets the global maximum for a field, in this specific calendar. This value is larger or equal to that returned by IntlCalendar::getActualMaximum(), which is in its turn larger or equal to that returned by IntlCalendar::getLeastMaximum()."
    },
    "ƒ: intlcal_get_minimal_days_in_first_week": {
        "type": "function",
        "label": "intlcal_get_minimal_days_in_first_week( $calendar:IntlCalendar )",
        "apply": "intlcal_get_minimal_days_in_first_week( $calendar:IntlCalendar )",
        "info": "Returns the smallest number of days the first week of a year or month must have in the new year or month.  For instance, in the Gregorian calendar, if this value is 1, then the first week of the year will necessarily include January 1st, while if this value is 7, then the week with January 1st will be the first week of the year only if the day of the week for January 1st matches the day of the week returned by IntlCalendar::getFirstDayOfWeek(); otherwise it will be the previous year\u02bcs last week."
    },
    "ƒ: intlcal_set_minimal_days_in_first_week": {
        "type": "function",
        "label": "intlcal_set_minimal_days_in_first_week( $calendar:IntlCalendar, $days:int )",
        "apply": "intlcal_set_minimal_days_in_first_week( $calendar:IntlCalendar, $days:int )",
        "info": "Sets the smallest number of days the first week of a year or month must have in the new year or month.  For instance, in the Gregorian calendar, if this value is 1, then the first week of the year will necessarily include January 1st, while if this value is 7, then the week with January 1st will be the first week of the year only if the day of the week for January 1st matches the day of the week returned by IntlCalendar::getFirstDayOfWeek(); otherwise it will be the previous year\u02bcs last week."
    },
    "ƒ: intlcal_get_minimum": {
        "type": "function",
        "label": "intlcal_get_minimum( $calendar:IntlCalendar, $field:int )",
        "apply": "intlcal_get_minimum( $calendar:IntlCalendar, $field:int )",
        "info": "Gets the global minimum for a field, in this specific calendar. This value is smaller or equal to that returned by IntlCalendar::getActualMinimum(), which is in its turn smaller or equal to that returned by IntlCalendar::getGreatestMinimum(). For the Gregorian calendar, these three functions always return the same value (for each field)."
    },
    "ƒ: intlcal_get_time_zone": {
        "type": "function",
        "label": "intlcal_get_time_zone( $calendar:IntlCalendar )",
        "apply": "intlcal_get_time_zone( $calendar:IntlCalendar )",
        "info": "Returns the IntlTimeZone object associated with this calendar."
    },
    "ƒ: intlcal_get_type": {
        "type": "function",
        "label": "intlcal_get_type( $calendar:IntlCalendar )",
        "apply": "intlcal_get_type( $calendar:IntlCalendar )",
        "info": "A string describing the type of this calendar. This is one of the valid values for the calendar keyword value 'calendar'."
    },
    "ƒ: intlcal_get_weekend_transition": {
        "type": "function",
        "label": "intlcal_get_weekend_transition( $calendar:IntlCalendar, $dayOfWeek:int )",
        "apply": "intlcal_get_weekend_transition( $calendar:IntlCalendar, $dayOfWeek:int )",
        "info": "This function requires ICU 4.4 or later."
    },
    "ƒ: intlcal_in_daylight_time": {
        "type": "function",
        "label": "intlcal_in_daylight_time( $calendar:IntlCalendar )",
        "apply": "intlcal_in_daylight_time( $calendar:IntlCalendar )",
        "info": "Whether, for the instant represented by this object and for this object\u02bcs timezone, daylight saving time is in place."
    },
    "ƒ: intlcal_is_lenient": {
        "type": "function",
        "label": "intlcal_is_lenient( $calendar:IntlCalendar )",
        "apply": "intlcal_is_lenient( $calendar:IntlCalendar )",
        "info": "Returns whether the current date\/time interpretations is lenient (the default). If that is case, some out of range values for fields will be accepted instead of raising an error."
    },
    "ƒ: intlcal_is_set": {
        "type": "function",
        "label": "intlcal_is_set( $calendar:IntlCalendar, $field:int )",
        "apply": "intlcal_is_set( $calendar:IntlCalendar, $field:int )",
        "info": "Returns whether a field is set (as opposed to clear). Set fields take priority over unset fields and their default values when the date\/time is being calculated. Fields set later take priority over fields set earlier."
    },
    "ƒ: intlcal_is_equivalent_to": {
        "type": "function",
        "label": "intlcal_is_equivalent_to( $calendar:IntlCalendar, $other:IntlCalendar )",
        "apply": "intlcal_is_equivalent_to( $calendar:IntlCalendar, $other:IntlCalendar )",
        "info": "Returns whether this and the given object are equivalent for all purposes except as to the time they have set. The locales do not have to match, as long as no change in behavior results from such mismatch. This includes the timezone, whether the lenient mode is set,the repeated and skipped wall time settings,the days of the week when the weekend starts and ceases and the times where such transitions occur. It may also include other calendar specific settings, such as the Gregorian\/Julian transition instant."
    },
    "ƒ: intlcal_is_weekend": {
        "type": "function",
        "label": "intlcal_is_weekend( $calendar:IntlCalendar, $timestamp:?float )",
        "apply": "intlcal_is_weekend( $calendar:IntlCalendar, $timestamp:?float )",
        "info": "This function requires ICU 4.4 or later."
    },
    "ƒ: intlcal_set_first_day_of_week": {
        "type": "function",
        "label": "intlcal_set_first_day_of_week( $calendar:IntlCalendar, $dayOfWeek:int )",
        "apply": "intlcal_set_first_day_of_week( $calendar:IntlCalendar, $dayOfWeek:int )",
        "info": "Defines the day of week deemed to start the week. This affects the behavior of fields that depend on the concept of week start and end such as IntlCalendar::FIELD_WEEK_OF_YEAR and IntlCalendar::FIELD_YEAR_WOY."
    },
    "ƒ: intlcal_set_lenient": {
        "type": "function",
        "label": "intlcal_set_lenient( $calendar:IntlCalendar, $lenient:bool )",
        "apply": "intlcal_set_lenient( $calendar:IntlCalendar, $lenient:bool )",
        "info": "Defines whether the calendar is \u2018lenient mode\u2019. In such a mode, some of out-of-bounds values for some fields are accepted, the behavior being similar to that of IntlCalendar::add() (i.e., the value wraps around, carrying into more significant fields each time). If the lenient mode is off, then such values will generate an error."
    },
    "ƒ: intlcal_get_repeated_wall_time_option": {
        "type": "function",
        "label": "intlcal_get_repeated_wall_time_option( $calendar:IntlCalendar )",
        "apply": "intlcal_get_repeated_wall_time_option( $calendar:IntlCalendar )",
        "info": "This function requires ICU 4.9 or later."
    },
    "ƒ: intlcal_equals": {
        "type": "function",
        "label": "intlcal_equals( $calendar:IntlCalendar, $other:IntlCalendar )",
        "apply": "intlcal_equals( $calendar:IntlCalendar, $other:IntlCalendar )",
        "info": "Returns true if this calendar and the given calendar have the same time.The settings, calendar types and field states do not have to be the same."
    },
    "ƒ: intlcal_get_skipped_wall_time_option": {
        "type": "function",
        "label": "intlcal_get_skipped_wall_time_option( $calendar:IntlCalendar )",
        "apply": "intlcal_get_skipped_wall_time_option( $calendar:IntlCalendar )",
        "info": "This function requires ICU 4.9 or later."
    },
    "ƒ: intlcal_set_repeated_wall_time_option": {
        "type": "function",
        "label": "intlcal_set_repeated_wall_time_option( $calendar:IntlCalendar, $option:int )",
        "apply": "intlcal_set_repeated_wall_time_option( $calendar:IntlCalendar, $option:int )",
        "info": "This function requires ICU 4.9 or later."
    },
    "ƒ: intlcal_set_skipped_wall_time_option": {
        "type": "function",
        "label": "intlcal_set_skipped_wall_time_option( $calendar:IntlCalendar, $option:int )",
        "apply": "intlcal_set_skipped_wall_time_option( $calendar:IntlCalendar, $option:int )",
        "info": "This function requires ICU 4.9 or later."
    },
    "ƒ: intlcal_from_date_time": {
        "type": "function",
        "label": "intlcal_from_date_time( $datetime:DateTime|string, $locale:?string )",
        "apply": "intlcal_from_date_time( $datetime:DateTime|string, $locale:?string )",
        "info": "The new calendar will represent not only the same instant as the given DateTime (subject to precision loss for dates very far into the past or future), but also the same timezone (subject to the caveat that different timezone databases will be used, and therefore the results may differ)."
    },
    "ƒ: intlcal_to_date_time": {
        "type": "function",
        "label": "intlcal_to_date_time( $calendar:IntlCalendar )",
        "apply": "intlcal_to_date_time( $calendar:IntlCalendar )",
        "info": "Create a DateTime object that represents the same instant (up to second precision, with a rounding error of less than 1 second) and has an analog timezone to this object (the difference being DateTime\u02bcs timezone will be backed by PHP\u02bcs timezone while IntlCalendar\u02bcs timezone is backed by ICU\u02bcs)."
    },
    "ƒ: intlcal_get_error_code": {
        "type": "function",
        "label": "intlcal_get_error_code( $calendar:IntlCalendar )",
        "apply": "intlcal_get_error_code( $calendar:IntlCalendar )",
        "info": "The last error that occurred in any call to a function of the intl extension, including early argument errors, can be obtained with intl_get_error_code(). This function resets the global error code, but not the object\u02bcs error code."
    },
    "ƒ: intlcal_get_error_message": {
        "type": "function",
        "label": "intlcal_get_error_message( $calendar:IntlCalendar )",
        "apply": "intlcal_get_error_message( $calendar:IntlCalendar )",
        "info": "Returns the error message (if any) associated with the error reported by IntlCalendar::getErrorCode() or intlcal_get_error_code(). If there is no associated error message, only the string representation of the name of the error constant will be returned.  Otherwise, the message also includes a message set on the side of the PHP binding."
    },
    "ƒ: collator_create": {
        "type": "function",
        "label": "collator_create( $locale:string )",
        "apply": "collator_create( $locale:string )",
        "info": "Object-oriented style"
    },
    "ƒ: collator_compare": {
        "type": "function",
        "label": "collator_compare( $object:Collator, $string1:string, $string2:string )",
        "apply": "collator_compare( $object:Collator, $string1:string, $string2:string )",
        "info": "Object-oriented style "
    },
    "ƒ: collator_get_attribute": {
        "type": "function",
        "label": "collator_get_attribute( $object:Collator, $attribute:int )",
        "apply": "collator_get_attribute( $object:Collator, $attribute:int )",
        "info": "Get a value of an integer collator attribute."
    },
    "ƒ: collator_set_attribute": {
        "type": "function",
        "label": "collator_set_attribute( $object:Collator, $attribute:int, $value:int )",
        "apply": "collator_set_attribute( $object:Collator, $attribute:int, $value:int )",
        "info": ""
    },
    "ƒ: collator_get_strength": {
        "type": "function",
        "label": "collator_get_strength( $object:Collator )",
        "apply": "collator_get_strength( $object:Collator )",
        "info": ""
    },
    "ƒ: collator_set_strength": {
        "type": "function",
        "label": "collator_set_strength( $object:Collator, $strength:int )",
        "apply": "collator_set_strength( $object:Collator, $strength:int )",
        "info": "For example, people may choose to ignore accents or ignore accents and case when searching for text. Almost all characters are distinguished by the first three levels, and in most locales the default value is thus Tertiary.However, if Alternate is set to be Shifted, then the Quaternary strength can be used to break ties among whitespace, punctuation, and symbols that would otherwise be ignored. If very fine distinctions among characters are required, then the Identical strength can be used (for example, Identical Strength distinguishes between the Mathematical Bold Small A and the Mathematical Italic Small A.). However, using levels higher than Tertiary the Identical strength result in significantly longer sort keys, and slower string comparison performance for equal strings."
    },
    "ƒ: collator_sort": {
        "type": "function",
        "label": "collator_sort( $object:Collator, $array:array, $flags:int )",
        "apply": "collator_sort( $object:Collator, $array:array, $flags:int )",
        "info": "Object-oriented style "
    },
    "ƒ: collator_sort_with_sort_keys": {
        "type": "function",
        "label": "collator_sort_with_sort_keys( $object:Collator, $array:array )",
        "apply": "collator_sort_with_sort_keys( $object:Collator, $array:array )",
        "info": "Similar to collator_sort()but uses ICU sorting keys produced by ucol_getSortKey() to gain more speed on large arrays."
    },
    "ƒ: collator_asort": {
        "type": "function",
        "label": "collator_asort( $object:Collator, $array:array, $flags:int )",
        "apply": "collator_asort( $object:Collator, $array:array, $flags:int )",
        "info": "Object-oriented style"
    },
    "ƒ: collator_get_locale": {
        "type": "function",
        "label": "collator_get_locale( $object:Collator, $type:int )",
        "apply": "collator_get_locale( $object:Collator, $type:int )",
        "info": "Get collector locale name."
    },
    "ƒ: collator_get_error_code": {
        "type": "function",
        "label": "collator_get_error_code( $object:Collator )",
        "apply": "collator_get_error_code( $object:Collator )",
        "info": ""
    },
    "ƒ: collator_get_error_message": {
        "type": "function",
        "label": "collator_get_error_message( $object:Collator )",
        "apply": "collator_get_error_message( $object:Collator )",
        "info": "Retrieves the message for the last error."
    },
    "ƒ: collator_get_sort_key": {
        "type": "function",
        "label": "collator_get_sort_key( $object:Collator, $string:string )",
        "apply": "collator_get_sort_key( $object:Collator, $string:string )",
        "info": "Return collation key for a string.Collation keys can be compared directly instead of strings, though are implementation specific and may change between ICU library versions. Sort keys are generally only useful in databases or other circumstances where function calls are extremely expensive."
    },
    "ƒ: datefmt_create": {
        "type": "function",
        "label": "datefmt_create( $locale:?string, $dateType:int, $timeType:int, $timezone:, $calendar:IntlCalendar|int|null, $pattern:?string )",
        "apply": "datefmt_create( $locale:?string, $dateType:int, $timeType:int, $timezone:, $calendar:IntlCalendar|int|null, $pattern:?string )",
        "info": "Create a date formatter."
    },
    "ƒ: datefmt_get_datetype": {
        "type": "function",
        "label": "datefmt_get_datetype( $formatter:IntlDateFormatter )",
        "apply": "datefmt_get_datetype( $formatter:IntlDateFormatter )",
        "info": "Returns date type used by the formatter."
    },
    "ƒ: datefmt_get_timetype": {
        "type": "function",
        "label": "datefmt_get_timetype( $formatter:IntlDateFormatter )",
        "apply": "datefmt_get_timetype( $formatter:IntlDateFormatter )",
        "info": "Return time type used by the formatter."
    },
    "ƒ: datefmt_get_calendar": {
        "type": "function",
        "label": "datefmt_get_calendar( $formatter:IntlDateFormatter )",
        "apply": "datefmt_get_calendar( $formatter:IntlDateFormatter )",
        "info": ""
    },
    "ƒ: datefmt_set_calendar": {
        "type": "function",
        "label": "datefmt_set_calendar( $formatter:IntlDateFormatter, $calendar:IntlCalendar|int|null )",
        "apply": "datefmt_set_calendar( $formatter:IntlDateFormatter, $calendar:IntlCalendar|int|null )",
        "info": "Sets the calendar or calendar type used by the formatter."
    },
    "ƒ: datefmt_get_timezone_id": {
        "type": "function",
        "label": "datefmt_get_timezone_id( $formatter:IntlDateFormatter )",
        "apply": "datefmt_get_timezone_id( $formatter:IntlDateFormatter )",
        "info": "Get the timezone-id used for the IntlDateFormatter."
    },
    "ƒ: datefmt_get_calendar_object": {
        "type": "function",
        "label": "datefmt_get_calendar_object( $formatter:IntlDateFormatter )",
        "apply": "datefmt_get_calendar_object( $formatter:IntlDateFormatter )",
        "info": "Obtain a copy of the calendar object used internally by this formatter. This calendar will have a type (as in gregorian, japanese, buddhist, roc, persian,islamic, etc.) and a timezone that match the type and timezone used by the formatter. The date\/time of the object is unspecified."
    },
    "ƒ: datefmt_get_timezone": {
        "type": "function",
        "label": "datefmt_get_timezone( $formatter:IntlDateFormatter )",
        "apply": "datefmt_get_timezone( $formatter:IntlDateFormatter )",
        "info": "Returns an IntlTimeZone object representing the timezone that will be used by this object to format dates and times. When formatting IntlCalendar and DateTime objects with this IntlDateFormatter, the timezone used will be the one returned by this method, not the one associated with the objects being formatted."
    },
    "ƒ: datefmt_set_timezone": {
        "type": "function",
        "label": "datefmt_set_timezone( $formatter:IntlDateFormatter, $timezone: )",
        "apply": "datefmt_set_timezone( $formatter:IntlDateFormatter, $timezone: )",
        "info": "Sets the timezone used for the IntlDateFormatter.object."
    },
    "ƒ: datefmt_set_pattern": {
        "type": "function",
        "label": "datefmt_set_pattern( $formatter:IntlDateFormatter, $pattern:string )",
        "apply": "datefmt_set_pattern( $formatter:IntlDateFormatter, $pattern:string )",
        "info": "Set the pattern used for the IntlDateFormatter."
    },
    "ƒ: datefmt_get_pattern": {
        "type": "function",
        "label": "datefmt_get_pattern( $formatter:IntlDateFormatter )",
        "apply": "datefmt_get_pattern( $formatter:IntlDateFormatter )",
        "info": "Get pattern used by the formatter."
    },
    "ƒ: datefmt_get_locale": {
        "type": "function",
        "label": "datefmt_get_locale( $formatter:IntlDateFormatter, $type:int )",
        "apply": "datefmt_get_locale( $formatter:IntlDateFormatter, $type:int )",
        "info": "Get locale used by the formatter."
    },
    "ƒ: datefmt_set_lenient": {
        "type": "function",
        "label": "datefmt_set_lenient( $formatter:IntlDateFormatter, $lenient:bool )",
        "apply": "datefmt_set_lenient( $formatter:IntlDateFormatter, $lenient:bool )",
        "info": "Define if the parser is strict or lenient in interpreting inputs that do not match the pattern exactly.Enabling lenient parsing allows the parser to accept otherwise flawed date or time patterns, parsing as much as possible to obtain a value.Extra space, unrecognized tokens, or invalid values (\"February 30th\") are not accepted.  "
    },
    "ƒ: datefmt_is_lenient": {
        "type": "function",
        "label": "datefmt_is_lenient( $formatter:IntlDateFormatter )",
        "apply": "datefmt_is_lenient( $formatter:IntlDateFormatter )",
        "info": "Check if the parser is strict or lenient in interpreting inputs that do not match the pattern exactly."
    },
    "ƒ: datefmt_format": {
        "type": "function",
        "label": "datefmt_format( $formatter:IntlDateFormatter, $datetime: )",
        "apply": "datefmt_format( $formatter:IntlDateFormatter, $datetime: )",
        "info": "Formats the time value as a string."
    },
    "ƒ: datefmt_format_object": {
        "type": "function",
        "label": "datefmt_format_object( $datetime:, $format:, $locale:?string )",
        "apply": "datefmt_format_object( $datetime:, $format:, $locale:?string )",
        "info": "The temporary IntlDateFormatter that will be created will take the timezone from the passed in object. The timezone database bundled with PHP will not be used \u2013 ICU's will be used instead. The timezone identifier used in DateTime objects must therefore also exist in ICU's database."
    },
    "ƒ: datefmt_parse": {
        "type": "function",
        "label": "datefmt_parse( $formatter:IntlDateFormatter, $string:string, $offset: )",
        "apply": "datefmt_parse( $formatter:IntlDateFormatter, $string:string, $offset: )",
        "info": "Converts string to an incremental time value, starting at offset and consuming as much of the input value as possible."
    },
    "ƒ: datefmt_localtime": {
        "type": "function",
        "label": "datefmt_localtime( $formatter:IntlDateFormatter, $string:string, $offset: )",
        "apply": "datefmt_localtime( $formatter:IntlDateFormatter, $string:string, $offset: )",
        "info": "Converts string $value to a field-based time value ( an array of various fields), starting at $parse_pos and consuming as much of the input value as possible."
    },
    "ƒ: datefmt_get_error_code": {
        "type": "function",
        "label": "datefmt_get_error_code( $formatter:IntlDateFormatter )",
        "apply": "datefmt_get_error_code( $formatter:IntlDateFormatter )",
        "info": "Get the error code from last operation.Returns error code from the last number formatting operation. "
    },
    "ƒ: datefmt_get_error_message": {
        "type": "function",
        "label": "datefmt_get_error_message( $formatter:IntlDateFormatter )",
        "apply": "datefmt_get_error_message( $formatter:IntlDateFormatter )",
        "info": "Get the error text from the last operation.  "
    },
    "ƒ: numfmt_create": {
        "type": "function",
        "label": "numfmt_create( $locale:string, $style:int, $pattern:?string )",
        "apply": "numfmt_create( $locale:string, $style:int, $pattern:?string )",
        "info": "Creates a number formatter."
    },
    "ƒ: numfmt_format": {
        "type": "function",
        "label": "numfmt_format( $formatter:NumberFormatter, $num:int|float, $type:int )",
        "apply": "numfmt_format( $formatter:NumberFormatter, $num:int|float, $type:int )",
        "info": "Format a numeric value according to the formatter rules."
    },
    "ƒ: numfmt_parse": {
        "type": "function",
        "label": "numfmt_parse( $formatter:NumberFormatter, $string:string, $type:int, $offset: )",
        "apply": "numfmt_parse( $formatter:NumberFormatter, $string:string, $type:int, $offset: )",
        "info": "Parse a string into a number using the current formatter rules."
    },
    "ƒ: numfmt_format_currency": {
        "type": "function",
        "label": "numfmt_format_currency( $formatter:NumberFormatter, $amount:float, $currency:string )",
        "apply": "numfmt_format_currency( $formatter:NumberFormatter, $amount:float, $currency:string )",
        "info": "Format the currency value according to the formatter rules."
    },
    "ƒ: numfmt_parse_currency": {
        "type": "function",
        "label": "numfmt_parse_currency( $formatter:NumberFormatter, $string:string, $currency:, $offset: )",
        "apply": "numfmt_parse_currency( $formatter:NumberFormatter, $string:string, $currency:, $offset: )",
        "info": "Parse a string into a float and a currency using the current formatter."
    },
    "ƒ: numfmt_set_attribute": {
        "type": "function",
        "label": "numfmt_set_attribute( $formatter:NumberFormatter, $attribute:int, $value:int|float )",
        "apply": "numfmt_set_attribute( $formatter:NumberFormatter, $attribute:int, $value:int|float )",
        "info": "Set a numeric attribute associated with the formatter. An example of a numeric attribute is the number of integer digits the formatter will produce."
    },
    "ƒ: numfmt_get_attribute": {
        "type": "function",
        "label": "numfmt_get_attribute( $formatter:NumberFormatter, $attribute:int )",
        "apply": "numfmt_get_attribute( $formatter:NumberFormatter, $attribute:int )",
        "info": "Get a numeric attribute associated with the formatter. An example of a numeric attribute is the number of integer digits the formatter will produce."
    },
    "ƒ: numfmt_set_text_attribute": {
        "type": "function",
        "label": "numfmt_set_text_attribute( $formatter:NumberFormatter, $attribute:int, $value:string )",
        "apply": "numfmt_set_text_attribute( $formatter:NumberFormatter, $attribute:int, $value:string )",
        "info": "Set a text attribute associated with the formatter. An example of a text attribute is the suffix for positive numbers. If the formatter does not understand the attribute,U_UNSUPPORTED_ERROR error is produced. Rule-based formatters only understand NumberFormatter::DEFAULT_RULESET and NumberFormatter::PUBLIC_RULESETS."
    },
    "ƒ: numfmt_get_text_attribute": {
        "type": "function",
        "label": "numfmt_get_text_attribute( $formatter:NumberFormatter, $attribute:int )",
        "apply": "numfmt_get_text_attribute( $formatter:NumberFormatter, $attribute:int )",
        "info": "Get a text attribute associated with the formatter. An example of a text attribute is the suffix for positive numbers. If the formatter does not understand the attribute,U_UNSUPPORTED_ERROR error is produced. Rule-based formatters only understand NumberFormatter::DEFAULT_RULESET and NumberFormatter::PUBLIC_RULESETS."
    },
    "ƒ: numfmt_set_symbol": {
        "type": "function",
        "label": "numfmt_set_symbol( $formatter:NumberFormatter, $symbol:int, $value:string )",
        "apply": "numfmt_set_symbol( $formatter:NumberFormatter, $symbol:int, $value:string )",
        "info": "Set a symbol associated with the formatter. The formatter uses symbols to represent the special locale-dependent characters in a number, for example the percent sign. This API is not supported for rule-based formatters."
    },
    "ƒ: numfmt_get_symbol": {
        "type": "function",
        "label": "numfmt_get_symbol( $formatter:NumberFormatter, $symbol:int )",
        "apply": "numfmt_get_symbol( $formatter:NumberFormatter, $symbol:int )",
        "info": "Get a symbol associated with the formatter. The formatter uses symbols to represent the special locale-dependent characters in a number, for example the percent sign. This API is not supported for rule-based formatters."
    },
    "ƒ: numfmt_set_pattern": {
        "type": "function",
        "label": "numfmt_set_pattern( $formatter:NumberFormatter, $pattern:string )",
        "apply": "numfmt_set_pattern( $formatter:NumberFormatter, $pattern:string )",
        "info": "Set the pattern used by the formatter. Can not be used on a rule-based formatter."
    },
    "ƒ: numfmt_get_pattern": {
        "type": "function",
        "label": "numfmt_get_pattern( $formatter:NumberFormatter )",
        "apply": "numfmt_get_pattern( $formatter:NumberFormatter )",
        "info": "Extract pattern used by the formatter."
    },
    "ƒ: numfmt_get_locale": {
        "type": "function",
        "label": "numfmt_get_locale( $formatter:NumberFormatter, $type:int )",
        "apply": "numfmt_get_locale( $formatter:NumberFormatter, $type:int )",
        "info": "Get formatter locale name."
    },
    "ƒ: numfmt_get_error_code": {
        "type": "function",
        "label": "numfmt_get_error_code( $formatter:NumberFormatter )",
        "apply": "numfmt_get_error_code( $formatter:NumberFormatter )",
        "info": "Get error code from the last function performed by the formatter."
    },
    "ƒ: numfmt_get_error_message": {
        "type": "function",
        "label": "numfmt_get_error_message( $formatter:NumberFormatter )",
        "apply": "numfmt_get_error_message( $formatter:NumberFormatter )",
        "info": "Get error message from the last function performed by the formatter."
    },
    "ƒ: locale_get_default": {
        "type": "function",
        "label": "locale_get_default()",
        "apply": "locale_get_default()",
        "info": "Gets the default locale value. At the PHP initialization this value is set to 'intl.default_locale' value from php.ini if that value exists or from ICU's function uloc_getDefault()."
    },
    "ƒ: locale_set_default": {
        "type": "function",
        "label": "locale_set_default( $locale:string )",
        "apply": "locale_set_default( $locale:string )",
        "info": "Sets the default runtime locale to locale. This changes the value of INTL global 'default_locale' locale identifier. UAX #35 extensions are accepted."
    },
    "ƒ: locale_get_primary_language": {
        "type": "function",
        "label": "locale_get_primary_language( $locale:string )",
        "apply": "locale_get_primary_language( $locale:string )",
        "info": "Gets the primary language for the input locale "
    },
    "ƒ: locale_get_script": {
        "type": "function",
        "label": "locale_get_script( $locale:string )",
        "apply": "locale_get_script( $locale:string )",
        "info": "Gets the script for the input locale."
    },
    "ƒ: locale_get_region": {
        "type": "function",
        "label": "locale_get_region( $locale:string )",
        "apply": "locale_get_region( $locale:string )",
        "info": "Gets the region for the input locale."
    },
    "ƒ: locale_get_keywords": {
        "type": "function",
        "label": "locale_get_keywords( $locale:string )",
        "apply": "locale_get_keywords( $locale:string )",
        "info": "Gets the keywords for the input locale."
    },
    "ƒ: locale_get_display_script": {
        "type": "function",
        "label": "locale_get_display_script( $locale:string, $displayLocale:?string )",
        "apply": "locale_get_display_script( $locale:string, $displayLocale:?string )",
        "info": "Returns an appropriately localized display name for script of the input locale. If is null then the default locale is used."
    },
    "ƒ: locale_get_display_region": {
        "type": "function",
        "label": "locale_get_display_region( $locale:string, $displayLocale:?string )",
        "apply": "locale_get_display_region( $locale:string, $displayLocale:?string )",
        "info": "Returns an appropriately localized display name for region of the input locale. If is null then the default locale is used."
    },
    "ƒ: locale_get_display_name": {
        "type": "function",
        "label": "locale_get_display_name( $locale:string, $displayLocale:?string )",
        "apply": "locale_get_display_name( $locale:string, $displayLocale:?string )",
        "info": "Returns an appropriately localized display name for the input locale. If locale is null then the default locale is used."
    },
    "ƒ: locale_get_display_language": {
        "type": "function",
        "label": "locale_get_display_language( $locale:string, $displayLocale:?string )",
        "apply": "locale_get_display_language( $locale:string, $displayLocale:?string )",
        "info": "Returns an appropriately localized display name for language of the input locale. If is null then the default locale is used."
    },
    "ƒ: locale_get_display_variant": {
        "type": "function",
        "label": "locale_get_display_variant( $locale:string, $displayLocale:?string )",
        "apply": "locale_get_display_variant( $locale:string, $displayLocale:?string )",
        "info": "Returns an appropriately localized display name for variants of the input locale. If is null then the default locale is used."
    },
    "ƒ: locale_get_all_variants": {
        "type": "function",
        "label": "locale_get_all_variants( $locale:string )",
        "apply": "locale_get_all_variants( $locale:string )",
        "info": "Gets the variants for the input locale "
    },
    "ƒ: locale_filter_matches": {
        "type": "function",
        "label": "locale_filter_matches( $languageTag:string, $locale:string, $canonicalize:bool )",
        "apply": "locale_filter_matches( $languageTag:string, $locale:string, $canonicalize:bool )",
        "info": "Checks if a languageTag filter matches with locale according to RFC 4647's basic filtering algorithm "
    },
    "ƒ: locale_canonicalize": {
        "type": "function",
        "label": "locale_canonicalize( $locale:string )",
        "apply": "locale_canonicalize( $locale:string )",
        "info": ""
    },
    "ƒ: locale_lookup": {
        "type": "function",
        "label": "locale_lookup( $languageTag:array, $locale:string, $canonicalize:bool, $defaultLocale:?string )",
        "apply": "locale_lookup( $languageTag:array, $locale:string, $canonicalize:bool, $defaultLocale:?string )",
        "info": "Searches the items in languageTag for the best match to the language range specified in locale according to RFC 4647's lookup algorithm."
    },
    "ƒ: locale_accept_from_http": {
        "type": "function",
        "label": "locale_accept_from_http( $header:string )",
        "apply": "locale_accept_from_http( $header:string )",
        "info": "Tries to find locale that can satisfy the language list that is requested by the HTTP \"Accept-Language\" header."
    },
    "ƒ: msgfmt_create": {
        "type": "function",
        "label": "msgfmt_create( $locale:string, $pattern:string )",
        "apply": "msgfmt_create( $locale:string, $pattern:string )",
        "info": "Constructs a new Message Formatter "
    },
    "ƒ: msgfmt_format": {
        "type": "function",
        "label": "msgfmt_format( $formatter:MessageFormatter, $values:array )",
        "apply": "msgfmt_format( $formatter:MessageFormatter, $values:array )",
        "info": "Format the message by substituting the data into the format string according to the locale rules "
    },
    "ƒ: msgfmt_format_message": {
        "type": "function",
        "label": "msgfmt_format_message( $locale:string, $pattern:string, $values:array )",
        "apply": "msgfmt_format_message( $locale:string, $pattern:string, $values:array )",
        "info": "Quick formatting function that formats the string without having to explicitly create the formatter object. Use this function when the format operation is done only once and does not need any parameters or state to be kept or when wanting to customize the output by providing additional context to ICU directly."
    },
    "ƒ: msgfmt_parse": {
        "type": "function",
        "label": "msgfmt_parse( $formatter:MessageFormatter, $string:string )",
        "apply": "msgfmt_parse( $formatter:MessageFormatter, $string:string )",
        "info": "Parses input string and return any extracted items as an array."
    },
    "ƒ: msgfmt_parse_message": {
        "type": "function",
        "label": "msgfmt_parse_message( $locale:string, $pattern:string, $message:string )",
        "apply": "msgfmt_parse_message( $locale:string, $pattern:string, $message:string )",
        "info": "Parses input string without explicitly creating the formatter object. Use this function when the format operation is done only once and does not need any parameters or state to be kept."
    },
    "ƒ: msgfmt_set_pattern": {
        "type": "function",
        "label": "msgfmt_set_pattern( $formatter:MessageFormatter, $pattern:string )",
        "apply": "msgfmt_set_pattern( $formatter:MessageFormatter, $pattern:string )",
        "info": "Set the pattern used by the formatter "
    },
    "ƒ: msgfmt_get_pattern": {
        "type": "function",
        "label": "msgfmt_get_pattern( $formatter:MessageFormatter )",
        "apply": "msgfmt_get_pattern( $formatter:MessageFormatter )",
        "info": "Get the pattern used by the formatter "
    },
    "ƒ: msgfmt_get_locale": {
        "type": "function",
        "label": "msgfmt_get_locale( $formatter:MessageFormatter )",
        "apply": "msgfmt_get_locale( $formatter:MessageFormatter )",
        "info": "Get the locale for which the formatter was created."
    },
    "ƒ: msgfmt_get_error_code": {
        "type": "function",
        "label": "msgfmt_get_error_code( $formatter:MessageFormatter )",
        "apply": "msgfmt_get_error_code( $formatter:MessageFormatter )",
        "info": "Get the error code from last operation."
    },
    "ƒ: msgfmt_get_error_message": {
        "type": "function",
        "label": "msgfmt_get_error_message( $formatter:MessageFormatter )",
        "apply": "msgfmt_get_error_message( $formatter:MessageFormatter )",
        "info": "Get the error text from the last operation."
    },
    "ƒ: normalizer_normalize": {
        "type": "function",
        "label": "normalizer_normalize( $string:string, $form:int )",
        "apply": "normalizer_normalize( $string:string, $form:int )",
        "info": "Normalizes the input provided and returns the normalized string"
    },
    "ƒ: normalizer_is_normalized": {
        "type": "function",
        "label": "normalizer_is_normalized( $string:string, $form:int )",
        "apply": "normalizer_is_normalized( $string:string, $form:int )",
        "info": "Checks if the provided string is already in the specified normalization form."
    },
    "ƒ: normalizer_get_raw_decomposition": {
        "type": "function",
        "label": "normalizer_get_raw_decomposition( $string:string, $form:int )",
        "apply": "normalizer_get_raw_decomposition( $string:string, $form:int )",
        "info": "Gets the Decomposition_Mapping property, as specified in the Unicode Character Database (UCD), for the given UTF-8 encoded code point."
    },
    "ƒ: resourcebundle_create": {
        "type": "function",
        "label": "resourcebundle_create( $locale:?string, $bundle:?string, $fallback:bool )",
        "apply": "resourcebundle_create( $locale:?string, $bundle:?string, $fallback:bool )",
        "info": "Creates a resource bundle."
    },
    "ƒ: resourcebundle_get": {
        "type": "function",
        "label": "resourcebundle_get( $bundle:ResourceBundle, $index:, $fallback:bool )",
        "apply": "resourcebundle_get( $bundle:ResourceBundle, $index:, $fallback:bool )",
        "info": "Get the data from the bundle by index or string key."
    },
    "ƒ: resourcebundle_count": {
        "type": "function",
        "label": "resourcebundle_count( $bundle:ResourceBundle )",
        "apply": "resourcebundle_count( $bundle:ResourceBundle )",
        "info": "Get the number of elements in the bundle."
    },
    "ƒ: resourcebundle_locales": {
        "type": "function",
        "label": "resourcebundle_locales( $bundle:string )",
        "apply": "resourcebundle_locales( $bundle:string )",
        "info": "Get available locales from ResourceBundle name."
    },
    "ƒ: resourcebundle_get_error_code": {
        "type": "function",
        "label": "resourcebundle_get_error_code( $bundle:ResourceBundle )",
        "apply": "resourcebundle_get_error_code( $bundle:ResourceBundle )",
        "info": "Get error code from the last function performed by the bundle object."
    },
    "ƒ: resourcebundle_get_error_message": {
        "type": "function",
        "label": "resourcebundle_get_error_message( $bundle:ResourceBundle )",
        "apply": "resourcebundle_get_error_message( $bundle:ResourceBundle )",
        "info": "Get error message from the last function performed by the bundle object."
    },
    "ƒ: intltz_count_equivalent_ids": {
        "type": "function",
        "label": "intltz_count_equivalent_ids( $timezoneId:string )",
        "apply": "intltz_count_equivalent_ids( $timezoneId:string )",
        "info": "This function is currently not documented; only its argument list is available."
    },
    "ƒ: intltz_create_default": {
        "type": "function",
        "label": "intltz_create_default()",
        "apply": "intltz_create_default()",
        "info": "This function is currently not documented; only its argument list is available."
    },
    "ƒ: intltz_create_enumeration": {
        "type": "function",
        "label": "intltz_create_enumeration( $countryOrRawOffset: )",
        "apply": "intltz_create_enumeration( $countryOrRawOffset: )",
        "info": "This function is currently not documented; only its argument list is available."
    },
    "ƒ: intltz_create_time_zone": {
        "type": "function",
        "label": "intltz_create_time_zone( $timezoneId:string )",
        "apply": "intltz_create_time_zone( $timezoneId:string )",
        "info": "This function is currently not documented; only its argument list is available."
    },
    "ƒ: intltz_create_time_zone_id_enumeration": {
        "type": "function",
        "label": "intltz_create_time_zone_id_enumeration( $type:int, $region:?string, $rawOffset:?int )",
        "apply": "intltz_create_time_zone_id_enumeration( $type:int, $region:?string, $rawOffset:?int )",
        "info": "This function is currently not documented; only its argument list is available."
    },
    "ƒ: intltz_from_date_time_zone": {
        "type": "function",
        "label": "intltz_from_date_time_zone( $timezone:DateTimeZone )",
        "apply": "intltz_from_date_time_zone( $timezone:DateTimeZone )",
        "info": "This function is currently not documented; only its argument list is available."
    },
    "ƒ: intltz_get_canonical_id": {
        "type": "function",
        "label": "intltz_get_canonical_id( $timezoneId:string, $isSystemId: )",
        "apply": "intltz_get_canonical_id( $timezoneId:string, $isSystemId: )",
        "info": "This function is currently not documented; only its argument list is available."
    },
    "ƒ: intltz_get_display_name": {
        "type": "function",
        "label": "intltz_get_display_name( $timezone:IntlTimeZone, $dst:bool, $style:int, $locale:?string )",
        "apply": "intltz_get_display_name( $timezone:IntlTimeZone, $dst:bool, $style:int, $locale:?string )",
        "info": "This function is currently not documented; only its argument list is available."
    },
    "ƒ: intltz_get_dst_savings": {
        "type": "function",
        "label": "intltz_get_dst_savings( $timezone:IntlTimeZone )",
        "apply": "intltz_get_dst_savings( $timezone:IntlTimeZone )",
        "info": "This function is currently not documented; only its argument list is available."
    },
    "ƒ: intltz_get_equivalent_id": {
        "type": "function",
        "label": "intltz_get_equivalent_id( $timezoneId:string, $offset:int )",
        "apply": "intltz_get_equivalent_id( $timezoneId:string, $offset:int )",
        "info": "This function is currently not documented; only its argument list is available."
    },
    "ƒ: intltz_get_error_code": {
        "type": "function",
        "label": "intltz_get_error_code( $timezone:IntlTimeZone )",
        "apply": "intltz_get_error_code( $timezone:IntlTimeZone )",
        "info": "This function is currently not documented; only its argument list is available."
    },
    "ƒ: intltz_get_error_message": {
        "type": "function",
        "label": "intltz_get_error_message( $timezone:IntlTimeZone )",
        "apply": "intltz_get_error_message( $timezone:IntlTimeZone )",
        "info": "This function is currently not documented; only its argument list is available."
    },
    "ƒ: intltz_get_gmt": {
        "type": "function",
        "label": "intltz_get_gmt()",
        "apply": "intltz_get_gmt()",
        "info": "This function is currently not documented; only its argument list is available."
    },
    "ƒ: intltz_get_id": {
        "type": "function",
        "label": "intltz_get_id( $timezone:IntlTimeZone )",
        "apply": "intltz_get_id( $timezone:IntlTimeZone )",
        "info": "This function is currently not documented; only its argument list is available."
    },
    "ƒ: intltz_get_offset": {
        "type": "function",
        "label": "intltz_get_offset( $timezone:IntlTimeZone, $timestamp:float, $local:bool, $rawOffset:, $dstOffset: )",
        "apply": "intltz_get_offset( $timezone:IntlTimeZone, $timestamp:float, $local:bool, $rawOffset:, $dstOffset: )",
        "info": "This function is currently not documented; only its argument list is available."
    },
    "ƒ: intltz_get_raw_offset": {
        "type": "function",
        "label": "intltz_get_raw_offset( $timezone:IntlTimeZone )",
        "apply": "intltz_get_raw_offset( $timezone:IntlTimeZone )",
        "info": "This function is currently not documented; only its argument list is available."
    },
    "ƒ: intltz_get_region": {
        "type": "function",
        "label": "intltz_get_region( $timezoneId:string )",
        "apply": "intltz_get_region( $timezoneId:string )",
        "info": "This function is currently not documented; only its argument list is available."
    },
    "ƒ: intltz_get_tz_data_version": {
        "type": "function",
        "label": "intltz_get_tz_data_version()",
        "apply": "intltz_get_tz_data_version()",
        "info": "This function is currently not documented; only its argument list is available."
    },
    "ƒ: intltz_get_unknown": {
        "type": "function",
        "label": "intltz_get_unknown()",
        "apply": "intltz_get_unknown()",
        "info": "This function is currently not documented; only its argument list is available."
    },
    "ƒ: intltz_get_windows_id": {
        "type": "function",
        "label": "intltz_get_windows_id( $timezoneId:string )",
        "apply": "intltz_get_windows_id( $timezoneId:string )",
        "info": "This function is currently not documented; only its argument list is available."
    },
    "ƒ: intltz_get_id_for_windows_id": {
        "type": "function",
        "label": "intltz_get_id_for_windows_id( $timezoneId:string, $region:?string )",
        "apply": "intltz_get_id_for_windows_id( $timezoneId:string, $region:?string )",
        "info": "This function is currently not documented; only its argument list is available."
    },
    "ƒ: intltz_has_same_rules": {
        "type": "function",
        "label": "intltz_has_same_rules( $timezone:IntlTimeZone, $other:IntlTimeZone )",
        "apply": "intltz_has_same_rules( $timezone:IntlTimeZone, $other:IntlTimeZone )",
        "info": "This function is currently not documented; only its argument list is available."
    },
    "ƒ: intltz_to_date_time_zone": {
        "type": "function",
        "label": "intltz_to_date_time_zone( $timezone:IntlTimeZone )",
        "apply": "intltz_to_date_time_zone( $timezone:IntlTimeZone )",
        "info": "This function is currently not documented; only its argument list is available."
    },
    "ƒ: intltz_use_daylight_time": {
        "type": "function",
        "label": "intltz_use_daylight_time( $timezone:IntlTimeZone )",
        "apply": "intltz_use_daylight_time( $timezone:IntlTimeZone )",
        "info": "This function is currently not documented; only its argument list is available."
    },
    "ƒ: transliterator_create": {
        "type": "function",
        "label": "transliterator_create( $id:string, $direction:int )",
        "apply": "transliterator_create( $id:string, $direction:int )",
        "info": "Opens a Transliterator by ID."
    },
    "ƒ: transliterator_create_from_rules": {
        "type": "function",
        "label": "transliterator_create_from_rules( $rules:string, $direction:int )",
        "apply": "transliterator_create_from_rules( $rules:string, $direction:int )",
        "info": "This function is currently not documented; only its argument list is available."
    },
    "ƒ: transliterator_list_ids": {
        "type": "function",
        "label": "transliterator_list_ids()",
        "apply": "transliterator_list_ids()",
        "info": "Returns an array with the registered transliterator IDs."
    },
    "ƒ: transliterator_create_inverse": {
        "type": "function",
        "label": "transliterator_create_inverse( $transliterator:Transliterator )",
        "apply": "transliterator_create_inverse( $transliterator:Transliterator )",
        "info": "This function is currently not documented; only its argument list is available."
    },
    "ƒ: transliterator_transliterate": {
        "type": "function",
        "label": "transliterator_transliterate( $transliterator:Transliterator|string, $string:string, $start:int, $end:int )",
        "apply": "transliterator_transliterate( $transliterator:Transliterator|string, $string:string, $start:int, $end:int )",
        "info": "Transforms a string or part thereof using an ICU transliterator."
    },
    "ƒ: transliterator_get_error_code": {
        "type": "function",
        "label": "transliterator_get_error_code( $transliterator:Transliterator )",
        "apply": "transliterator_get_error_code( $transliterator:Transliterator )",
        "info": "This function is currently not documented; only its argument list is available."
    },
    "ƒ: transliterator_get_error_message": {
        "type": "function",
        "label": "transliterator_get_error_message( $transliterator:Transliterator )",
        "apply": "transliterator_get_error_message( $transliterator:Transliterator )",
        "info": "This function is currently not documented; only its argument list is available."
    },
    "ƒ: mysqli_affected_rows": {
        "type": "function",
        "label": "mysqli_affected_rows( $mysql:mysqli )",
        "apply": "mysqli_affected_rows( $mysql:mysqli )",
        "info": "Returns the number of rows affected by the last INSERT,UPDATE, REPLACE or DELETE query.Works like mysqli_num_rows() for SELECT statements."
    },
    "ƒ: mysqli_autocommit": {
        "type": "function",
        "label": "mysqli_autocommit( $mysql:mysqli, $enable:bool )",
        "apply": "mysqli_autocommit( $mysql:mysqli, $enable:bool )",
        "info": "To determine the current state of autocommit use the SQL command SELECT @@autocommit."
    },
    "ƒ: mysqli_begin_transaction": {
        "type": "function",
        "label": "mysqli_begin_transaction( $mysql:mysqli, $flags:int, $name:?string )",
        "apply": "mysqli_begin_transaction( $mysql:mysqli, $flags:int, $name:?string )",
        "info": "Begins a transaction. Requires the InnoDB engine (it is enabled by default). For additional details about how MySQL transactions work, see \u00bb\u00a0http:\/\/dev.mysql.com\/doc\/mysql\/en\/commit.html."
    },
    "ƒ: mysqli_change_user": {
        "type": "function",
        "label": "mysqli_change_user( $mysql:mysqli, $username:string, $password:string, $database:?string )",
        "apply": "mysqli_change_user( $mysql:mysqli, $username:string, $password:string, $database:?string )",
        "info": "In order to successfully change users a valid username and password parameters must be provided and that user must have sufficient permissions to access the desired database. If for any reason authorization fails, the current user authentication will remain."
    },
    "ƒ: mysqli_character_set_name": {
        "type": "function",
        "label": "mysqli_character_set_name( $mysql:mysqli )",
        "apply": "mysqli_character_set_name( $mysql:mysqli )",
        "info": "Returns the current character set of the database connection."
    },
    "ƒ: mysqli_close": {
        "type": "function",
        "label": "mysqli_close( $mysql:mysqli )",
        "apply": "mysqli_close( $mysql:mysqli )",
        "info": "Open non-persistent MySQL connections and result sets are automatically closed when their objects are destroyed. Explicitly closing open connections and freeing result sets is optional. However, it's a good idea to close the connection as soon as the script finishes performing all of its database operations, if it still has a lot of processing to do after getting the results."
    },
    "ƒ: mysqli_commit": {
        "type": "function",
        "label": "mysqli_commit( $mysql:mysqli, $flags:int, $name:?string )",
        "apply": "mysqli_commit( $mysql:mysqli, $flags:int, $name:?string )",
        "info": "Commits the current transaction for the database connection."
    },
    "ƒ: mysqli_connect": {
        "type": "function",
        "label": "mysqli_connect( $hostname:?string, $username:?string, $password:?string, $database:?string, $port:?int, $socket:?string )",
        "apply": "mysqli_connect( $hostname:?string, $username:?string, $password:?string, $database:?string, $port:?int, $socket:?string )",
        "info": "If mysqli exception mode is not enabled and a connection fails, then mysqli_connect() returns false instead of an object. The mysqli_connect_error() function can be used to fetch the connection error."
    },
    "ƒ: mysqli_connect_errno": {
        "type": "function",
        "label": "mysqli_connect_errno()",
        "apply": "mysqli_connect_errno()",
        "info": "Returns the error code from the last connection attempt."
    },
    "ƒ: mysqli_connect_error": {
        "type": "function",
        "label": "mysqli_connect_error()",
        "apply": "mysqli_connect_error()",
        "info": "Returns the error message from the last connection attempt."
    },
    "ƒ: mysqli_dump_debug_info": {
        "type": "function",
        "label": "mysqli_dump_debug_info( $mysql:mysqli )",
        "apply": "mysqli_dump_debug_info( $mysql:mysqli )",
        "info": "This function is designed to be executed by an user with the SUPER privilege and is used to dump debugging information into the log for the MySQL Server relating to the connection."
    },
    "ƒ: mysqli_debug": {
        "type": "function",
        "label": "mysqli_debug( $options:string )",
        "apply": "mysqli_debug( $options:string )",
        "info": "Performs debugging operations using the Fred Fish debugging library."
    },
    "ƒ: mysqli_errno": {
        "type": "function",
        "label": "mysqli_errno( $mysql:mysqli )",
        "apply": "mysqli_errno( $mysql:mysqli )",
        "info": "Returns the last error code for the most recent MySQLi function call that can succeed or fail."
    },
    "ƒ: mysqli_error": {
        "type": "function",
        "label": "mysqli_error( $mysql:mysqli )",
        "apply": "mysqli_error( $mysql:mysqli )",
        "info": "Returns the last error message for the most recent MySQLi function call that can succeed or fail."
    },
    "ƒ: mysqli_error_list": {
        "type": "function",
        "label": "mysqli_error_list( $mysql:mysqli )",
        "apply": "mysqli_error_list( $mysql:mysqli )",
        "info": "Returns a array of errors for the most recent MySQLi function call that can succeed or fail."
    },
    "ƒ: mysqli_execute": {
        "type": "function",
        "label": "mysqli_execute( $statement:mysqli_stmt, $params:?array )",
        "apply": "mysqli_execute( $statement:mysqli_stmt, $params:?array )",
        "info": "This function is an alias of:  mysqli_stmt_execute()."
    },
    "ƒ: mysqli_data_seek": {
        "type": "function",
        "label": "mysqli_data_seek( $result:mysqli_result, $offset:int )",
        "apply": "mysqli_data_seek( $result:mysqli_result, $offset:int )",
        "info": "The mysqli_data_seek() function seeks to an arbitrary result pointer specified by the offset in the result set."
    },
    "ƒ: mysqli_field_seek": {
        "type": "function",
        "label": "mysqli_field_seek( $result:mysqli_result, $index:int )",
        "apply": "mysqli_field_seek( $result:mysqli_result, $index:int )",
        "info": "To seek to the beginning of a row, pass an offset value of zero."
    },
    "ƒ: mysqli_fetch_field": {
        "type": "function",
        "label": "mysqli_fetch_field( $result:mysqli_result )",
        "apply": "mysqli_fetch_field( $result:mysqli_result )",
        "info": "Returns the definition of one column of a result set as an object. Call this function repeatedly to retrieve information about all columns in the result set."
    },
    "ƒ: mysqli_fetch_fields": {
        "type": "function",
        "label": "mysqli_fetch_fields( $result:mysqli_result )",
        "apply": "mysqli_fetch_fields( $result:mysqli_result )",
        "info": "This function serves an identical purpose to the mysqli_fetch_field() function with the single difference that, instead of returning one object at a time for each field,the columns are returned as an array of objects."
    },
    "ƒ: mysqli_fetch_field_direct": {
        "type": "function",
        "label": "mysqli_fetch_field_direct( $result:mysqli_result, $index:int )",
        "apply": "mysqli_fetch_field_direct( $result:mysqli_result, $index:int )",
        "info": "Returns an object which contains field definition information from the specified result set. "
    },
    "ƒ: mysqli_fetch_lengths": {
        "type": "function",
        "label": "mysqli_fetch_lengths( $result:mysqli_result )",
        "apply": "mysqli_fetch_lengths( $result:mysqli_result )",
        "info": "The mysqli_fetch_lengths() function returns an array containing the lengths of every column of the current row within the result set."
    },
    "ƒ: mysqli_fetch_all": {
        "type": "function",
        "label": "mysqli_fetch_all( $result:mysqli_result, $mode:int )",
        "apply": "mysqli_fetch_all( $result:mysqli_result, $mode:int )",
        "info": "Prior to PHP 8.1.0, available only with mysqlnd."
    },
    "ƒ: mysqli_fetch_array": {
        "type": "function",
        "label": "mysqli_fetch_array( $result:mysqli_result, $mode:int )",
        "apply": "mysqli_fetch_array( $result:mysqli_result, $mode:int )",
        "info": "Note: This function sets NULL fields to the PHP null value."
    },
    "ƒ: mysqli_fetch_assoc": {
        "type": "function",
        "label": "mysqli_fetch_assoc( $result:mysqli_result )",
        "apply": "mysqli_fetch_assoc( $result:mysqli_result )",
        "info": "Note: This function sets NULL fields to the PHP null value."
    },
    "ƒ: mysqli_fetch_object": {
        "type": "function",
        "label": "mysqli_fetch_object( $result:mysqli_result, $class:string, $constructor_args:array )",
        "apply": "mysqli_fetch_object( $result:mysqli_result, $class:string, $constructor_args:array )",
        "info": "Note: This function sets NULL fields to the PHP null value."
    },
    "ƒ: mysqli_fetch_row": {
        "type": "function",
        "label": "mysqli_fetch_row( $result:mysqli_result )",
        "apply": "mysqli_fetch_row( $result:mysqli_result )",
        "info": "Note: This function sets NULL fields to the PHP null value."
    },
    "ƒ: mysqli_fetch_column": {
        "type": "function",
        "label": "mysqli_fetch_column( $result:mysqli_result, $column:int )",
        "apply": "mysqli_fetch_column( $result:mysqli_result, $column:int )",
        "info": "Note: This function sets NULL fields to the PHP null value."
    },
    "ƒ: mysqli_field_count": {
        "type": "function",
        "label": "mysqli_field_count( $mysql:mysqli )",
        "apply": "mysqli_field_count( $mysql:mysqli )",
        "info": "Returns the number of columns for the most recent query on the connection represented by the mysql parameter. This function can be useful when using the mysqli_store_result()function to determine if the query should have produced a non-empty result set or not without knowing the nature of the query."
    },
    "ƒ: mysqli_free_result": {
        "type": "function",
        "label": "mysqli_free_result( $result:mysqli_result )",
        "apply": "mysqli_free_result( $result:mysqli_result )",
        "info": "Frees the memory associated with the result."
    },
    "ƒ: mysqli_get_connection_stats": {
        "type": "function",
        "label": "mysqli_get_connection_stats( $mysql:mysqli )",
        "apply": "mysqli_get_connection_stats( $mysql:mysqli )",
        "info": "Available only with mysqlnd."
    },
    "ƒ: mysqli_get_client_stats": {
        "type": "function",
        "label": "mysqli_get_client_stats()",
        "apply": "mysqli_get_client_stats()",
        "info": "Available only with mysqlnd."
    },
    "ƒ: mysqli_get_charset": {
        "type": "function",
        "label": "mysqli_get_charset( $mysql:mysqli )",
        "apply": "mysqli_get_charset( $mysql:mysqli )",
        "info": "Returns a character set object providing several properties of the current active character set."
    },
    "ƒ: mysqli_get_client_info": {
        "type": "function",
        "label": "mysqli_get_client_info( $mysql:?mysqli )",
        "apply": "mysqli_get_client_info( $mysql:?mysqli )",
        "info": "Returns a string that represents the MySQL client library version."
    },
    "ƒ: mysqli_get_client_version": {
        "type": "function",
        "label": "mysqli_get_client_version()",
        "apply": "mysqli_get_client_version()",
        "info": "Returns client version number as an integer."
    },
    "ƒ: mysqli_get_links_stats": {
        "type": "function",
        "label": "mysqli_get_links_stats()",
        "apply": "mysqli_get_links_stats()",
        "info": "mysqli_get_links_stats() returns information about open and cached MySQL links."
    },
    "ƒ: mysqli_get_host_info": {
        "type": "function",
        "label": "mysqli_get_host_info( $mysql:mysqli )",
        "apply": "mysqli_get_host_info( $mysql:mysqli )",
        "info": "Returns a string describing the connection represented by the mysql parameter (including the server host name)."
    },
    "ƒ: mysqli_get_proto_info": {
        "type": "function",
        "label": "mysqli_get_proto_info( $mysql:mysqli )",
        "apply": "mysqli_get_proto_info( $mysql:mysqli )",
        "info": "Returns an integer representing the MySQL protocol version used by the connection represented by the mysql parameter."
    },
    "ƒ: mysqli_get_server_info": {
        "type": "function",
        "label": "mysqli_get_server_info( $mysql:mysqli )",
        "apply": "mysqli_get_server_info( $mysql:mysqli )",
        "info": "Returns a string representing the version of the MySQL server that the MySQLi extension is connected to."
    },
    "ƒ: mysqli_get_server_version": {
        "type": "function",
        "label": "mysqli_get_server_version( $mysql:mysqli )",
        "apply": "mysqli_get_server_version( $mysql:mysqli )",
        "info": "The mysqli_get_server_version() function returns the version of the server connected to (represented by the mysql parameter) as an integer."
    },
    "ƒ: mysqli_get_warnings": {
        "type": "function",
        "label": "mysqli_get_warnings( $mysql:mysqli )",
        "apply": "mysqli_get_warnings( $mysql:mysqli )",
        "info": "This function is currently not documented; only its argument list is available."
    },
    "ƒ: mysqli_init": {
        "type": "function",
        "label": "mysqli_init()",
        "apply": "mysqli_init()",
        "info": "Any subsequent calls to any mysqli function (except mysqli_options()and mysqli_ssl_set())will fail until mysqli_real_connect() was called."
    },
    "ƒ: mysqli_info": {
        "type": "function",
        "label": "mysqli_info( $mysql:mysqli )",
        "apply": "mysqli_info( $mysql:mysqli )",
        "info": "Queries which do not fall into one of the preceding formats are not supported.In these situations, mysqli_info() will return an empty string."
    },
    "ƒ: mysqli_insert_id": {
        "type": "function",
        "label": "mysqli_insert_id( $mysql:mysqli )",
        "apply": "mysqli_insert_id( $mysql:mysqli )",
        "info": "Returns 0 if the previous statement did not change an AUTO_INCREMENT value. mysqli_insert_id() must be called immediately after the statement that generated the value."
    },
    "ƒ: mysqli_kill": {
        "type": "function",
        "label": "mysqli_kill( $mysql:mysqli, $process_id:int )",
        "apply": "mysqli_kill( $mysql:mysqli, $process_id:int )",
        "info": "To stop a running query you should use the SQL command KILL QUERY processid."
    },
    "ƒ: mysqli_more_results": {
        "type": "function",
        "label": "mysqli_more_results( $mysql:mysqli )",
        "apply": "mysqli_more_results( $mysql:mysqli )",
        "info": "Indicates if one or more result sets are available from a previous call to mysqli_multi_query()."
    },
    "ƒ: mysqli_multi_query": {
        "type": "function",
        "label": "mysqli_multi_query( $mysql:mysqli, $query:string )",
        "apply": "mysqli_multi_query( $mysql:mysqli, $query:string )",
        "info": "Executing CALL statements for stored procedures can produce multiple result sets. If the stored procedure contains SELECT statements, the result sets are returned in the order that they are produced as the procedure executes. In general, the caller cannot know how many result sets a procedure will return and must be prepared to retrieve multiple results. The final result from the procedure is a status result that includes no result set. The status indicates whether the procedure succeeded or an error occurred."
    },
    "ƒ: mysqli_next_result": {
        "type": "function",
        "label": "mysqli_next_result( $mysql:mysqli )",
        "apply": "mysqli_next_result( $mysql:mysqli )",
        "info": "Prepares next result set from a previous call to mysqli_multi_query() which can be retrieved by mysqli_store_result() or mysqli_use_result()."
    },
    "ƒ: mysqli_options": {
        "type": "function",
        "label": "mysqli_options( $mysql:mysqli, $option:int, $value: )",
        "apply": "mysqli_options( $mysql:mysqli, $option:int, $value: )",
        "info": "mysqli_options() should be called after mysqli_init() and before mysqli_real_connect()."
    },
    "ƒ: mysqli_set_opt": {
        "type": "function",
        "label": "mysqli_set_opt( $mysql:mysqli, $option:int, $value: )",
        "apply": "mysqli_set_opt( $mysql:mysqli, $option:int, $value: )",
        "info": "This function is an alias of:  mysqli_options()."
    },
    "ƒ: mysqli_ping": {
        "type": "function",
        "label": "mysqli_ping( $mysql:mysqli )",
        "apply": "mysqli_ping( $mysql:mysqli )",
        "info": "This function can be used by clients that remain idle for a long while,to check whether the server has closed the connection and reconnect if necessary."
    },
    "ƒ: mysqli_poll": {
        "type": "function",
        "label": "mysqli_poll( $read:?array, $error:?array, $reject:array, $seconds:int, $microseconds:int )",
        "apply": "mysqli_poll( $read:?array, $error:?array, $reject:array, $seconds:int, $microseconds:int )",
        "info": "Available only with mysqlnd."
    },
    "ƒ: mysqli_prepare": {
        "type": "function",
        "label": "mysqli_prepare( $mysql:mysqli, $query:string )",
        "apply": "mysqli_prepare( $mysql:mysqli, $query:string )",
        "info": "The statement template can contain zero or more question mark (?) parameter markers\u2060\u2014also called placeholders.The parameter markers must be bound to application variables using mysqli_stmt_bind_param() before executing the statement."
    },
    "ƒ: mysqli_report": {
        "type": "function",
        "label": "mysqli_report( $flags:int )",
        "apply": "mysqli_report( $flags:int )",
        "info": "This function is an alias of:  mysqli_driver->report_mode "
    },
    "ƒ: mysqli_query": {
        "type": "function",
        "label": "mysqli_query( $mysql:mysqli, $query:string, $result_mode:int )",
        "apply": "mysqli_query( $mysql:mysqli, $query:string, $result_mode:int )",
        "info": "libmysqlclient on all platforms returns an error code 2006. This error message means server has gone away."
    },
    "ƒ: mysqli_real_connect": {
        "type": "function",
        "label": "mysqli_real_connect( $mysql:mysqli, $hostname:?string, $username:?string, $password:?string, $database:?string, $port:?int, $socket:?string, $flags:int )",
        "apply": "mysqli_real_connect( $mysql:mysqli, $hostname:?string, $username:?string, $password:?string, $database:?string, $port:?int, $socket:?string, $flags:int )",
        "info": "There is a flags parameter."
    },
    "ƒ: mysqli_real_escape_string": {
        "type": "function",
        "label": "mysqli_real_escape_string( $mysql:mysqli, $string:string )",
        "apply": "mysqli_real_escape_string( $mysql:mysqli, $string:string )",
        "info": "The character set must be set either at the server level, or with the API function mysqli_set_charset() for it to affect mysqli_real_escape_string(). See the concepts section on character sets for more information."
    },
    "ƒ: mysqli_escape_string": {
        "type": "function",
        "label": "mysqli_escape_string( $mysql:mysqli, $string:string )",
        "apply": "mysqli_escape_string( $mysql:mysqli, $string:string )",
        "info": "This function is an alias of:  mysqli_real_escape_string()."
    },
    "ƒ: mysqli_real_query": {
        "type": "function",
        "label": "mysqli_real_query( $mysql:mysqli, $query:string )",
        "apply": "mysqli_real_query( $mysql:mysqli, $query:string )",
        "info": "In order to determine if a given query should return a result set or not,see mysqli_field_count()."
    },
    "ƒ: mysqli_reap_async_query": {
        "type": "function",
        "label": "mysqli_reap_async_query( $mysql:mysqli )",
        "apply": "mysqli_reap_async_query( $mysql:mysqli )",
        "info": "Available only with mysqlnd."
    },
    "ƒ: mysqli_release_savepoint": {
        "type": "function",
        "label": "mysqli_release_savepoint( $mysql:mysqli, $name:string )",
        "apply": "mysqli_release_savepoint( $mysql:mysqli, $name:string )",
        "info": "This function is identical to executing $mysqli->query(\"RELEASE SAVEPOINT `$name`\");.This function does not trigger commit or rollback."
    },
    "ƒ: mysqli_rollback": {
        "type": "function",
        "label": "mysqli_rollback( $mysql:mysqli, $flags:int, $name:?string )",
        "apply": "mysqli_rollback( $mysql:mysqli, $flags:int, $name:?string )",
        "info": "Rollbacks the current transaction for the database."
    },
    "ƒ: mysqli_savepoint": {
        "type": "function",
        "label": "mysqli_savepoint( $mysql:mysqli, $name:string )",
        "apply": "mysqli_savepoint( $mysql:mysqli, $name:string )",
        "info": "This function is identical to executing $mysqli->query(\"SAVEPOINT `$name`\");"
    },
    "ƒ: mysqli_select_db": {
        "type": "function",
        "label": "mysqli_select_db( $mysql:mysqli, $database:string )",
        "apply": "mysqli_select_db( $mysql:mysqli, $database:string )",
        "info": "This function should only be used to change the default database for the connection. You can select the default database with 4th parameter in mysqli_connect()."
    },
    "ƒ: mysqli_set_charset": {
        "type": "function",
        "label": "mysqli_set_charset( $mysql:mysqli, $charset:string )",
        "apply": "mysqli_set_charset( $mysql:mysqli, $charset:string )",
        "info": "Sets the character set to be used when sending data from and to the database server."
    },
    "ƒ: mysqli_stmt_attr_get": {
        "type": "function",
        "label": "mysqli_stmt_attr_get( $statement:mysqli_stmt, $attribute:int )",
        "apply": "mysqli_stmt_attr_get( $statement:mysqli_stmt, $attribute:int )",
        "info": "Gets the current value of a statement attribute."
    },
    "ƒ: mysqli_stmt_attr_set": {
        "type": "function",
        "label": "mysqli_stmt_attr_set( $statement:mysqli_stmt, $attribute:int, $value:int )",
        "apply": "mysqli_stmt_attr_set( $statement:mysqli_stmt, $attribute:int, $value:int )",
        "info": "Used to modify the behavior of a prepared statement. This function may be called multiple times to set several attributes."
    },
    "ƒ: mysqli_stmt_bind_param": {
        "type": "function",
        "label": "mysqli_stmt_bind_param( $statement:mysqli_stmt, $types:string, $vars:mixed )",
        "apply": "mysqli_stmt_bind_param( $statement:mysqli_stmt, $types:string, $vars:mixed )",
        "info": "Care must be taken when using mysqli_stmt_bind_param() in conjunction with call_user_func_array(). Note that mysqli_stmt_bind_param()requires parameters to be passed by reference, whereas call_user_func_array()can accept as a parameter a list of variables that can represent references or values."
    },
    "ƒ: mysqli_stmt_bind_result": {
        "type": "function",
        "label": "mysqli_stmt_bind_result( $statement:mysqli_stmt, $vars:mixed )",
        "apply": "mysqli_stmt_bind_result( $statement:mysqli_stmt, $vars:mixed )",
        "info": "This functions is useful for simple results. To retrieve iterable result set, or fetch each row as an array or object,use mysqli_stmt_get_result()."
    },
    "ƒ: mysqli_stmt_close": {
        "type": "function",
        "label": "mysqli_stmt_close( $statement:mysqli_stmt )",
        "apply": "mysqli_stmt_close( $statement:mysqli_stmt )",
        "info": "Closes a prepared statement. mysqli_stmt_close() also deallocates the statement handle. If the current statement has pending or unread results, this function cancels them so that the next query can be executed."
    },
    "ƒ: mysqli_stmt_data_seek": {
        "type": "function",
        "label": "mysqli_stmt_data_seek( $statement:mysqli_stmt, $offset:int )",
        "apply": "mysqli_stmt_data_seek( $statement:mysqli_stmt, $offset:int )",
        "info": "This function works only on the buffered internal result set.mysqli_stmt_store_result() must be called prior to mysqli_stmt_data_seek()."
    },
    "ƒ: mysqli_stmt_errno": {
        "type": "function",
        "label": "mysqli_stmt_errno( $statement:mysqli_stmt )",
        "apply": "mysqli_stmt_errno( $statement:mysqli_stmt )",
        "info": "Returns the error code for the most recently invoked statement function that can succeed or fail."
    },
    "ƒ: mysqli_stmt_error": {
        "type": "function",
        "label": "mysqli_stmt_error( $statement:mysqli_stmt )",
        "apply": "mysqli_stmt_error( $statement:mysqli_stmt )",
        "info": "Returns a string containing the error message for the most recently invoked statement function that can succeed or fail."
    },
    "ƒ: mysqli_stmt_error_list": {
        "type": "function",
        "label": "mysqli_stmt_error_list( $statement:mysqli_stmt )",
        "apply": "mysqli_stmt_error_list( $statement:mysqli_stmt )",
        "info": "Returns an array of errors for the most recently invoked statement function that can succeed or fail."
    },
    "ƒ: mysqli_stmt_fetch": {
        "type": "function",
        "label": "mysqli_stmt_fetch( $statement:mysqli_stmt )",
        "apply": "mysqli_stmt_fetch( $statement:mysqli_stmt )",
        "info": "Data are transferred unbuffered without calling mysqli_stmt_store_result() which can decrease performance (but reduces memory cost)."
    },
    "ƒ: mysqli_stmt_field_count": {
        "type": "function",
        "label": "mysqli_stmt_field_count( $statement:mysqli_stmt )",
        "apply": "mysqli_stmt_field_count( $statement:mysqli_stmt )",
        "info": "Returns the number of columns in the prepared statement."
    },
    "ƒ: mysqli_stmt_free_result": {
        "type": "function",
        "label": "mysqli_stmt_free_result( $statement:mysqli_stmt )",
        "apply": "mysqli_stmt_free_result( $statement:mysqli_stmt )",
        "info": "Frees the result memory associated with the statement, which was allocated by mysqli_stmt_store_result()."
    },
    "ƒ: mysqli_stmt_get_result": {
        "type": "function",
        "label": "mysqli_stmt_get_result( $statement:mysqli_stmt )",
        "apply": "mysqli_stmt_get_result( $statement:mysqli_stmt )",
        "info": "This function cannot be used together with mysqli_stmt_store_result(). Both of these functions retrieve the full result set from the MySQL server."
    },
    "ƒ: mysqli_stmt_get_warnings": {
        "type": "function",
        "label": "mysqli_stmt_get_warnings( $statement:mysqli_stmt )",
        "apply": "mysqli_stmt_get_warnings( $statement:mysqli_stmt )",
        "info": "This function is currently not documented; only its argument list is available."
    },
    "ƒ: mysqli_stmt_init": {
        "type": "function",
        "label": "mysqli_stmt_init( $mysql:mysqli )",
        "apply": "mysqli_stmt_init( $mysql:mysqli )",
        "info": "Any subsequent calls to any mysqli_stmt function will fail until mysqli_stmt_prepare() was called."
    },
    "ƒ: mysqli_stmt_insert_id": {
        "type": "function",
        "label": "mysqli_stmt_insert_id( $statement:mysqli_stmt )",
        "apply": "mysqli_stmt_insert_id( $statement:mysqli_stmt )",
        "info": "This function is currently not documented; only its argument list is available."
    },
    "ƒ: mysqli_stmt_more_results": {
        "type": "function",
        "label": "mysqli_stmt_more_results( $statement:mysqli_stmt )",
        "apply": "mysqli_stmt_more_results( $statement:mysqli_stmt )",
        "info": "Available only with mysqlnd."
    },
    "ƒ: mysqli_stmt_next_result": {
        "type": "function",
        "label": "mysqli_stmt_next_result( $statement:mysqli_stmt )",
        "apply": "mysqli_stmt_next_result( $statement:mysqli_stmt )",
        "info": "Prior to PHP 8.1.0, available only with mysqlnd."
    },
    "ƒ: mysqli_stmt_num_rows": {
        "type": "function",
        "label": "mysqli_stmt_num_rows( $statement:mysqli_stmt )",
        "apply": "mysqli_stmt_num_rows( $statement:mysqli_stmt )",
        "info": "This function returns 0 unless all rows have been fetched from the server."
    },
    "ƒ: mysqli_stmt_param_count": {
        "type": "function",
        "label": "mysqli_stmt_param_count( $statement:mysqli_stmt )",
        "apply": "mysqli_stmt_param_count( $statement:mysqli_stmt )",
        "info": "Returns the number of parameter markers present in the prepared statement."
    },
    "ƒ: mysqli_stmt_prepare": {
        "type": "function",
        "label": "mysqli_stmt_prepare( $statement:mysqli_stmt, $query:string )",
        "apply": "mysqli_stmt_prepare( $statement:mysqli_stmt, $query:string )",
        "info": "libmysqlclient on all platforms returns an error code 2006. This error message means server has gone away."
    },
    "ƒ: mysqli_stmt_reset": {
        "type": "function",
        "label": "mysqli_stmt_reset( $statement:mysqli_stmt )",
        "apply": "mysqli_stmt_reset( $statement:mysqli_stmt )",
        "info": "To prepare a statement with another query use function mysqli_stmt_prepare()."
    },
    "ƒ: mysqli_stmt_result_metadata": {
        "type": "function",
        "label": "mysqli_stmt_result_metadata( $statement:mysqli_stmt )",
        "apply": "mysqli_stmt_result_metadata( $statement:mysqli_stmt )",
        "info": "The result set returned by mysqli_stmt_result_metadata() contains only metadata. It does not contain any row results. The rows are obtained by using the statement handle with mysqli_stmt_fetch()."
    },
    "ƒ: mysqli_stmt_send_long_data": {
        "type": "function",
        "label": "mysqli_stmt_send_long_data( $statement:mysqli_stmt, $param_num:int, $data:string )",
        "apply": "mysqli_stmt_send_long_data( $statement:mysqli_stmt, $param_num:int, $data:string )",
        "info": "Allows to send parameter data to the server in pieces (or chunks), e.g. if the size of a blob exceeds the size of max_allowed_packet.This function can be called multiple times to send the parts of a character or binary data value for a column, which must be one of the TEXT or BLOB datatypes."
    },
    "ƒ: mysqli_stmt_store_result": {
        "type": "function",
        "label": "mysqli_stmt_store_result( $statement:mysqli_stmt )",
        "apply": "mysqli_stmt_store_result( $statement:mysqli_stmt )",
        "info": "It is unnecessary to call mysqli_stmt_store_result() for other queries,but if you do, it will not harm or cause any notable performance loss in all cases.You can detect whether the query produced a result set by checking if mysqli_stmt_result_metadata() returns false."
    },
    "ƒ: mysqli_stmt_sqlstate": {
        "type": "function",
        "label": "mysqli_stmt_sqlstate( $statement:mysqli_stmt )",
        "apply": "mysqli_stmt_sqlstate( $statement:mysqli_stmt )",
        "info": "Returns a string containing the SQLSTATE error code for the most recently invoked prepared statement function that can succeed or fail.The error code consists of five characters. '00000' means no error.The values are specified by ANSI SQL and ODBC. For a list of possible values, see \u00bb\u00a0http:\/\/dev.mysql.com\/doc\/mysql\/en\/error-handling.html."
    },
    "ƒ: mysqli_sqlstate": {
        "type": "function",
        "label": "mysqli_sqlstate( $mysql:mysqli )",
        "apply": "mysqli_sqlstate( $mysql:mysqli )",
        "info": "Note that not all MySQL errors are yet mapped to SQLSTATE's.The value HY000 (general error) is used for unmapped errors."
    },
    "ƒ: mysqli_ssl_set": {
        "type": "function",
        "label": "mysqli_ssl_set( $mysql:mysqli, $key:?string, $certificate:?string, $ca_certificate:?string, $ca_path:?string, $cipher_algos:?string )",
        "apply": "mysqli_ssl_set( $mysql:mysqli, $key:?string, $certificate:?string, $ca_certificate:?string, $ca_path:?string, $cipher_algos:?string )",
        "info": "Used for establishing secure connections using SSL. It must be called before mysqli_real_connect(). This function does nothing unless OpenSSL support is enabled."
    },
    "ƒ: mysqli_stat": {
        "type": "function",
        "label": "mysqli_stat( $mysql:mysqli )",
        "apply": "mysqli_stat( $mysql:mysqli )",
        "info": "mysqli_stat() returns a string containing information similar to that provided by the 'mysqladmin status' command.This includes uptime in seconds and the number of running threads,questions, reloads, and open tables."
    },
    "ƒ: mysqli_store_result": {
        "type": "function",
        "label": "mysqli_store_result( $mysql:mysqli, $mode:int )",
        "apply": "mysqli_store_result( $mysql:mysqli, $mode:int )",
        "info": "Transfers the result set from the last query on the database connection represented by the mysql parameter to be used with the mysqli_data_seek() function."
    },
    "ƒ: mysqli_thread_id": {
        "type": "function",
        "label": "mysqli_thread_id( $mysql:mysqli )",
        "apply": "mysqli_thread_id( $mysql:mysqli )",
        "info": "To kill a running query you can use the SQL command KILL QUERY processid."
    },
    "ƒ: mysqli_thread_safe": {
        "type": "function",
        "label": "mysqli_thread_safe()",
        "apply": "mysqli_thread_safe()",
        "info": "Tells whether the client library is compiled as thread-safe."
    },
    "ƒ: mysqli_use_result": {
        "type": "function",
        "label": "mysqli_use_result( $mysql:mysqli )",
        "apply": "mysqli_use_result( $mysql:mysqli )",
        "info": "The mysqli_use_result() function does not transfer the entire result set from the database and hence cannot be used functions such as mysqli_data_seek() to move to a particular row within the set. To use this functionality, the result set must be stored using mysqli_store_result(). One should not use mysqli_use_result() if a lot of processing on the client side is performed, since this will tie up the server and prevent other threads from updating any tables from which the data is being fetched."
    },
    "ƒ: mysqli_warning_count": {
        "type": "function",
        "label": "mysqli_warning_count( $mysql:mysqli )",
        "apply": "mysqli_warning_count( $mysql:mysqli )",
        "info": "For retrieving warning messages you can use the SQL command SHOW WARNINGS [limit row_count]."
    },
    "ƒ: mysqli_refresh": {
        "type": "function",
        "label": "mysqli_refresh( $mysql:mysqli, $flags:int )",
        "apply": "mysqli_refresh( $mysql:mysqli, $flags:int )",
        "info": "Flushes tables or caches, or resets the replication server information."
    }
}